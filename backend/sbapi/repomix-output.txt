This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-10T22:38:11.006Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
management/
  commands/
    sm.py
migrations/
  0001_initial.py
models/
  events/
    __init__.py
    base.py
    defending.py
    goalkeeper.py
    passing.py
    possession.py
    shooting.py
    summary.py
  __init__.py
  competition.py
  formation.py
  match.py
  player.py
  team.py
services/
  loaders/
    event_loader.py
    match_loader.py
  main/
    main.py
    test.py
    utils.py
  scripts/
    match_scraper.py
v1/
  serializers/
    base/
      __init__.py
      common.py
      competition.py
      events.py
      match.py
    player_analytics/
      match_events/
        base.py
        passing.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
    base.py
  services/
    events/
      __init__.py
      event_aggregator.py
    player_analytics/
      __init__.py
      base.py
      passing.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
  views/
    base/
      __init__.py
      base.py
      competition.py
      events.py
      match.py
    player_analytics/
      match_events.py
      match.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
  urls.py
  utils.py
admin.py
apps.py
tests.py

================================================================
Repository Files
================================================================

================
File: management/commands/sm.py
================
from django.core.management.base import BaseCommand
from sbapi.services.scripts.match_scraper import MatchScraper
from sbapi.services.main.main import getMatchUrls
import json
from pathlib import Path
import time
from datetime import datetime, timedelta
from selenium import webdriver


class Command(BaseCommand):
    help = 'Get match data and stores it in the database'
    BASE_URL = "https://1xbet.whoscored.com"

    def add_arguments(self, parser):
        # Original arguments remain the same
        parser.add_argument('-u', '--urls', nargs='+', type=str,
                            help='List of match URLs to scrape')
        parser.add_argument('-f', '--file', type=str,
                            help='JSON file with URLs')
        parser.add_argument('-d', '--delay', type=float, default=2,
                            help='Delay between scrapes in seconds (default: 2)')

        parser.add_argument('-l', '--league', type=str,
                            help='League to scrape (e.g., England-Premier-League)')
        parser.add_argument('-s', '--season', type=str,
                            help='Season to scrape (format: 2024/2025)')
        parser.add_argument('--preview', action='store_true',
                            help='Preview URLs without scraping')

    def format_time(self, seconds):
        return str(timedelta(seconds=int(seconds)))

    def get_league_urls(self, league: str, season: str):
        """Get URLs for all matches in a league season"""
        league_url = f"{self.BASE_URL}/Regions/252/Tournaments/2/{league}"

        driver = webdriver.Chrome()
        try:
            match_urls = getMatchUrls(
                comp_urls={league: league_url},
                competition=league,
                season=season
            )
            driver.quit()
            return match_urls
        except Exception as e:
            driver.quit()
            raise e

    def format_url(self, url_or_data):
        """Convert relative URLs to absolute URLs or extract URL from match data"""
        if isinstance(url_or_data, dict):
            relative_url = url_or_data.get('url', '')
        else:
            relative_url = url_or_data

        if relative_url.startswith('http'):
            return relative_url
        return f"{self.BASE_URL}{relative_url}"

    def save_urls(self, urls, filename):
        """Save URLs to a JSON file"""
        with open(filename, 'w') as f:
            json.dump(urls, f, indent=2)
        return filename

    def handle(self, *args, **options):
        start_time = time.time()
        urls = []

        # Handle league option
        if options.get('league'):
            if not options.get('season'):
                self.stderr.write(
                    "Season (-s) required when using league option")
                return

            try:
                self.stdout.write(
                    f"Getting matches for {options['league']} {options['season']}...")
                match_data = self.get_league_urls(
                    options['league'], options['season'])

                # Save league URLs for reference
                league_file = f"league_matches_{options['league']}_{options['season'].replace('/', '_')}.json"
                self.save_urls(match_data, league_file)
                self.stdout.write(f"\nFound {len(match_data)} matches")
                self.stdout.write(f"URLs saved to {league_file}")

                if options.get('preview'):
                    self.stdout.write("\nPreview mode - not scraping")
                    self.stdout.write(
                        "Review the JSON file and run again with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                confirm = input("\nProceed with scraping? [y/N]: ").lower()
                if confirm != 'y':
                    self.stdout.write("Aborted. You can run later with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                # Store full URLs from match data
                urls.extend(self.format_url(match) for match in match_data)

            except Exception as e:
                self.stderr.write(f"Error getting league matches: {str(e)}")
                return

        # Handle direct URLs
        if options.get('urls'):
            urls.extend(self.format_url(url) for url in options['urls'])

        # Handle file input
        if options.get('file'):
            try:
                with open(Path(options['file'])) as f:
                    file_data = json.load(f)
                    # Handle both URL lists and match data lists
                    if isinstance(file_data, list):
                        urls.extend(self.format_url(item)
                                    for item in file_data)
            except Exception as e:
                self.stderr.write(f"Error reading URLs file: {e}")
                return

        if not urls:
            self.stderr.write(
                "No URLs provided. Use -u/--urls, -f/--file, or -l/--league")
            return

        # Initialize counters
        total = len(urls)
        successful = failed = 0
        failed_urls = []

        # Progress header
        self.stdout.write(
            f"\nStarting scrape of {total} matches at {datetime.now().strftime('%H:%M:%S')}")
        self.stdout.write("-" * 50)

        # Process URLs
        for i, url in enumerate(urls, 1):
            loop_start = time.time()
            try:
                self.stdout.write(f"\nMatch {i}/{total}: {url}")
                scraper = MatchScraper()
                match_data = scraper.scrape_match(url)
                processed_data = scraper.process_match_data(match_data)

                successful += 1
                elapsed = time.time() - loop_start
                self.stdout.write(self.style.SUCCESS(
                    f"✓ Success - {len(processed_data['events'])} events "
                    f"({elapsed:.1f}s)"
                ))

            except Exception as e:
                failed += 1
                failed_urls.append(url)
                self.stdout.write(self.style.ERROR(f"✗ Failed: {str(e)}"))

            if i < total:  # Don't sleep after last URL
                time.sleep(options['delay'])

        # Final summary
        total_time = time.time() - start_time
        self.stdout.write("\n" + "=" * 50)
        self.stdout.write(self.style.SUCCESS(
            f"\nScraping completed in {self.format_time(total_time)}\n"
            f"✓ Successful: {successful}/{total}\n"
            f"✗ Failed: {failed}/{total}"
        ))

        # Save failed URLs if any
        if failed_urls:
            failed_file = f"failed_urls_{int(time.time())}.json"
            self.save_urls(failed_urls, failed_file)
            self.stdout.write(f"\nFailed URLs saved to {failed_file}")


"""
USAGE EXAMPLES:

# Get league matches with preview
python manage.py sm -l England-Premier-League -s 2024/2025 --preview

# Get and scrape league matches (with confirmation prompt)
python manage.py sm -l England-Premier-League -s 2024/2025

# Use previously saved league file
python manage.py sm -f league_matches_England-Premier-League_2024_2025.json

# Direct URLs and file still work as before
python manage.py sm -u http://url1 http://url2
python manage.py sm -f urls.json
python manage.py sm -u http://url1 -d 1.5
"""

================
File: migrations/0001_initial.py
================
# Generated by Django 5.1.2 on 2024-12-06 18:17

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Competition',
            fields=[
                ('competition_id', models.AutoField(
                    primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('country', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'indexes': [models.Index(fields=['name'], name='sbapi_compe_name_080072_idx'), models.Index(fields=['country'], name='sbapi_compe_country_2b45dd_idx')],
                'unique_together': {('name', 'country')},
            },
        ),
        migrations.CreateModel(
            name='Player',
            fields=[
                ('player_id', models.IntegerField(
                    primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('height', models.IntegerField(null=True)),
                ('weight', models.IntegerField(null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'indexes': [models.Index(fields=['name'], name='sbapi_playe_name_2f622a_idx')],
            },
        ),
        migrations.CreateModel(
            name='Season',
            fields=[
                ('season_id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=20)),
                ('is_current', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('competition', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.competition')),
            ],
        ),
        migrations.CreateModel(
            name='Match',
            fields=[
                ('match_id', models.IntegerField(
                    primary_key=True, serialize=False)),
                ('start_datetime', models.DateTimeField()),
                ('venue', models.CharField(max_length=200)),
                ('attendance', models.IntegerField(null=True)),
                ('referee_id', models.IntegerField(null=True)),
                ('referee_name', models.CharField(max_length=100, null=True)),
                ('home_manager_name', models.CharField(max_length=100, null=True)),
                ('away_manager_name', models.CharField(max_length=100, null=True)),
                ('home_team_average_age', models.FloatField(null=True)),
                ('away_team_average_age', models.FloatField(null=True)),
                ('home_score_ht', models.IntegerField()),
                ('away_score_ht', models.IntegerField()),
                ('home_score_ft', models.IntegerField()),
                ('away_score_ft', models.IntegerField()),
                ('home_score_et', models.IntegerField(null=True)),
                ('away_score_et', models.IntegerField(null=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('season', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.season')),
            ],
            options={
                'verbose_name': 'Match',
                'verbose_name_plural': 'Matches',
            },
        ),
        migrations.CreateModel(
            name='Team',
            fields=[
                ('team_id', models.IntegerField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('country', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'Team',
                'verbose_name_plural': 'Teams',
                'indexes': [models.Index(fields=['name'], name='sbapi_team_name_4b83cb_idx'), models.Index(fields=['country'], name='sbapi_team_country_075517_idx')],
            },
        ),
        migrations.CreateModel(
            name='SummaryEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('card_type', models.CharField(max_length=20, null=True)),
                ('yellow_card', models.BooleanField(default=False)),
                ('red_card', models.BooleanField(default=False)),
                ('second_yellow', models.BooleanField(default=False)),
                ('void_yellow_card', models.BooleanField(default=False)),
                ('foul_committed', models.BooleanField(default=False)),
                ('foul_given', models.BooleanField(default=False)),
                ('penalty_conceded', models.BooleanField(default=False)),
                ('penalty_won', models.BooleanField(default=False)),
                ('offside_given', models.BooleanField(default=False)),
                ('offside_provoked', models.BooleanField(default=False)),
                ('sub_on', models.BooleanField(default=False)),
                ('sub_off', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Summary',
                'verbose_name_plural': 'Events - Summary',
                'db_table': 'sbapi_event_summary',
            },
        ),
        migrations.CreateModel(
            name='ShootingEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('big_chance_missed', models.BooleanField(default=False)),
                ('big_chance_scored', models.BooleanField(default=False)),
                ('close_miss_high', models.BooleanField(default=False)),
                ('close_miss_high_left', models.BooleanField(default=False)),
                ('close_miss_high_right', models.BooleanField(default=False)),
                ('close_miss_left', models.BooleanField(default=False)),
                ('close_miss_right', models.BooleanField(default=False)),
                ('is_goal', models.BooleanField(default=False)),
                ('goal_counter', models.BooleanField(default=False)),
                ('goal_head', models.BooleanField(default=False)),
                ('goal_left_foot', models.BooleanField(default=False)),
                ('goal_right_foot', models.BooleanField(default=False)),
                ('goal_normal', models.BooleanField(default=False)),
                ('goal_open_play', models.BooleanField(default=False)),
                ('goal_set_piece', models.BooleanField(default=False)),
                ('goal_obox', models.BooleanField(default=False)),
                ('goal_obp', models.BooleanField(default=False)),
                ('goal_penalty_area', models.BooleanField(default=False)),
                ('goal_six_yard_box', models.BooleanField(default=False)),
                ('goal_mouth_y', models.FloatField(null=True)),
                ('goal_mouth_z', models.FloatField(null=True)),
                ('is_shot', models.BooleanField(default=False)),
                ('shot_blocked', models.BooleanField(default=False)),
                ('shot_counter', models.BooleanField(default=False)),
                ('shot_direct_corner', models.BooleanField(default=False)),
                ('shot_on_post', models.BooleanField(default=False)),
                ('shot_on_target', models.BooleanField(default=False)),
                ('shot_off_target', models.BooleanField(default=False)),
                ('shot_off_target_inside_box', models.BooleanField(default=False)),
                ('shots_total', models.BooleanField(default=False)),
                ('shot_body_type', models.CharField(max_length=20, null=True)),
                ('shot_head', models.BooleanField(default=False)),
                ('shot_left_foot', models.BooleanField(default=False)),
                ('shot_right_foot', models.BooleanField(default=False)),
                ('shot_obox_total', models.BooleanField(default=False)),
                ('shot_obp', models.BooleanField(default=False)),
                ('shot_penalty_area', models.BooleanField(default=False)),
                ('shot_six_yard_box', models.BooleanField(default=False)),
                ('shot_open_play', models.BooleanField(default=False)),
                ('shot_set_piece', models.BooleanField(default=False)),
                ('penalty_missed', models.BooleanField(default=False)),
                ('penalty_scored', models.BooleanField(default=False)),
                ('penalty_shootout_missed_off_target',
                 models.BooleanField(default=False)),
                ('penalty_shootout_scored', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Shooting',
                'verbose_name_plural': 'Events - Shooting ',
                'db_table': 'sbapi_event_shooting',
            },
        ),
        migrations.CreateModel(
            name='PossessionEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('corner_awarded', models.BooleanField(default=False)),
                ('dispossessed', models.BooleanField(default=False)),
                ('turnover', models.BooleanField(default=False)),
                ('overrun', models.BooleanField(default=False)),
                ('dribble_lastman', models.BooleanField(default=False)),
                ('dribble_lost', models.BooleanField(default=False)),
                ('dribble_won', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Possession',
                'verbose_name_plural': 'Events - Possession',
                'db_table': 'sbapi_event_possession',
            },
        ),
        migrations.CreateModel(
            name='PassEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('pass_accurate', models.BooleanField(default=False)),
                ('pass_inaccurate', models.BooleanField(default=False)),
                ('pass_accuracy', models.BooleanField(default=False)),
                ('assist', models.BooleanField(default=False)),
                ('assist_corner', models.BooleanField(default=False)),
                ('assist_cross', models.BooleanField(default=False)),
                ('assist_freekick', models.BooleanField(default=False)),
                ('assist_other', models.BooleanField(default=False)),
                ('assist_throughball', models.BooleanField(default=False)),
                ('assist_throwin', models.BooleanField(default=False)),
                ('intentional_assist', models.BooleanField(default=False)),
                ('key_pass_corner', models.BooleanField(default=False)),
                ('key_pass_cross', models.BooleanField(default=False)),
                ('key_pass_freekick', models.BooleanField(default=False)),
                ('key_pass_long', models.BooleanField(default=False)),
                ('key_pass_other', models.BooleanField(default=False)),
                ('key_pass_short', models.BooleanField(default=False)),
                ('key_pass_throughball', models.BooleanField(default=False)),
                ('key_pass_throwin', models.BooleanField(default=False)),
                ('pass_key', models.BooleanField(default=False)),
                ('pass_corner', models.BooleanField(default=False)),
                ('pass_corner_accurate', models.BooleanField(default=False)),
                ('pass_corner_inaccurate', models.BooleanField(default=False)),
                ('pass_cross_accurate', models.BooleanField(default=False)),
                ('pass_cross_blocked_defensive',
                 models.BooleanField(default=False)),
                ('pass_cross_inaccurate', models.BooleanField(default=False)),
                ('pass_freekick', models.BooleanField(default=False)),
                ('pass_freekick_accurate', models.BooleanField(default=False)),
                ('pass_freekick_inaccurate', models.BooleanField(default=False)),
                ('pass_back', models.BooleanField(default=False)),
                ('pass_back_zone_inaccurate', models.BooleanField(default=False)),
                ('pass_forward', models.BooleanField(default=False)),
                ('pass_forward_zone_accurate', models.BooleanField(default=False)),
                ('pass_left', models.BooleanField(default=False)),
                ('pass_right', models.BooleanField(default=False)),
                ('pass_chipped', models.BooleanField(default=False)),
                ('pass_head', models.BooleanField(default=False)),
                ('pass_left_foot', models.BooleanField(default=False)),
                ('pass_right_foot', models.BooleanField(default=False)),
                ('pass_long_ball_accurate', models.BooleanField(default=False)),
                ('pass_long_ball_inaccurate', models.BooleanField(default=False)),
                ('short_pass_accurate', models.BooleanField(default=False)),
                ('short_pass_inaccurate', models.BooleanField(default=False)),
                ('pass_through_ball_accurate', models.BooleanField(default=False)),
                ('pass_through_ball_inaccurate',
                 models.BooleanField(default=False)),
                ('big_chance_created', models.BooleanField(default=False)),
                ('successful_final_third_passes',
                 models.BooleanField(default=False)),
                ('throw_in', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Passing',
                'verbose_name_plural': 'Events - Passing',
                'db_table': 'sbapi_event_passing',
            },
        ),
        migrations.CreateModel(
            name='MatchPlayer',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('shirt_no', models.IntegerField()),
                ('position', models.CharField(max_length=20)),
                ('is_first_eleven', models.BooleanField()),
                ('is_man_of_match', models.BooleanField(default=False)),
                ('age', models.IntegerField()),
                ('height', models.IntegerField(null=True)),
                ('weight', models.IntegerField(null=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Match - Player Information',
                'verbose_name_plural': 'Matches - Player Information',
            },
        ),
        migrations.AddField(
            model_name='match',
            name='away_team',
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name='away_matches',
                to='sbapi.team'),
        ),
        migrations.AddField(
            model_name='match',
            name='home_team',
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name='home_matches',
                to='sbapi.team'),
        ),
        migrations.CreateModel(
            name='GoalkeeperEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('is_collected', models.BooleanField(default=False)),
                ('keeper_claim_high_lost', models.BooleanField(default=False)),
                ('keeper_claim_high_won', models.BooleanField(default=False)),
                ('keeper_claim_lost', models.BooleanField(default=False)),
                ('keeper_claim_won', models.BooleanField(default=False)),
                ('keeper_diving_save', models.BooleanField(default=False)),
                ('keeper_missed', models.BooleanField(default=False)),
                ('keeper_one_to_one_won', models.BooleanField(default=False)),
                ('standing_save', models.BooleanField(default=False)),
                ('save_feet', models.BooleanField(default=False)),
                ('save_hands', models.BooleanField(default=False)),
                ('save_high_centre', models.BooleanField(default=False)),
                ('save_high_left', models.BooleanField(default=False)),
                ('save_high_right', models.BooleanField(default=False)),
                ('save_low_centre', models.BooleanField(default=False)),
                ('save_low_left', models.BooleanField(default=False)),
                ('save_low_right', models.BooleanField(default=False)),
                ('save_obox', models.BooleanField(default=False)),
                ('save_obp', models.BooleanField(default=False)),
                ('save_penalty_area', models.BooleanField(default=False)),
                ('save_six_yard_box', models.BooleanField(default=False)),
                ('keeper_save_in_the_box', models.BooleanField(default=False)),
                ('keeper_save_total', models.BooleanField(default=False)),
                ('keeper_penalty_saved', models.BooleanField(default=False)),
                ('penalty_shootout_saved', models.BooleanField(default=False)),
                ('penalty_shootout_saved_gk', models.BooleanField(default=False)),
                ('penalty_shootout_conceded_gk',
                 models.BooleanField(default=False)),
                ('keeper_smother', models.BooleanField(default=False)),
                ('keeper_sweeper_lost', models.BooleanField(default=False)),
                ('parried_danger', models.BooleanField(default=False)),
                ('parried_safe', models.BooleanField(default=False)),
                ('punches', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Goalkeeper',
                'verbose_name_plural': 'Events - Goalkeeper',
                'db_table': 'sbapi_event_goalkeeping',
            },
        ),
        migrations.CreateModel(
            name='Formation',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('formation_name', models.CharField(max_length=10)),
                ('captain_player_id', models.IntegerField()),
                ('start_minute', models.IntegerField()),
                ('end_minute', models.IntegerField()),
                ('player_ids', models.JSONField(default=list)),
                ('jersey_numbers', models.JSONField(default=list)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Match Formation',
                'verbose_name_plural': 'Match Formations',
            },
        ),
        migrations.CreateModel(
            name='DefendingEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('is_tackle', models.BooleanField(default=False,
                 help_text='Quick identifier for tackle events')),
                ('is_interception', models.BooleanField(default=False,
                 help_text="Quick identifier for interception events. Occurs when a player reads and intercepts an opponent's pass by moving into the line of the intended pass")),
                ('is_clearance', models.BooleanField(default=False,
                 help_text='Quick identifier for clearance events. Represents an action where a player attempts to get the ball away from a dangerous zone')),
                ('is_ball_recovery', models.BooleanField(default=False,
                 help_text='Quick identifier for ball recovery events. Occurs when a player recovers the ball in a situation where neither team has possession')),
                ('aerial_success', models.BooleanField(default=False,
                 help_text='Indicates successful aerial duel')),
                ('duel_aerial_lost', models.BooleanField(
                    default=False, help_text='Indicates lost aerial duel')),
                ('duel_aerial_won', models.BooleanField(
                    default=False, help_text='Indicates won aerial duel')),
                ('blocked_x', models.FloatField(
                    help_text='X-coordinate of block location', null=True)),
                ('blocked_y', models.FloatField(
                    help_text='Y-coordinate of block location', null=True)),
                ('clearance_effective', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was effective')),
                ('clearance_head', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was made with the head')),
                ('clearance_off_the_line', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was made off the goal line')),
                ('clearance_total', models.BooleanField(default=False,
                 help_text='Total clearance indicator (purpose needs clarification)')),
                ('challenge_lost', models.BooleanField(default=False,
                 help_text='Indicates when a player is dribbled past and fails to win the ball')),
                ('defensive_duel', models.BooleanField(default=False,
                 help_text='Indicates involvement in a defensive duel')),
                ('offensive_duel', models.BooleanField(default=False,
                 help_text='Indicates involvement in an offensive duel')),
                ('error_leads_to_goal', models.BooleanField(default=False,
                 help_text='Indicates if a defensive error led to a goal')),
                ('error_leads_to_shot', models.BooleanField(default=False,
                 help_text='Indicates if a defensive error led to a shot')),
                ('goal_own', models.BooleanField(default=False,
                 help_text='Indicates if an own goal was scored')),
                ('interception_all', models.BooleanField(default=False,
                 help_text='Indicates any type of interception')),
                ('interception_in_the_box', models.BooleanField(default=False,
                 help_text='Indicates interception made inside the penalty box')),
                ('interception_won', models.BooleanField(
                    default=False, help_text='Indicates successful interception')),
                ('outfielder_block', models.BooleanField(default=False,
                 help_text='Indicates block made by an outfield player')),
                ('outfielder_blocked_pass', models.BooleanField(default=False,
                 help_text='Indicates blocked pass by an outfield player. Similar to interception but with less reading of the pass')),
                ('six_yard_block', models.BooleanField(default=False,
                 help_text='Indicates block made in the six-yard box')),
                ('tackle_last_man', models.BooleanField(default=False,
                 help_text='Indicates tackle made as the last defending player')),
                ('tackle_lost', models.BooleanField(default=False,
                 help_text='Indicates tackle where the ball goes to an opposition player')),
                ('tackle_won', models.BooleanField(default=False,
                 help_text='Indicates tackle where the tackler or teammate regains possession, or the ball goes safely out of play')),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Defending',
                'verbose_name_plural': 'Events - Defending',
                'db_table': 'sbapi_event_defending',
            },
        ),
        migrations.AddIndex(
            model_name='season',
            index=models.Index(
                fields=['is_current'],
                name='sbapi_seaso_is_curr_bc5403_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='season',
            unique_together={('competition', 'name')},
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_787265_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__b52555_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_ef028a_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_376715_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__aceb7a_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['card_type'],
                name='sbapi_event_card_ty_01bd0b_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['foul_committed'],
                name='sbapi_event_foul_co_270625_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'penalty_conceded',
                    'penalty_won'],
                name='sbapi_event_penalty_c50ee7_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'sub_on',
                    'sub_off'],
                name='sbapi_event_sub_on_919522_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_600bbe_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__4d3a71_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_3a6f6a_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_678115_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__ca4bb8_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['is_goal'],
                name='sbapi_event_is_goal_c0daab_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['is_shot'],
                name='sbapi_event_is_shot_d8c23b_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['shot_on_target'],
                name='sbapi_event_shot_on_496be4_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['big_chance_scored'],
                name='sbapi_event_big_cha_d3b014_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_0de657_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__08d47c_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_082591_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_0506ad_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__8649c9_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['dribble_won'],
                name='sbapi_event_dribble_336758_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['dispossessed'],
                name='sbapi_event_disposs_3e2477_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['touches'],
                name='sbapi_event_touches_689c94_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_aefb3b_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__6abd5a_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_054a1e_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_14931d_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__c67f83_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['pass_accurate'],
                name='sbapi_event_pass_ac_ba36de_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['assist'],
                name='sbapi_event_assist_d8fa64_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['pass_key'],
                name='sbapi_event_pass_ke_26ed2a_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['big_chance_created'],
                name='sbapi_event_big_cha_ff1221_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=['position'],
                name='sbapi_match_positio_d56e17_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=[
                    'match',
                    'team'],
                name='sbapi_match_match_i_d49a36_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=['is_first_eleven'],
                name='sbapi_match_is_firs_ad26eb_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='matchplayer',
            unique_together={('match', 'player', 'team')},
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['start_datetime'],
                name='sbapi_match_start_d_b479c2_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['home_team'],
                name='sbapi_match_home_te_17af12_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['away_team'],
                name='sbapi_match_away_te_c1e3d5_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['referee_id'],
                name='sbapi_match_referee_20666a_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['season'],
                name='sbapi_match_season__d292ef_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_13e256_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__c1b44b_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_08b887_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_dcaa0e_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__6e974b_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_diving_save'],
                name='sbapi_event_keeper__21d8d4_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_save_total'],
                name='sbapi_event_keeper__a677af_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_penalty_saved'],
                name='sbapi_event_keeper__16ced3_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=['formation_name'],
                name='sbapi_forma_formati_ab138a_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=['captain_player_id'],
                name='sbapi_forma_captain_756fc3_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=[
                    'match',
                    'team'],
                name='sbapi_forma_match_i_982726_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='formation',
            unique_together={('match', 'team', 'start_minute', 'end_minute')},
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_6313f6_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__083cd7_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_27df09_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_e9ff91_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__cb714d_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_tackle'],
                name='sbapi_event_is_tack_00e724_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_interception'],
                name='sbapi_event_is_inte_428499_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_clearance'],
                name='sbapi_event_is_clea_e456d8_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['aerial_success'],
                name='sbapi_event_aerial__dc1179_idx'),
        ),
    ]

================
File: models/events/__init__.py
================
from .base import Event
from .passing import PassEvent
from .shooting import ShootingEvent
from .defending import DefendingEvent
from .goalkeeper import GoalkeeperEvent
from .possession import PossessionEvent
from .summary import SummaryEvent

__all__ = [
    'Event',
    'PassEvent',
    'ShootingEvent',
    'DefendingEvent',
    'GoalkeeperEvent',
    'PossessionEvent',
    'SummaryEvent'
]

================
File: models/events/base.py
================
from django.db import models


class Event(models.Model):
    """Base model for all match events, these fields are informative"""
    # Core identification
    # Django's auto-incrementing primary key
    id = models.AutoField(primary_key=True)
    # The original DataFrame id (2.755319e+09)
    source_id = models.BigIntegerField()
    # The original eventId that groups related actions (21, 22, etc)
    event_id = models.IntegerField()
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    player = models.ForeignKey(
        'sbapi.Player', null=True, on_delete=models.CASCADE)
    player_name = models.CharField(max_length=100, null=True)

    # Timing
    minute = models.IntegerField()  # Range: [0 to 102]
    second = models.FloatField(null=True)  # Range: [0.0 to 59.0]
    expanded_minute = models.IntegerField()  # Range: [0 to 108]
    # FirstHalf, SecondHalf, PenaltyShootout, FirstPeriodOfExtraTime, SecondPeriodOfExtraTime
    period = models.CharField(max_length=20)
    max_minute = models.IntegerField()  # [102]

    # Location
    x = models.FloatField()  # Range: [0.0 to 100]
    y = models.FloatField()  # Range: [0.0 to 100.0]
    end_x = models.FloatField(null=True)  # Range: [0.0 to 100.0]
    end_y = models.FloatField(null=True)  # Range: [0.0 to 100.0]

    # Did this event involve a touch?
    is_touch = models.BooleanField(default=False)
    touches = models.BooleanField(default=False)

    # Field position
    defensive_third = models.BooleanField(default=False)
    mid_third = models.BooleanField(default=False)
    final_third = models.BooleanField(default=False)

    # Type and outcome
    # Pass, Shot, etc. (see type in docs/)
    type = models.CharField(max_length=50)
    outcome_type = models.CharField(
        max_length=20, null=True)  # Successful, Unsuccessful

    # Related events/players
    # Changed to FloatField, Range: [63.0 to 924.0]
    related_event_id = models.FloatField(null=True)
    # Changed to FloatField, Range: [22079.0 to 494120.0]
    related_player_id = models.FloatField(null=True)

    # Match context
    h_a = models.CharField(max_length=1)  # 'h' or 'a'

    # OpenPlay, SetPiece, etc.
    situation = models.CharField(max_length=50, null=True)
    """Regular an attempt created from an open-play attack.
Set-piece  an attempt created where the ball starts from an indirect free-kick dead-ball situation.
Throw-in  an attempt created from a throw-in.
Direct free-kick  an attempt at goal directly from free-kick situation.
Direct corner  a goal scored directly from a corner by the corner-taker, or an attempt created from a corner situation.
Fast break  an attempt created after a team quickly turn defence into attack, winning the ball in their own half (counter-attack).
Penalty  The penalty attempt itself, any follow-up shot would be classed as a set-piece attempt. Passed penalties are also counted as penalty pattern of play"""

    # Additional data
    qualifiers = models.JSONField(default=list)
    satisfied_events_types = models.JSONField(default=list)

    class Meta:
        abstract = True
        indexes = [
            models.Index(fields=['match', 'minute']),
            models.Index(fields=['player', 'type']),
            models.Index(fields=['team', 'type']),
            models.Index(fields=['event_id']),
            # Meaningful for finding related actions
            # Index for the original DataFrame id
            models.Index(fields=['source_id']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['match', 'source_id'],
                name='%(app_label)s_%(class)s_unique_match_source'
            )
        ]

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: models/events/defending.py
================
from django.db import models
from .base import Event


class DefendingEvent(Event):
    """
    Model representing defensive actions in football/soccer matches.
    Inherits from base Event model.

    This model tracks various defensive actions including tackles, interceptions,
    clearances, aerial duels, and defensive errors.
    """

    # Core defensive actions
    is_tackle = models.BooleanField(
        default=False,
        help_text="Quick identifier for tackle events"
    )
    is_interception = models.BooleanField(
        default=False,
        help_text="Quick identifier for interception events. Occurs when a player reads and "
        "intercepts an opponent's pass by moving into the line of the intended pass"
    )
    is_clearance = models.BooleanField(
        default=False,
        help_text="Quick identifier for clearance events. Represents an action where "
        "a player attempts to get the ball away from a dangerous zone"
    )
    is_ball_recovery = models.BooleanField(
        default=False,
        help_text="Quick identifier for ball recovery events. Occurs when a player recovers "
        "the ball in a situation where neither team has possession"
    )

    # Aerial duels
    aerial_success = models.BooleanField(
        default=False,
        help_text="Indicates successful aerial duel"
    )
    duel_aerial_lost = models.BooleanField(
        default=False,
        help_text="Indicates lost aerial duel"
    )
    duel_aerial_won = models.BooleanField(
        default=False,
        help_text="Indicates won aerial duel"
    )

    # Block coordinates
    blocked_x = models.FloatField(
        null=True,
        help_text="X-coordinate of block location"
    )
    blocked_y = models.FloatField(
        null=True,
        help_text="Y-coordinate of block location"
    )

    # Clearance types
    clearance_effective = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was effective"
    )
    clearance_head = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made with the head"
    )
    clearance_off_the_line = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made off the goal line"
    )
    clearance_total = models.BooleanField(
        default=False,
        help_text="Total clearance indicator (purpose needs clarification)"
    )

    # Duels and challenges
    challenge_lost = models.BooleanField(
        default=False,
        help_text="Indicates when a player is dribbled past and fails to win the ball"
    )
    defensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in a defensive duel"
    )
    offensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in an offensive duel"
    )

    # Defensive errors
    error_leads_to_goal = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a goal"
    )
    error_leads_to_shot = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a shot"
    )
    goal_own = models.BooleanField(
        default=False,
        help_text="Indicates if an own goal was scored"
    )

    # Interception details
    interception_all = models.BooleanField(
        default=False,
        help_text="Indicates any type of interception"
    )
    interception_in_the_box = models.BooleanField(
        default=False,
        help_text="Indicates interception made inside the penalty box"
    )
    interception_won = models.BooleanField(
        default=False,
        help_text="Indicates successful interception"
    )

    # Block types
    outfielder_block = models.BooleanField(
        default=False,
        help_text="Indicates block made by an outfield player (for shots?)"
    )
    outfielder_blocked_pass = models.BooleanField(
        default=False,
        help_text="Indicates blocked pass by an outfield player. Similar to interception "
        "but with less reading of the pass"
    )
    six_yard_block = models.BooleanField(
        default=False,
        help_text="Indicates block made in the six-yard box"
    )

    # Tackle outcomes
    tackle_last_man = models.BooleanField(
        default=False,
        help_text="Indicates tackle made as the last defending player"
    )
    tackle_lost = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the ball goes to an opposition player"
    )
    tackle_won = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the tackler or teammate regains possession, "
        "or the ball goes safely out of play"
    )

    class Meta:
        db_table = 'sbapi_event_defending'
        verbose_name = 'Events - Defending'
        verbose_name_plural = 'Events - Defending'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['is_tackle']),
            models.Index(fields=['is_interception']),
            models.Index(fields=['is_clearance']),
            models.Index(fields=['aerial_success']),
        ]

================
File: models/events/goalkeeper.py
================
from django.db import models
from .base import Event


class GoalkeeperEvent(Event):
    """Goalkeeper-specific event details"""
    # Core actions
    is_collected = models.BooleanField(default=False)

    # Claims
    keeper_claim_high_lost = models.BooleanField(default=False)
    keeper_claim_high_won = models.BooleanField(default=False)
    keeper_claim_lost = models.BooleanField(default=False)
    keeper_claim_won = models.BooleanField(default=False)

    # Save types
    keeper_diving_save = models.BooleanField(default=False)
    keeper_missed = models.BooleanField(default=False)
    keeper_one_to_one_won = models.BooleanField(default=False)
    standing_save = models.BooleanField(default=False)
    save_feet = models.BooleanField(default=False)
    save_hands = models.BooleanField(default=False)

    # Save locations
    save_high_centre = models.BooleanField(default=False)
    save_high_left = models.BooleanField(default=False)
    save_high_right = models.BooleanField(default=False)
    save_low_centre = models.BooleanField(default=False)
    save_low_left = models.BooleanField(default=False)
    save_low_right = models.BooleanField(default=False)

    # Save zones
    save_obox = models.BooleanField(default=False)  # Outside box
    save_obp = models.BooleanField(default=False)   # Outside box proper
    save_penalty_area = models.BooleanField(default=False)
    save_six_yard_box = models.BooleanField(default=False)
    keeper_save_in_the_box = models.BooleanField(default=False)
    keeper_save_total = models.BooleanField(default=False)

    # Penalties
    keeper_penalty_saved = models.BooleanField(default=False)
    penalty_shootout_saved = models.BooleanField(default=False)
    penalty_shootout_saved_gk = models.BooleanField(default=False)
    penalty_shootout_conceded_gk = models.BooleanField(default=False)

    # Other actions
    keeper_smother = models.BooleanField(default=False)
    keeper_sweeper_lost = models.BooleanField(default=False)
    parried_danger = models.BooleanField(default=False)
    parried_safe = models.BooleanField(default=False)
    punches = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_goalkeeping'  # Specific table name
        verbose_name = 'Events - Goalkeeper'
        verbose_name_plural = 'Events - Goalkeeper'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['keeper_diving_save']),
            models.Index(fields=['keeper_save_total']),
            models.Index(fields=['keeper_penalty_saved']),
        ]

================
File: models/events/passing.py
================
from django.db import models
from .base import Event


class PassEvent(Event):
    """Pass-specific event details"""
    # Core pass attributes
    pass_accurate = models.BooleanField(default=False)
    pass_inaccurate = models.BooleanField(default=False)
    pass_accuracy = models.BooleanField(default=False)

    # Assist types
    assist = models.BooleanField(default=False)
    assist_corner = models.BooleanField(default=False)
    assist_cross = models.BooleanField(default=False)
    assist_freekick = models.BooleanField(default=False)
    assist_other = models.BooleanField(default=False)
    assist_throughball = models.BooleanField(default=False)
    assist_throwin = models.BooleanField(default=False)
    intentional_assist = models.BooleanField(default=False)

    # Key pass types
    key_pass_corner = models.BooleanField(default=False)
    key_pass_cross = models.BooleanField(default=False)
    key_pass_freekick = models.BooleanField(default=False)
    key_pass_long = models.BooleanField(default=False)
    key_pass_other = models.BooleanField(default=False)
    key_pass_short = models.BooleanField(default=False)
    key_pass_throughball = models.BooleanField(default=False)
    key_pass_throwin = models.BooleanField(default=False)
    pass_key = models.BooleanField(default=False)

    # Corner passes
    pass_corner = models.BooleanField(default=False)
    pass_corner_accurate = models.BooleanField(default=False)
    pass_corner_inaccurate = models.BooleanField(default=False)

    # Cross passes
    pass_cross_accurate = models.BooleanField(default=False)
    pass_cross_blocked_defensive = models.BooleanField(default=False)
    pass_cross_inaccurate = models.BooleanField(default=False)

    # Freekick passes
    pass_freekick = models.BooleanField(default=False)
    pass_freekick_accurate = models.BooleanField(default=False)
    pass_freekick_inaccurate = models.BooleanField(default=False)

    # Pass direction/zone
    pass_back = models.BooleanField(default=False)
    pass_back_zone_inaccurate = models.BooleanField(default=False)
    pass_forward = models.BooleanField(default=False)
    pass_forward_zone_accurate = models.BooleanField(default=False)
    pass_left = models.BooleanField(default=False)
    pass_right = models.BooleanField(default=False)

    # Pass types
    pass_chipped = models.BooleanField(default=False)
    pass_head = models.BooleanField(default=False)
    pass_left_foot = models.BooleanField(default=False)
    pass_right_foot = models.BooleanField(default=False)

    # Long/short passes
    pass_long_ball_accurate = models.BooleanField(default=False)
    pass_long_ball_inaccurate = models.BooleanField(default=False)
    short_pass_accurate = models.BooleanField(default=False)
    short_pass_inaccurate = models.BooleanField(default=False)

    # Through balls
    pass_through_ball_accurate = models.BooleanField(default=False)
    pass_through_ball_inaccurate = models.BooleanField(default=False)

    # Additional characteristics
    big_chance_created = models.BooleanField(default=False)
    successful_final_third_passes = models.BooleanField(default=False)
    throw_in = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_passing'  # Specific table name
        verbose_name = 'Events - Passing'
        verbose_name_plural = 'Events - Passing'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['pass_accurate']),
            models.Index(fields=['assist']),
            models.Index(fields=['pass_key']),
            models.Index(fields=['big_chance_created']),
        ]

================
File: models/events/possession.py
================
# sbapi/models/events/possession.py
from django.db import models
from .base import Event


class PossessionEvent(Event):
    """Possession-related event details"""
    # Set pieces
    corner_awarded = models.BooleanField(
        default=False)  # recorded as h/a for conceded/won

    # Ball control
    dispossessed = models.BooleanField(default=False)
    turnover = models.BooleanField(default=False)
    overrun = models.BooleanField(default=False)

    # Dribbling
    dribble_lastman = models.BooleanField(default=False)
    dribble_lost = models.BooleanField(default=False)
    dribble_won = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_possession'  # Specific table name
        verbose_name = 'Events - Possession'
        verbose_name_plural = 'Events - Possession'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['dribble_won']),
            models.Index(fields=['dispossessed']),
            models.Index(fields=['touches']),
        ]


# 
# Location of each pass
# End location of each pass
# Pass accuracy so all passes, (for this we need to use pass accurate and pass innac)then use accuract erand innacruate

# Type of pass, so this too:

# was it an assist
# was it a corner?
# was it a cross? most times when its a corner its a cross but not always lol
# what about:
# Assist freekick
# Assist other
# Assist throughball
# Assist throwin
# was it Intentional assist

# then for a # Passkey key pass was it a ?

# Key pass corner

# Key pass cross

# Key pass freekick

# Key pass long

# Key pass other

# Key pass short

# Key pass throughball

# Key pass throwin

# then chances created too (this mean key passes + assists), so for alter when trying to find the cahcne created find ti from events
# Note theres also BCC BUT THIS ALREADY CO MES TWITH THE DAT SO WE ODNT NEED TO FIND




# doing  it this way will help me aggregate it for a season, so aggreagte for amcth foir a player i wil show u this too

# then use this too i want to kmow every detaila but my passes
# Pass corner

# Pass corner accurate

# Pass corner inaccurate

# Pass cross accurate

# Pass cross blocked defensive

# Pass cross inaccurate

# Pass freekick

# Pass freekick accurate

# Pass freekick inaccurate

# Pass back

# Pass back zone inaccurate

# Pass forward

# Pass forward zone accurate

# Pass left

# Pass right

# Pass chipped

# Pass head

# Pass left foot

# Pass right foot

# Pass long ball accurate

# Pass long ball inaccurate

# Short pass accurate

# Short pass inaccurate

# Pass through ball accurate

# Pass through ball inaccurate

# Big chance created

# Successful final third passes

# Throw in

# i wanna be clear what im trying to do so you know,
# basically i havce api routes fior diffrent stats i ie match events, im staring with passing that needs upgradingf and pottnetially changing idk yuoull help
# the route return all passing events from a amtchn adn com, eptiotn good, firstly i want to be able to from ym front end (so perhaps i need an api rotue backend oidk0, see
# passinmg events for a speicifc player form trhat macth you get me
# alsoo,i currently have a playere macth stats rotue showingg stats from a specifi cmathc thats no problem but then, i feel liek its goo ig ic a=could get mor edtail fo the stuff 
# i aggregate, for example asists in match a playe rmay have 3, but then i want to see what was true, ie was he asis tyf rom a corner or fk or sdomehting
# or even a regualr passes a paleyr had 90 passes, i want to get the detail of each pass as well or know i mean we have all the dat in one palc eits kind of jus tfil;t
# fi;lteroig it in the righ wya or somethign , liek a players passes all them then the type and then aggregated (and then knowing what those aggregate stuff are clealryl)
# liek i dont jsu wnan aknow he had 3 chances cretaed or 5 bgi chnces created wold be ncie to know if it was a coner ans stuff idk if i m vlear o hwo this woulkd work
# caus e i ahevb an matches/1282309/events/passing and matches/stats/players/1282309 showing detail too 

#  i wil lalso calculate further stats based on ther attribuyte s latesr, the reason i want match level agrgegation and with detial is so that my
# player season is easy to sdo ie cna use match possibley but for all amcthes idk, liek perhaps isot sjust getting the ful row of passing event btu perhas theres abter way, hope ive been clear and lmk
# if u have any qs, i am goonn share my code


# on my endx and start x coroidnates, like i want to do stuff liek finding out progressive passes, later tho

================
File: models/events/shooting.py
================
from django.db import models
from .base import Event


class ShootingEvent(Event):
    """Shot-specific event details"""
    # Big chances
    big_chance_missed = models.BooleanField(default=False)
    big_chance_scored = models.BooleanField(default=False)

    # Close misses
    close_miss_high = models.BooleanField(default=False)
    close_miss_high_left = models.BooleanField(default=False)
    close_miss_high_right = models.BooleanField(default=False)
    close_miss_left = models.BooleanField(default=False)
    close_miss_right = models.BooleanField(default=False)

    # Goals
    is_goal = models.BooleanField(default=False)
    goal_counter = models.BooleanField(default=False)
    goal_head = models.BooleanField(default=False)
    goal_left_foot = models.BooleanField(default=False)
    goal_right_foot = models.BooleanField(default=False)
    goal_normal = models.BooleanField(default=False)
    goal_open_play = models.BooleanField(default=False)
    goal_set_piece = models.BooleanField(default=False)

    # Goal location
    goal_obox = models.BooleanField(default=False)
    goal_obp = models.BooleanField(default=False)
    goal_penalty_area = models.BooleanField(default=False)
    goal_six_yard_box = models.BooleanField(default=False)
    goal_mouth_y = models.FloatField(null=True)  # Range: 7.1 to 93.4
    goal_mouth_z = models.FloatField(null=True)  # Range: 1.3 to 86.1

    # Shot flags
    is_shot = models.BooleanField(default=False)
    shot_blocked = models.BooleanField(default=False)
    shot_counter = models.BooleanField(default=False)
    shot_direct_corner = models.BooleanField(default=False)
    shot_on_post = models.BooleanField(default=False)
    shot_on_target = models.BooleanField(default=False)
    shot_off_target = models.BooleanField(default=False)
    shot_off_target_inside_box = models.BooleanField(default=False)
    shots_total = models.BooleanField(default=False)

    # Shot body part
    shot_body_type = models.CharField(max_length=20, null=True)
    shot_head = models.BooleanField(default=False)
    shot_left_foot = models.BooleanField(default=False)
    shot_right_foot = models.BooleanField(default=False)

    # Shot location
    shot_obox_total = models.BooleanField(default=False)
    shot_obp = models.BooleanField(default=False)
    shot_penalty_area = models.BooleanField(default=False)
    shot_six_yard_box = models.BooleanField(default=False)

    # Shot type
    shot_open_play = models.BooleanField(default=False)
    shot_set_piece = models.BooleanField(default=False)

    # Penalties (note diff in open play vs shootouts)
    penalty_missed = models.BooleanField(default=False)
    penalty_scored = models.BooleanField(default=False)
    penalty_shootout_missed_off_target = models.BooleanField(default=False)
    penalty_shootout_scored = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_shooting'  # Specific table name
        verbose_name = 'Events - Shooting'
        verbose_name_plural = 'Events - Shooting '
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['is_goal']),
            models.Index(fields=['is_shot']),
            models.Index(fields=['shot_on_target']),
            models.Index(fields=['big_chance_scored']),
        ]

================
File: models/events/summary.py
================
from django.db import models
from .base import Event


class SummaryEvent(Event):
    """Summary events such as fouls, cards and substitutions"""
    # Cards
    # Yellow, Red, SecondYellow
    card_type = models.CharField(max_length=20, null=True)
    yellow_card = models.BooleanField(default=False)
    red_card = models.BooleanField(default=False)
    second_yellow = models.BooleanField(default=False)
    void_yellow_card = models.BooleanField(default=False)

    # Fouls
    foul_committed = models.BooleanField(
        default=False)  # player that gave foul away
    foul_given = models.BooleanField(
        default=False)  # player/team foul was given to

    # Penalty
    penalty_conceded = models.BooleanField(default=False)
    penalty_won = models.BooleanField(default=False)

    # Offsides
    # An event attributed to the player deemed to be in an offside position
    # when a free kick is awarded
    offside_given = models.BooleanField(default=False)
    # The deepest player in the defensive line when an offside has been given
    offside_provoked = models.BooleanField(default=False)

    # Substitutions
    sub_on = models.BooleanField(default=False)  # Renamed from is_sub_on
    sub_off = models.BooleanField(default=False)  # Renamed from is_sub_off

    class Meta:
        db_table = 'sbapi_event_summary'  # Specific table name
        verbose_name = 'Events - Summary'
        verbose_name_plural = 'Events - Summary'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['card_type']),
            models.Index(fields=['foul_committed']),
            models.Index(fields=['penalty_conceded', 'penalty_won']),
            models.Index(fields=['sub_on', 'sub_off']),
        ]

================
File: models/__init__.py
================
from .competition import Competition, Season
from .team import Team
from .match import Match
from .formation import Formation
from .player import Player, MatchPlayer
from .events import (
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)

__all__ = [
    'Competition',
    'Season',
    'Team',
    'Match',
    'Formation',
    'Player',
    'MatchPlayer',
    'PassEvent',
    'ShootingEvent',
    'DefendingEvent',
    'GoalkeeperEvent',
    'PossessionEvent',
    'SummaryEvent'
]

================
File: models/competition.py
================
from django.db import models


class Competition(models.Model):
    """Core competition/league information"""
    competition_id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('name', 'country')
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]

    def __str__(self):
        return f"{self.name} ({self.country})"


class Season(models.Model):
    """Season information for a competition"""
    season_id = models.AutoField(primary_key=True)
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE)
    name = models.CharField(max_length=20)  # e.g., "2023/24"
    # start_date = models.DateField()
    # end_date = models.DateField()
    is_current = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('competition', 'name')
        indexes = [
            models.Index(fields=['is_current']),
        ]

    def __str__(self):
        return f"{self.competition.name} {self.name}"

================
File: models/formation.py
================
from django.db import models


class Formation(models.Model):
    """Store formation information for a team in a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    formation_name = models.CharField(max_length=10)  # e.g. "4231"
    captain_player_id = models.IntegerField()
    start_minute = models.IntegerField()
    end_minute = models.IntegerField()

    # Store player information
    player_ids = models.JSONField(default=list)
    jersey_numbers = models.JSONField(default=list)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['formation_name']),
            models.Index(fields=['captain_player_id']),
            models.Index(fields=['match', 'team']),
        ]
        # Add uniqueness constraint for formations
        unique_together = ('match', 'team', 'start_minute', 'end_minute')
        verbose_name = 'Match Formation'
        verbose_name_plural = 'Match Formations'

    def __str__(self):
        """
        Provides a detailed string representation of the Formation instance.
        """
        match_date = self.match.start_datetime.date()

        # Show the formation team first, then vs their opponent
        if self.team == self.match.home_team:
            opponent = self.match.away_team.name
        else:
            opponent = self.match.home_team.name

        return f"{self.team.name} formation ({self.formation_name}) vs {opponent} ({match_date})"

================
File: models/match.py
================
from django.db import models
from django.utils import timezone


class Match(models.Model):
    match_id = models.IntegerField(primary_key=True)
    season = models.ForeignKey('sbapi.Season', on_delete=models.CASCADE)

    # Date/Time fields
    start_datetime = models.DateTimeField()
    venue = models.CharField(max_length=200)
    attendance = models.IntegerField(null=True)

    # Referee information
    referee_id = models.IntegerField(null=True)
    referee_name = models.CharField(max_length=100, null=True)

    # Team relationships
    home_team = models.ForeignKey(
        'sbapi.Team', related_name='home_matches', on_delete=models.CASCADE)
    away_team = models.ForeignKey(
        'sbapi.Team', related_name='away_matches', on_delete=models.CASCADE)

    # Manager information (moved from MatchTeamStats)
    home_manager_name = models.CharField(max_length=100, null=True)
    away_manager_name = models.CharField(max_length=100, null=True)

    # Team average age (moved from MatchTeamStats)
    home_team_average_age = models.FloatField(null=True)
    away_team_average_age = models.FloatField(null=True)

    # Scores
    # score = models.CharField(max_length=10)
    home_score_ht = models.IntegerField()
    away_score_ht = models.IntegerField()
    home_score_ft = models.IntegerField()
    away_score_ft = models.IntegerField()
    home_score_et = models.IntegerField(null=True)
    away_score_et = models.IntegerField(null=True)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['start_datetime']),
            models.Index(fields=['home_team']),
            models.Index(fields=['away_team']),
            models.Index(fields=['referee_id']),
            models.Index(fields=['season']),
        ]
        verbose_name = 'Match'
        verbose_name_plural = 'Matches'

    @property
    def competition(self):
        return self.season.competition

    @property
    def score(self):
        return f"{self.home_score_ft} : {self.away_score_ft}"

    def __str__(self):
        return f"{self.home_team} vs {self.away_team} ({self.start_datetime.date()})"

================
File: models/player.py
================
from django.db import models


class Player(models.Model):
    """Store player information"""
    player_id = models.IntegerField(primary_key=True)  # Changed to primary_key
    name = models.CharField(max_length=100)
    height = models.IntegerField(null=True)
    weight = models.IntegerField(null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
        ]

    def __str__(self):
        return self.name


class MatchPlayer(models.Model):
    """Store player information specific to a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    player = models.ForeignKey('sbapi.Player', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)

    # Match-specific info
    shirt_no = models.IntegerField()
    position = models.CharField(max_length=20)  # e.g. 'GK'
    is_first_eleven = models.BooleanField()
    is_man_of_match = models.BooleanField(default=False)
    age = models.IntegerField()
    height = models.IntegerField(null=True)  # in cm
    weight = models.IntegerField(null=True)  # in kg

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('match', 'player', 'team')
        indexes = [
            models.Index(fields=['position']),
            models.Index(fields=['match', 'team']),
            models.Index(fields=['is_first_eleven']),
        ]
        verbose_name = 'Match - Player Information'
        verbose_name_plural = 'Matches - Player Information'

    def __str__(self):
        return f"{self.player.name} ({self.team.name}) - Match {self.match.match_id}"

    @property
    def match_date(self):
        return self.match.start_datetime.date()

================
File: models/team.py
================
from django.db import models


class Team(models.Model):
    """Team model representing a football team"""
    team_id = models.IntegerField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]
        verbose_name = 'Team'
        verbose_name_plural = 'Teams'

    def __str__(self):
        return f"{self.name} ({self.country})"

================
File: services/loaders/event_loader.py
================
from django.db import transaction
import pandas as pd
import logging

from ...models.events import (
    PassEvent, ShootingEvent, DefendingEvent,
    GoalkeeperEvent, PossessionEvent, SummaryEvent
)
from ...models import Player

logger = logging.getLogger(__name__)


def load_match_events(match, events_df):
    """Loads all events for a match"""
    with transaction.atomic():
        for _, event in events_df.iterrows():
            try:
                # Skip 'Start' events
                event_type = str(event.get('type', '')).strip()
                if event_type == 'Start':
                    logger.info("Skipping 'Start' event")
                    continue

                # Get player if exists - safer conversion
                player = None
                if not pd.isna(event.get('playerId')):
                    try:
                        player = Player.objects.get(
                            player_id=int(float(event['playerId'])))
                    except (ValueError, Player.DoesNotExist):
                        logger.warning(
                            f"Player not found or invalid ID: {event['playerId']}")

                # Get team - with safety check
                team = match.home_team if str(
                    event.get('h_a', '')).lower() == 'h' else match.away_team

                # Base event data with safer gets
                base_event_data = {
                    'source_id': int(float(event.get('id', 0))),
                    'event_id': int(float(event.get('eventId', 0))),
                    'match': match,
                    'team': team,
                    'player': player,
                    'player_name': event.get('playerName') if not pd.isna(event.get('playerName')) else None,
                    'minute': event.get('minute'),
                    'second': float(event.get('second', 0.0)),
                    'expanded_minute': event.get('expandedMinute'),
                    'period': event.get('period'),
                    'max_minute': event.get('maxMinute'),
                    'x': event.get('x'),
                    'y': event.get('y'),
                    'touches': event.get('touches', False),
                    'is_touch': event.get('isTouch', False),
                    'end_x': event.get('endX') if not pd.isna(event.get('endX')) else None,
                    'end_y': event.get('endY') if not pd.isna(event.get('endY')) else None,
                    'defensive_third': bool(event.get('defensiveThird', False)),
                    'mid_third': bool(event.get('midThird', False)),
                    'final_third': bool(event.get('finalThird', False)),
                    'type': str(event.get('type', '')),
                    'outcome_type': event.get('outcomeType') if not pd.isna(event.get('outcomeType')) else None,
                    'related_event_id': event.get('relatedEventId') if not pd.isna(event.get('relatedEventId')) else None,
                    'related_player_id': event.get('relatedPlayerId') if not pd.isna(event.get('relatedPlayerId')) else None,
                    'h_a': str(event.get('h_a', '')),
                    'situation': str(event.get('situation')).strip() if pd.notna(event.get('situation')) else None,
                    'qualifiers': event.get('qualifiers').tolist() if hasattr(event.get('qualifiers'), 'tolist') else event.get('qualifiers', []),
                    'satisfied_events_types': event.get('satisfiedEventsTypes').tolist() if hasattr(event.get('satisfiedEventsTypes'), 'tolist') else event.get('satisfiedEventsTypes', [])
                }

                # Route to appropriate event handler
                try:
                    event_type = event.get('type', '')

                    # Pass events
                    if event_type == 'Pass':
                        _update_or_create_pass_event(event, base_event_data)

                    # Defending events
                    elif event_type in ['Tackle', 'Interception', 'Clearance', 'BallRecovery',
                                        'Aerial', 'Challenge', 'Error', 'BlockedPass'] or \
                            event.get('goalOwn', False) or \
                            event.get('sixYardBlock', False) or \
                            event.get('outfielderBlock', False):
                        _update_or_create_defending_event(
                            event, base_event_data)

                    # Goalkeeper events
                    elif event_type in ['Save', 'Smother', 'Punch', 'PenaltyFaced', 'CrossNotClaimed',
                                        'KeeperSweeper', 'KeeperPickup', 'Claim'] or \
                            any(event.get(f'keeper_{x}', False) for x in ['save', 'claim', 'punch']):
                        _update_or_create_goalkeeper_event(
                            event, base_event_data)

                    # Shooting events
                    elif event_type in ['Goal', 'Shot', 'SavedShot', 'ChanceMissed', 'MissedShots'] or event.get('isShot', False):
                        _update_or_create_shooting_event(
                            event, base_event_data)

                    # Possession events
                    elif event_type in ['BallTouch', 'TakeOn', 'Dispossessed', 'ShieldBallOpp']:
                        _update_or_create_possession_event(
                            event, base_event_data)

                    # Summary/other events
                    elif event_type in ['Card', 'SubstitutionOn', 'SubstitutionOff', 'Start', 'Foul', 'GoodSkill',
                                        'OffsideProvoked', 'OffsideGiven', 'OffsidePass', 'FormationSet',
                                        'FormationChange', 'CornerAwarded', 'End']:
                        _update_or_create_summary_event(event, base_event_data)

                    else:
                        logger.warning(f"Unhandled event type: {event_type}")

                except Exception as e:
                    logger.error(
                        f"Error processing event type {event_type}: {str(e)}")
                    continue

            except Exception as e:
                logger.error(
                    f"Error processing event {event.get('id')}: {str(e)}")
                continue


def _update_or_create_pass_event(event, base_data):
    """Updates or creates a passing event"""
    try:
        pass_data = {
            # Core pass attributes
            'pass_accurate': event.get('passAccurate', False),
            'pass_inaccurate': event.get('passInaccurate', False),
            'pass_accuracy': event.get('passAccuracy', False),

            # Assist types
            'assist': event.get('assist', False),
            'assist_corner': event.get('assistCorner', False),
            'assist_cross': event.get('assistCross', False),
            'assist_freekick': event.get('assistFreekick', False),
            'assist_other': event.get('assistOther', False),
            'assist_throughball': event.get('assistThroughball', False),
            'assist_throwin': event.get('assistThrowin', False),
            'intentional_assist': event.get('intentionalAssist', False),

            # Key pass types
            'key_pass_corner': event.get('keyPassCorner', False),
            'key_pass_cross': event.get('keyPassCross', False),
            'key_pass_freekick': event.get('keyPassFreekick', False),
            'key_pass_long': event.get('keyPassLong', False),
            'key_pass_other': event.get('keyPassOther', False),
            'key_pass_short': event.get('keyPassShort', False),
            'key_pass_throughball': event.get('keyPassThroughball', False),
            'key_pass_throwin': event.get('keyPassThrowin', False),
            'pass_key': event.get('passKey', False),

            # Corner passes
            'pass_corner': event.get('passCorner', False),
            'pass_corner_accurate': event.get('passCornerAccurate', False),
            'pass_corner_inaccurate': event.get('passCornerInaccurate', False),

            # Cross passes
            'pass_cross_accurate': event.get('passCrossAccurate', False),
            'pass_cross_blocked_defensive': event.get('passCrossBlockedDefensive', False),
            'pass_cross_inaccurate': event.get('passCrossInaccurate', False),

            # Freekick passes
            'pass_freekick': event.get('passFreekick', False),
            'pass_freekick_accurate': event.get('passFreekickAccurate', False),
            'pass_freekick_inaccurate': event.get('passFreekickInaccurate', False),

            # Direction/zone
            'pass_back': event.get('passBack', False),
            'pass_back_zone_inaccurate': event.get('passBackZoneInaccurate', False),
            'pass_forward': event.get('passForward', False),
            'pass_forward_zone_accurate': event.get('passForwardZoneAccurate', False),
            'pass_left': event.get('passLeft', False),
            'pass_right': event.get('passRight', False),

            # Pass types
            'pass_chipped': event.get('passChipped', False),
            'pass_head': event.get('passHead', False),
            'pass_left_foot': event.get('passLeftFoot', False),
            'pass_right_foot': event.get('passRightFoot', False),

            # Long/short passes
            'pass_long_ball_accurate': event.get('passLongBallAccurate', False),
            'pass_long_ball_inaccurate': event.get('passLongBallInaccurate', False),
            'short_pass_accurate': event.get('shortPassAccurate', False),
            'short_pass_inaccurate': event.get('shortPassInaccurate', False),

            # Through balls
            'pass_through_ball_accurate': event.get('passThroughBallAccurate', False),
            'pass_through_ball_inaccurate': event.get('passThroughBallInaccurate', False),

            # Additional characteristics
            'big_chance_created': event.get('bigChanceCreated', False),
            'successful_final_third_passes': event.get('successfulFinalThirdPasses', False),
            'throw_in': event.get('throwIn', False),
        }

        PassEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **pass_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating pass event: {str(e)}")
        raise


def _update_or_create_defending_event(event, base_data):
    """Updates or creates a defending event"""
    try:
        defending_data = {
            # Core defensive actions - determined by event type
            'is_tackle': event['type'] == 'Tackle',
            'is_interception': event['type'] == 'Interception',
            'is_clearance': event['type'] == 'Clearance',
            'is_ball_recovery': event['type'] == 'BallRecovery',

            # Aerial duels
            'aerial_success': event.get('aerialSuccess', False),
            'duel_aerial_lost': event.get('duelAerialLost', False),
            'duel_aerial_won': event.get('duelAerialWon', False),

            # Block details
            'blocked_x': event['blockedX'] if not pd.isna(event.get('blockedX')) else None,
            'blocked_y': event['blockedY'] if not pd.isna(event.get('blockedY')) else None,

            # Clearances
            'clearance_effective': event.get('clearanceEffective', False),
            'clearance_head': event.get('clearanceHead', False),
            'clearance_off_the_line': event.get('clearanceOffTheLine', False),
            'clearance_total': event.get('clearanceTotal', False),

            # Different types of duels
            'challenge_lost': event.get('challengeLost', False),
            'defensive_duel': event.get('defensiveDuel', False),
            'offensive_duel': event.get('offensiveDuel', False),

            # Defensive errors
            'error_leads_to_goal': event.get('errorLeadsToGoal', False),
            'error_leads_to_shot': event.get('errorLeadsToShot', False),
            'goal_own': event.get('goalOwn', False),

            # Interceptions
            'interception_all': event.get('interceptionAll', False),
            'interception_in_the_box': event.get('interceptionIntheBox', False),
            'interception_won': event.get('interceptionWon', False),

            # Blocks
            'outfielder_block': event.get('outfielderBlock', False),
            'outfielder_blocked_pass': event.get('outfielderBlockedPass', False),
            'six_yard_block': event.get('sixYardBlock', False),

            # Tackles
            'tackle_last_man': event.get('tackleLastMan', False),
            'tackle_lost': event.get('tackleLost', False),
            'tackle_won': event.get('tackleWon', False),

        }

        DefendingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **defending_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating defending event: {str(e)}")
        raise


def _update_or_create_shooting_event(event, base_data):
    try:
        shooting_data = {
            # Big chances
            'big_chance_missed': event.get('bigChanceMissed', False),
            'big_chance_scored': event.get('bigChanceScored', False),

            # Close misses
            'close_miss_high': event.get('closeMissHigh', False),
            'close_miss_high_left': event.get('closeMissHighLeft', False),
            'close_miss_high_right': event.get('closeMissHighRight', False),
            'close_miss_left': event.get('closeMissLeft', False),
            'close_miss_right': event.get('closeMissRight', False),

            # Goals
            'is_goal': event.get('isGoal', False),
            'goal_counter': event.get('goalCounter', False),
            'goal_head': event.get('goalHead', False),
            'goal_left_foot': event.get('goalLeftFoot', False),
            'goal_right_foot': event.get('goalRightFoot', False),
            'goal_normal': event.get('goalNormal', False),
            'goal_open_play': event.get('goalOpenPlay', False),
            'goal_set_piece': event.get('goalSetPiece', False),

            # Goal location
            'goal_obox': event.get('goalObox', False),
            'goal_obp': event.get('goalObp', False),
            'goal_penalty_area': event.get('goalPenaltyArea', False),
            'goal_six_yard_box': event.get('goalSixYardBox', False),
            'goal_mouth_y': event['goalMouthY'] if not pd.isna(event.get('goalMouthY')) else None,
            'goal_mouth_z': event['goalMouthZ'] if not pd.isna(event.get('goalMouthZ')) else None,

            # Shot flags
            'is_shot': event.get('isShot', False),
            'shot_blocked': event.get('shotBlocked', False),
            'shot_counter': event.get('shotCounter', False),
            'shot_direct_corner': event.get('shotDirectCorner', False),
            'shot_on_post': event.get('shotOnPost', False),
            'shot_on_target': event.get('shotOnTarget', False),
            'shot_off_target': event.get('shotOffTarget', False),
            'shot_off_target_inside_box': event.get('shotOffTargetInsideBox', False),
            'shots_total': event.get('shotsTotal', False),

            # Shot body part
            'shot_body_type': event['shotBodyType'] if not pd.isna(event.get('shotBodyType')) else None,
            'shot_head': event.get('shotHead', False),
            'shot_left_foot': event.get('shotLeftFoot', False),
            'shot_right_foot': event.get('shotRightFoot', False),

            # Shot location
            'shot_obox_total': event.get('shotOboxTotal', False),
            'shot_obp': event.get('shotObp', False),
            'shot_penalty_area': event.get('shotPenaltyArea', False),
            'shot_six_yard_box': event.get('shotSixYardBox', False),

            # Shot type
            'shot_open_play': event.get('shotOpenPlay', False),
            'shot_set_piece': event.get('shotSetPiece', False),

            # Penalties
            'penalty_missed': event.get('penaltyMissed', False),
            'penalty_scored': event.get('penaltyScored', False),
            'penalty_shootout_missed_off_target': event.get('penaltyShootoutMissedOffTarget', False),
            'penalty_shootout_scored': event.get('penaltyShootoutScored', False),
        }

        ShootingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **shooting_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating shooting event: {str(e)}")
        raise


def _update_or_create_goalkeeper_event(event, base_data):
    try:
        """Creates a goalkeeper event with all keeper-specific fields"""
        goalkeeper_data = {
            # Core actions
            'is_collected': event.get('collected', False),

            # Claims
            'keeper_claim_high_lost': event.get('keeperClaimHighLost', False),
            'keeper_claim_high_won': event.get('keeperClaimHighWon', False),
            'keeper_claim_lost': event.get('keeperClaimLost', False),
            'keeper_claim_won': event.get('keeperClaimWon', False),

            # Save types
            'keeper_diving_save': event.get('keeperDivingSave', False),
            # failed to make a save on a penalty
            'keeper_missed': event.get('keeperMissed', False),
            'keeper_one_to_one_won': event.get('keeperOneToOneWon', False),
            'standing_save': event.get('standingSave', False),
            'save_feet': event.get('saveFeet', False),
            'save_hands': event.get('saveHands', False),

            # Save locations
            'save_high_centre': event.get('saveHighCentre', False),
            'save_high_left': event.get('saveHighLeft', False),
            'save_high_right': event.get('saveHighRight', False),
            'save_low_centre': event.get('saveLowCentre', False),
            'save_low_left': event.get('saveLowLeft', False),
            'save_low_right': event.get('saveLowRight', False),

            # Save zones
            'save_obox': event.get('saveObox', False),
            'save_obp': event.get('saveObp', False),  # save outside the box?
            'save_penalty_area': event.get('savePenaltyArea', False),
            'save_six_yard_box': event.get('saveSixYardBox', False),
            'keeper_save_in_the_box': event.get('keeperSaveInTheBox', False),
            'keeper_save_total': event.get('keeperSaveTotal', False),

            # Penalties
            'keeper_penalty_saved': event.get('keeperPenaltySaved', False),
            'penalty_shootout_saved': event.get('penaltyShootoutSaved', False),
            'penalty_shootout_saved_gk': event.get('penaltyShootoutSavedGK', False),
            'penalty_shootout_conceded_gk': event.get('penaltyShootoutConcededGK', False),

            # Other actions
            'keeper_smother': event.get('keeperSmother', False),
            'keeper_sweeper_lost': event.get('keeperSweeperLost', False),
            'parried_danger': event.get('parriedDanger', False),
            'parried_safe': event.get('parriedSafe', False),
            'punches': event.get('punches', False),
        }

        GoalkeeperEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **goalkeeper_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating goalkeeper event: {str(e)}")
        raise


def _update_or_create_possession_event(event, base_data):

    try:
        """Creates a possession event with all possession-specific fields"""
        possession_data = {
            # Set pieces
            'corner_awarded': event.get('cornerAwarded', False),

            # Ball control
            'dispossessed': event.get('dispossessed', False),
            'turnover': event.get('turnover', False),
            'overrun': event.get('overrun', False),

            # Dribbling
            'dribble_lastman': event.get('dribbleLastman', False),
            'dribble_lost': event.get('dribbleLost', False),
            'dribble_won': event.get('dribbleWon', False),
        }

        PossessionEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **possession_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating possession event: {str(e)}")
        raise


def _update_or_create_summary_event(event, base_data):

    try:

        """Creates a summary event with all summary-specific fields"""
        summary_data = {
            # Cards
            'card_type': event['cardType'] if not pd.isna(event.get('cardType')) and event['cardType'] != 'False' else None,
            'yellow_card': event.get('yellowCard', False),
            'red_card': event.get('redCard', False),
            'second_yellow': event.get('secondYellow', False),
            'void_yellow_card': event.get('voidYellowCard', False),

            # Substitutions
            'sub_on': event.get('subOn', False),
            'sub_off': event.get('subOff', False),

            # Fouls
            'foul_committed': event.get('foulCommitted', False),
            'foul_given': event.get('foulGiven', False),
            'penalty_conceded': event.get('penaltyConceded', False),
            'penalty_won': event.get('penaltyWon', False),

            # Offsides
            'offside_given': event.get('offsideGiven', False),
            'offside_provoked': event.get('offsideProvoked', False),
        }

        SummaryEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **summary_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating summary event: {str(e)}")
        raise

================
File: services/loaders/match_loader.py
================
from typing import Dict, Any, Tuple, Optional
import logging
from datetime import datetime
from dataclasses import dataclass
from django.db import transaction
from django.core.exceptions import ValidationError
from django.db.models import Model
from django.utils import timezone
import pytz

from ...models import (
    Competition,
    Season,
    Team,
    Match,
    Formation,
    Player,
    MatchPlayer
)

# Initialise
uk_tz = pytz.timezone('Europe/London')
logger = logging.getLogger(__name__)


@dataclass
class ScoreData:
    """Structured container for match score data"""
    home: int
    away: int

    @classmethod
    def from_string(cls, score_str: str) -> 'ScoreData':
        """Parse score string in format '0:0' into ScoreData object"""
        try:
            home, away = map(int, score_str.split(':'))
            return cls(home=home, away=away)
        except (ValueError, AttributeError) as e:
            raise ValidationError(f"Invalid score format: {score_str}") from e


class MatchDataValidator:
    """Handles validation of match data"""

    REQUIRED_MATCH_FIELDS = {
        'matchId', 'league', 'region', 'season', 'home', 'away',
        'startDate', 'startTime', 'venueName', 'score', 'htScore', 'ftScore'
    }

    REQUIRED_TEAM_FIELDS = {
        'teamId', 'name', 'averageAge', 'managerName',
        'countryName', 'scores', 'stats', 'formations', 'players'
    }

    @classmethod
    def validate(cls, data: Dict[str, Any]) -> None:
        """Validate all match data"""
        cls._validate_required_fields(data, cls.REQUIRED_MATCH_FIELDS, "match")
        cls._validate_scores(data)
        cls._validate_teams(data)

    @staticmethod
    def _validate_required_fields(
            data: Dict[str, Any], required_fields: set, context: str) -> None:
        """Check for presence of required fields"""
        missing = required_fields - data.keys()
        if missing:
            raise ValidationError(
                f"Missing required {context} fields: {', '.join(sorted(missing))}")

    @classmethod
    def _validate_teams(cls, data: Dict[str, Any]) -> None:
        """Validate both teams' data"""
        for venue in ['home', 'away']:
            team_data = data.get(venue, {})
            if not isinstance(team_data, dict):
                raise ValidationError(f"Invalid {venue} team data format")
            cls._validate_required_fields(
                team_data, cls.REQUIRED_TEAM_FIELDS, f"{venue} team")

    @staticmethod
    def _validate_scores(data: Dict[str, Any]) -> None:
        """Validate all score fields"""
        for field in ['score', 'htScore', 'ftScore']:
            # Will raise ValidationError if invalid
            ScoreData.from_string(data[field])


class MatchLoader:
    """Handles loading match data into the database"""

    def __init__(self):
        self.validator = MatchDataValidator()

    @transaction.atomic
    def load_match(self, match_data: Dict[str, Any]) -> Model:
        """
        Load match data into database with transaction handling

        Args:
            match_data: Dictionary containing match data

        Returns:
            Match: Created Match instance

        Raises:
            ValidationError: If data validation fails
            Exception: For other errors during loading
        """
        try:
            # Validate all input data
            self.validator.validate(match_data)

            # Load core match data
            competition, season = self._get_or_create_competition_and_season(
                match_data)
            teams = self._create_teams(match_data)
            match = self._create_match(match_data, competition, season, teams)

            # Load related data
            self._create_formations(match, match_data, teams)
            self._create_players(match, match_data, teams)

            logger.info(f"Successfully loaded match {match_data['matchId']}")
            return match

        except ValidationError as e:
            logger.error(
                f"Validation error for match {match_data.get('matchId')}: {str(e)}")
            raise
        except Exception as e:
            logger.error(
                f"Error loading match {match_data.get('matchId')}: {str(e)}")
            raise

    def _get_or_create_competition_and_season(
            self, data: Dict[str, Any]) -> Tuple[Model, Model]:
        """Create or retrieve competition and season"""
        try:
            # First get or create the competition
            competition, _ = Competition.objects.get_or_create(
                name=data['league'],
                country=data['region']
            )

            # Parse the season name from the data
            season_name = data['season']  # e.g., "2023/24"

            # Get or create the season
            season, created = Season.objects.get_or_create(
                competition=competition,
                name=season_name,
                defaults={
                    'is_current': False  # This should be managed separately
                }
            )

            if created:
                logger.info(f"Created new season: {season}")

            return competition, season
        except Exception as e:
            logger.error(f"Error creating competition and season: {str(e)}")
            raise

    def _create_teams(self, data: Dict[str, Any]) -> Dict[str, Model]:
        """Create or retrieve both teams"""
        teams = {}
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team, created = Team.objects.get_or_create(
                    team_id=team_data['teamId'],
                    defaults={
                        'name': team_data['name'],
                        'country': data['region']
                    }
                )
                if created:
                    logger.info(f"Created new team: {team}")
                else:
                    logger.info(f"Updated team: {team}")
                teams[venue] = team
            return teams
        except Exception as e:
            logger.error(f"Error creating or updating teams: {str(e)}")
            raise

    def _create_match(self, data: Dict[str, Any], competition: Model,
                      season: Model, teams: Dict[str, Model]) -> Model:
        """Create or update the main match record"""

        start_datetime = None

        try:
            # Parse all scores
            ht_score = ScoreData.from_string(data['htScore'])
            ft_score = ScoreData.from_string(data['ftScore'])
            et_score = None
            if data.get('etScore'):
                et_score = ScoreData.from_string(data['etScore'])

            # Parse the datetime
            start_datetime = None
            try:
                if 'T' in data['startDate']:
                    # New format: "2023-11-06T00:00:00"
                    start_date = datetime.strptime(
                        data['startDate'].split('T')[0], "%Y-%m-%d")
                    # New format: "2023-11-06T20:00:00"
                    start_time = datetime.strptime(
                        data['startTime'].split('T')[1], "%H:%M:%S")
                    start_datetime = datetime.combine(
                        start_date.date(), start_time.time())
                    # Add timezone info
                    start_datetime = uk_tz.localize(start_datetime)
                else:
                    # Old format handling
                    start_datetime = datetime.strptime(
                        f"{data['startDate']} {data['startTime']}",
                        "%Y-%m-%d %H:%M:%S"
                    )
                    # Add timezone info here too
                    start_datetime = uk_tz.localize(start_datetime)

            except (ValueError, TypeError) as e:
                logger.error(f"Error parsing datetime: {e}")
                raise ValidationError(
                    f"Invalid datetime format: {data['startDate']} {data['startTime']}")

            defaults = {
                'season': season,  # Add season reference
                'start_datetime': start_datetime,
                'venue': data['venueName'],
                'attendance': data.get('attendance'),
                'referee_id': data.get('referee', {}).get('officialId'),
                'referee_name': data.get('referee', {}).get('name'),
                # 'score': data['score'],
                'home_team': teams['home'],
                'away_team': teams['away'],
                'home_score_ht': ht_score.home,
                'away_score_ht': ht_score.away,
                'home_score_ft': ft_score.home,
                'away_score_ft': ft_score.away,
                'home_score_et': et_score.home if et_score else None,
                'away_score_et': et_score.away if et_score else None,
                'home_manager_name': data['home']['managerName'],
                'away_manager_name': data['away']['managerName'],
                'home_team_average_age': data['home']['averageAge'],
                'away_team_average_age': data['away']['averageAge']
            }

            match, created = Match.objects.update_or_create(
                match_id=data['matchId'],
                defaults=defaults
            )

            action = "Created new" if created else "Updated existing"
            logger.info(f"{action} match: {match}")

            return match

        except Exception as e:
            logger.error(
                f"Error creating or updating match {data.get('matchId')}: {str(e)}")
            raise

    def _create_formations(
            self, match: Model, data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update formation records for both teams"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                for formation_data in team_data['formations']:
                    # Extract formation details
                    formation_name = formation_data['formationName']
                    captain_id = formation_data['captainPlayerId']

                    # Get the full minute range
                    start_minute = formation_data.get(
                        'startMinuteExpanded', 0)  # Default to 0 if not specified
                    end_minute = formation_data.get(
                        'endMinuteExpanded', 90)  # Default to 90 if not specified

                    # Create or update formation record
                    Formation.objects.update_or_create(
                        match=match,
                        team=teams[venue],
                        start_minute=start_minute,
                        end_minute=end_minute,  # Add this to uniqueness constraint
                        defaults={
                            'formation_name': formation_name,
                            'captain_player_id': captain_id,
                            'player_ids': formation_data.get('playerIds', []),
                            'jersey_numbers': formation_data.get('jerseyNumbers', [])
                        }
                    )

                    logger.info(
                        f"Created/updated formation for {teams[venue].name}: "
                        f"{formation_name} ({start_minute}-{end_minute})"
                    )

        except Exception as e:
            logger.error(f"Error creating/updating formations: {str(e)}")
            logger.error(f"Formation data: {formation_data}")
            raise

    def _create_players(self, match: Model,
                        data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update player records and match-player relationships"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team = teams[venue]

                for player_data in team_data['players']:
                    # First update or create the base player record
                    try:
                        player, player_created = Player.objects.update_or_create(
                            player_id=player_data['playerId'],
                            defaults={
                                'name': player_data['name'],
                                'height': player_data.get('height'),
                                'weight': player_data.get('weight'),
                            }
                        )

                        # Then update or create the match-specific player
                        # record
                        MatchPlayer.objects.update_or_create(
                            match=match,
                            player=player,
                            team=team,
                            defaults={
                                'shirt_no': player_data['shirtNo'],
                                'position': player_data['position'],
                                # 'field': player_data['field'],
                                'is_first_eleven': player_data.get('isFirstEleven', False),
                                'is_man_of_match': player_data.get('isManOfTheMatch', False),
                                'age': player_data.get('age', 0),
                                'height': player_data.get('height', 0),
                                'weight': player_data.get('weight', 0),
                                # 'stats': player_data.get('stats', {})
                            }
                        )

                    except Exception as e:
                        logger.error(
                            f"Error processing player {player_data.get('playerId')}: {str(e)}")
                        raise

        except Exception as e:
            logger.error(f"Error creating/updating players: {str(e)}")
            raise

================
File: services/main/main.py
================
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 14 14:20:02 2020

@author: aliha
@twitter: rockingAli5 
"""

import re
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import NoSuchElementException, WebDriverException
from selenium import webdriver
import numpy as np
import itertools
from datetime import datetime as dt
import datetime
from collections import OrderedDict
from bs4 import BeautifulSoup as soup
import json
import warnings
import time
import pandas as pd
pd.options.mode.chained_assignment = None
try:
    from tqdm import trange
except ModuleNotFoundError:
    pass


options = webdriver.ChromeOptions()

options.add_experimental_option('excludeSwitches', ['enable-logging'])


TRANSLATE_DICT = {'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mac': 'Mar',
                  'Apr': 'Apr',
                  'Mei': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Ago': 'Aug',
                  'Sep': 'Sep',
                  'Okt': 'Oct',
                  'Nov': 'Nov',
                  'Des': 'Dec',
                  'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mar': 'Mar',
                  'Apr': 'Apr',
                  'May': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Aug': 'Aug',
                  'Sep': 'Sep',
                  'Oct': 'Oct',
                  'Nov': 'Nov',
                  'Dec': 'Dec'}

main_url = 'https://1xbet.whoscored.com/'


def getLeagueUrls(minimize_window=True):

    driver = webdriver.Chrome()

    if minimize_window:
        driver.minimize_window()

    driver.get(main_url)
    league_names = []
    league_urls = []
    try:
        cookie_button = driver.find_element(
            By.XPATH, '//*[@class=" css-gweyaj"]').click()
    except NoSuchElementException:
        pass
    tournaments_btn = driver.find_element(
        By.XPATH, '//*[@id="All-Tournaments-btn"]').click()
    n_button = soup(driver.find_element(
        By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[1]/div/div').get_attribute('innerHTML')).find_all('button')
    n_tournaments = []
    for button in n_button:
        id_button = button.get('id')
        driver.find_element(By.ID, id_button).click()
        n_country = soup(driver.find_element(By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute(
            'innerHTML')).find_all('div', {'class': 'TournamentsDropdownMenu-module_countryDropdownContainer__I9P6n'})

        for country in n_country:
            country_id = country.find(
                'div', {'class': 'TournamentsDropdownMenu-module_countryDropdown__8rtD-'}).get('id')

            # Trouver l'élément avec Selenium et cliquer dessus
            country_element = driver.find_element(By.ID, country_id)
            country_element.click()

            html_tournaments_list = driver.find_element(
                By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute('innerHTML')

            # Parse le HTML avec BeautifulSoup pour trouver les liens des tournois
            soup_tournaments = soup(html_tournaments_list, 'html.parser')
            tournaments = soup_tournaments.find_all('a')

            # Ajouter les tournois à la liste n_tournaments
            n_tournaments.extend(tournaments)

            driver.execute_script("arguments[0].click();", country_element)

    for tournament in n_tournaments:
        league_name = tournament.get('href').split('/')[-1]
        league_link = main_url[:-1]+tournament.get('href')
        league_names.append(league_name)
        league_urls.append(league_link)

    leagues = {}
    for name, link in zip(league_names, league_urls):
        leagues[name] = link

    driver.close()
    return leagues


def getMatchUrls(comp_urls, competition, season, maximize_window=True):

    driver = webdriver.Chrome()

    if maximize_window:
        driver.maximize_window()

    comp_url = comp_urls[competition]
    driver.get(comp_url)
    time.sleep(5)

    seasons = driver.find_element(
        By.XPATH, '//*[@id="seasons"]').get_attribute('innerHTML').split(sep='\n')
    seasons = [i for i in seasons if i]

    for i in range(1, len(seasons)+1):
        if driver.find_element(By.XPATH, '//*[@id="seasons"]/option['+str(i)+']').text == season:
            driver.find_element(
                By.XPATH, '//*[@id="seasons"]/option['+str(i)+']').click()

            time.sleep(5)
            try:
                stages = driver.find_element(
                    By.XPATH, '//*[@id="stages"]').get_attribute('innerHTML').split(sep='\n')
                stages = [i for i in stages if i]

                all_urls = []

                for i in range(1, len(stages)+1):
                    print(driver.find_element(
                        By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text)
                    if competition == 'Champions League' or competition == 'Europa League':
                        if 'Grp' in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text or 'Final Stage' in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    elif competition == 'Major League Soccer':
                        if 'Grp. ' not in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    else:
                        driver.find_element(
                            By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                        time.sleep(5)

                        driver.execute_script("window.scrollTo(0, 400)")

                        match_urls = getFixtureData(driver)

                        match_urls = getSortedData(match_urls)

                        match_urls2 = [
                            url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                        all_urls += match_urls2

            except NoSuchElementException:
                all_urls = []

                driver.execute_script("window.scrollTo(0, 400)")

                match_urls = getFixtureData(driver)

                match_urls = getSortedData(match_urls)

                match_urls2 = [
                    url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                all_urls += match_urls2

            remove_dup = [dict(t) for t in {tuple(
                sorted(d.items())) for d in all_urls}]
            all_urls = getSortedData(remove_dup)

            driver.close()

            return all_urls

    season_names = [re.search(r'\>(.*?)\<', season).group(1)
                    for season in seasons]
    driver.close()
    print('Seasons available: {}'.format(season_names))
    raise ('Season Not Found.')


def getTeamUrls(team, match_urls):

    team_data = []
    for fixture in match_urls:
        if fixture['home'] == team or fixture['away'] == team:
            team_data.append(fixture)
    team_data = [a[0] for a in itertools.groupby(team_data)]

    return team_data


def getMatchesData(match_urls, minimize_window=True):

    matches = []

    driver = webdriver.Chrome()
    if minimize_window:
        driver.minimize_window()

    try:
        for i in trange(len(match_urls), desc='Getting Match Data'):
            # recommended to avoid getting blocked by incapsula/imperva bots
            time.sleep(7)
            match_data = getMatchData(
                driver, main_url+match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)
    except NameError:
        print('Recommended: \'pip install tqdm\' for a progress bar while the data gets scraped....')
        time.sleep(7)
        for i in range(len(match_urls)):
            match_data = getMatchData(
                driver, main_url+match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)

    driver.close()

    return matches


def getFixtureData(driver):
    matches_ls = []
    while True:
        initial = driver.page_source
        all_fixtures = driver.find_elements(
            By.CLASS_NAME, 'Accordion-module_accordion__UuHD0')
        for dates in all_fixtures:
            fixtures = dates.find_elements(
                By.CLASS_NAME, 'Match-module_row__zwBOn')
            date_row = dates.find_element(
                By.CLASS_NAME, 'Accordion-module_header__HqzWD')
            for row in fixtures:
                url = row.find_element(By.TAG_NAME, 'a')
                if 'Live' in url.get_attribute('href'):
                    match_dict = {}
                    element = soup(row.get_attribute(
                        'innerHTML'), features='lxml')
                    teams_tag = element.find(
                        "div", {"class": "Match-module_teams__sGVeq"})
                    link_tag = element.find("a")
                    match_dict['date'] = date_row.text
                    match_dict['home'] = teams_tag.find_all('a')[0].text
                    match_dict['away'] = teams_tag.find_all('a')[1].text
                    match_dict['score'] = ':'.join(
                        [t.text for t in link_tag.find_all('span')])
                    match_dict['url'] = link_tag['href']
                    matches_ls.append(match_dict)
        prev_btn = driver.find_element(By.ID, 'dayChangeBtn-prev')
        prev_btn.click()
        time.sleep(1)
        final = driver.page_source
        if initial == final:
            break

    return matches_ls


def translateDate(data):

    unwanted = []
    for match in data:
        date = match['date'].split()
        if '?' not in date[0]:
            try:
                match['date'] = ' '.join(
                    [TRANSLATE_DICT[date[0]], date[1], date[2]])
            except KeyError:
                print(date)
        else:
            unwanted.append(data.index(match))

    # remove matches that got suspended/postponed
    for i in sorted(unwanted, reverse=True):
        del data[i]

    return data


def getSortedData(data):
    data = sorted(data, key=lambda i: dt.strptime(i['date'], '%A, %b %d %Y'))
    return data


def getMatchData(driver, url, display=True, close_window=True):
    try:
        driver.get(url)
    except WebDriverException:
        driver.get(url)

    time.sleep(5)
    # get script data from page source
    script_content = driver.find_element(
        By.XPATH, '//*[@id="layout-wrapper"]/script[1]').get_attribute('innerHTML')

    # clean script content
    script_content = re.sub(r"[\n\t]*", "", script_content)
    script_content = script_content[script_content.index(
        "matchId"):script_content.rindex("}")]

    # this will give script content in list form
    script_content_list = list(
        filter(None, script_content.strip().split(',            ')))
    metadata = script_content_list.pop(1)

    # string format to json format
    match_data = json.loads(metadata[metadata.index('{'):])
    keys = [item[:item.index(':')].strip() for item in script_content_list]
    values = [item[item.index(':')+1:].strip() for item in script_content_list]
    for key, val in zip(keys, values):
        match_data[key] = json.loads(val)

    # get other details about the match
    region = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/span[1]').text
    league = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[0]
    season = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[1]
    if len(driver.find_element(By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 2:
        competition_type = 'League'
        competition_stage = ''
    elif len(driver.find_element(By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 3:
        competition_type = 'Knock Out'
        competition_stage = driver.find_element(
            By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[-1]
    else:
        print('Getting more than 3 types of information about the competition.')

    match_data['region'] = region
    match_data['league'] = league
    match_data['season'] = season
    match_data['competitionType'] = competition_type
    match_data['competitionStage'] = competition_stage

    # sort match_data dictionary alphabetically
    match_data = OrderedDict(sorted(match_data.items()))
    match_data = dict(match_data)
    if display:
        print('Region: {}, League: {}, Season: {}, Match Id: {}'.format(
            region, league, season, match_data['matchId']))

    if close_window:
        driver.close()

    return match_data


def createEventsDF(data):
    events = data['events']
    for event in events:
        event.update({'matchId': data['matchId'],
                      'startDate': data['startDate'],
                      'startTime': data['startTime'],
                      'score': data['score'],
                      'ftScore': data['ftScore'],
                      'htScore': data['htScore'],
                      'etScore': data['etScore'],
                      'venueName': data['venueName'],
                      'maxMinute': data['maxMinute']})
    events_df = pd.DataFrame(events)

    # clean period column
    events_df['period'] = pd.json_normalize(events_df['period'])['displayName']

    # clean type column
    events_df['type'] = pd.json_normalize(events_df['type'])['displayName']

    # clean outcomeType column
    events_df['outcomeType'] = pd.json_normalize(
        events_df['outcomeType'])['displayName']

    # clean outcomeType column
    try:
        x = events_df['cardType'].fillna({i: {} for i in events_df.index})
        events_df['cardType'] = pd.json_normalize(
            x)['displayName'].fillna(False)
    except KeyError:
        events_df['cardType'] = False

    eventTypeDict = data['matchCentreEventTypeJson']
    events_df['satisfiedEventsTypes'] = events_df['satisfiedEventsTypes'].apply(
        lambda x: [list(eventTypeDict.keys())[list(eventTypeDict.values()).index(event)] for event in x])

    # clean qualifiers column
    try:
        for i in events_df.index:
            row = events_df.loc[i, 'qualifiers'].copy()
            if len(row) != 0:
                for irow in range(len(row)):
                    row[irow]['type'] = row[irow]['type']['displayName']
    except TypeError:
        pass

    # clean isShot column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        if 'isShot' in events_df.columns:
            events_df['isShot'] = events_df['isShot'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isShot'] = False

        # clean isGoal column
        if 'isGoal' in events_df.columns:
            events_df['isGoal'] = events_df['isGoal'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isGoal'] = False

    # add player name column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        events_df.loc[events_df.playerId.notna(
        ), 'playerId'] = events_df.loc[events_df.playerId.notna(), 'playerId'].astype(int).astype(str)
    player_name_col = events_df.loc[:, 'playerId'].map(
        data['playerIdNameDictionary'])
    events_df.insert(loc=events_df.columns.get_loc("playerId")+1,
                     column='playerName', value=player_name_col)

    # add home/away column
    h_a_col = events_df['teamId'].map(
        {data['home']['teamId']: 'h', data['away']['teamId']: 'a'})
    events_df.insert(loc=events_df.columns.get_loc(
        "teamId")+1, column='h_a', value=h_a_col)

    # adding shot body part column
    events_df['shotBodyType'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'RightFoot' or j['type'] == 'LeftFoot' or j['type'] == 'Head' or j['type'] == 'OtherBodyPart':
                    events_df.loc[i, 'shotBodyType'] = j['type']

    # adding shot situation column
    events_df['situation'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'FromCorner' or j['type'] == 'SetPiece' or j['type'] == 'DirectFreekick':
                    events_df.loc[i, 'situation'] = j['type']
                if j['type'] == 'RegularPlay':
                    events_df.loc[i, 'situation'] = 'OpenPlay'

    event_types = list(data['matchCentreEventTypeJson'].keys())
    event_type_cols = pd.DataFrame({event_type: pd.Series(
        [event_type in row for row in events_df['satisfiedEventsTypes']]) for event_type in event_types})
    events_df = pd.concat([events_df, event_type_cols], axis=1)

    return events_df


def createMatchesDF(data):
    columns_req_ls = ['matchId', 'attendance', 'venueName', 'startTime', 'startDate',
                      'score', 'home', 'away', 'referee']
    matches_df = pd.DataFrame(columns=columns_req_ls)
    if type(data) == dict:
        matches_dict = dict(
            [(key, val) for key, val in data.items() if key in columns_req_ls])
        matches_df = pd.DataFrame(
            matches_dict, columns=columns_req_ls).reset_index(drop=True)
        matches_df[['home', 'away']] = np.nan
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=FutureWarning)
            matches_df['home'].iloc[0] = [data['home']]
            matches_df['away'].iloc[0] = [data['away']]
    else:
        for match in data:
            matches_dict = dict(
                [(key, val) for key, val in match.items() if key in columns_req_ls])
            matches_df = pd.DataFrame(
                matches_dict, columns=columns_req_ls).reset_index(drop=True)

    matches_df = matches_df.set_index('matchId')
    return matches_df


def load_EPV_grid(fname='EPV_grid.csv'):
    """ load_EPV_grid(fname='EPV_grid.csv')

    # load pregenerated EPV surface from file. 

    Parameters
    -----------
        fname: filename & path of EPV grid (default is 'EPV_grid.csv' in the curernt directory)

    Returns
    -----------
        EPV: The EPV surface (default is a (32,50) grid)

    """
    epv = np.loadtxt(fname, delimiter=',')
    return epv


def get_EPV_at_location(position, EPV, attack_direction, field_dimen=(106., 68.)):
    """ get_EPV_at_location

    Returns the EPV value at a given (x,y) location

    Parameters
    -----------
        position: Tuple containing the (x,y) pitch position
        EPV: tuple Expected Possession value grid (loaded using load_EPV_grid() )
        attack_direction: Sets the attack direction (1: left->right, -1: right->left)
        field_dimen: tuple containing the length and width of the pitch in meters. Default is (106,68)

    Returrns
    -----------
        EPV value at input position

    """

    x, y = position
    if abs(x) > field_dimen[0]/2. or abs(y) > field_dimen[1]/2.:
        return 0.0  # Position is off the field, EPV is zero
    else:
        if attack_direction == -1:
            EPV = np.fliplr(EPV)
        ny, nx = EPV.shape
        dx = field_dimen[0]/float(nx)
        dy = field_dimen[1]/float(ny)
        ix = (x+field_dimen[0]/2.-0.0001)/dx
        iy = (y+field_dimen[1]/2.-0.0001)/dy
        return EPV[int(iy), int(ix)]


def to_metric_coordinates_from_whoscored(data, field_dimen=(106., 68.)):
    '''
    Convert positions from Whoscored units to meters (with origin at centre circle)
    '''
    x_columns = [c for c in data.columns if c[-1].lower() == 'x'][:2]
    y_columns = [c for c in data.columns if c[-1].lower() == 'y'][:2]
    x_columns_mod = [c+'_metrica' for c in x_columns]
    y_columns_mod = [c+'_metrica' for c in y_columns]
    data[x_columns_mod] = (data[x_columns]/100*106)-53
    data[y_columns_mod] = (data[y_columns]/100*68)-34
    return data


def addEpvToDataFrame(data):

    # loading EPV data
    EPV = load_EPV_grid('EPV_grid.csv')

    # converting opta coordinates to metric coordinates
    data = to_metric_coordinates_from_whoscored(data)

    # calculating EPV for events
    EPV_difference = []
    for i in data.index:
        if data.loc[i, 'type'] == 'Pass' and data.loc[i, 'outcomeType'] == 'Successful':
            start_pos = (data.loc[i, 'x_metrica'], data.loc[i, 'y_metrica'])
            start_epv = get_EPV_at_location(start_pos, EPV, attack_direction=1)

            end_pos = (data.loc[i, 'endX_metrica'],
                       data.loc[i, 'endY_metrica'])
            end_epv = get_EPV_at_location(end_pos, EPV, attack_direction=1)

            diff = end_epv - start_epv
            EPV_difference.append(diff)

        else:
            EPV_difference.append(np.nan)

    data = data.assign(EPV_difference=EPV_difference)

    # dump useless columns
    drop_cols = ['x_metrica', 'endX_metrica', 'y_metrica',
                 'endY_metrica']
    data.drop(drop_cols, axis=1, inplace=True)
    data.rename(columns={'EPV_difference': 'EPV'}, inplace=True)

    return data

================
File: services/main/test.py
================
# import relevant functions
from main import getLeagueUrls, getMatchUrls, getTeamUrls, getMatchesData, getMatchData, createEventsDF, createMatchesDF, addEpvToDataFrame

# import relevant variables
from main import main_url

# import relevant packages
import pandas as pd

from selenium import webdriver
options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])


# write test functions for all functions in file
def test():
    print('Testing getLeagueUrls function...')
    leagues = getLeagueUrls()


assert isinstance(leagues,     assert )    assert len(leagues) == 23
print('getLeagueUrls function passed all tests.')

print('Testing getMatchUrls function...')
comp_urls = getLeagueUrls()
match_urls = getMatchUrls(comp_urls, 'Premier League', '2019/2020')
assert isinstance(match_urls,     assert )    assert len(match_urls) == 380
print('getMatchUrls function passed all tests.')

print('Testing getTeamUrls function...')
team_urls = getTeamUrls('Liverpool', match_urls)
assert isinstance(team_urls,     assert )    assert len(team_urls) == 38
print('getTeamUrls function passed all tests.')

print('Testing getMatchesData function...')
matches = getMatchesData(team_urls)
assert isinstance(matches,     assert )    assert len(matches) == 38
print('getMatchesData function passed all tests.')

print('Testing getMatchData function...')
driver = webdriver.Chrome('drivers/chromedriver.exe', options=options)
match_data = getMatchData(
    driver, main_url + '/Matches/1375927/Live/England-Premier-League-2019-2020-Liverpool-Norwich')
assert isinstance(match_data,     assert )    assert len(match_data) == 36
print('getMatchData function passed all tests.')

print('Testing createEventsDF function...')
events_df = createEventsDF(match_data)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 259
print('createEventsDF function passed all tests.')

print('Testing createMatchesDF function...')
matches_df = createMatchesDF(match_data)
assert isinstance(matches_df,     assert )    assert matches_df.shape[1] == 8
print('createMatchesDF function passed all tests.')

print('Testing addEpvToDataFrame function...')
events_df = addEpvToDataFrame(events_df)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 260
print('addEpvToDataFrame function passed all tests.')

print('All tests passed.')


if __name__ == '__main__':
    test()

================
File: services/main/utils.py
================
import os
import re
from sys import platform


def extract_version_registry(output):
    try:
        google_version = ''
        for letter in output[output.rindex('DisplayVersion    REG_SZ') + 24:]:
            if letter != '\n':
                google_version += letter
            else:
                break
        return (google_version.strip())
    except TypeError:
        return


def extract_version_folder():
    # Check if the Chrome folder exists in the x32 or x64 Program Files
    # folders.
    for i in range(2):
        path = 'C:\\Program Files' + \
            (' (x86)' if i else '') + '\\Google\\Chrome\\Application'
        if os.path.isdir(path):
            paths = [f.path for f in os.scandir(path) if f.is_dir()]
            for path in paths:
                filename = os.path.basename(path)
                pattern = '\\d+\\.\\d+\\.\\d+\\.\\d+'
                match = re.search(pattern, filename)
                if match and match.group():
                    # Found a Chrome version.
                    return match.group(0)

    return None


def get_chrome_version():
    version = None
    install_path = None

    try:
        if platform == "linux" or platform == "linux2":
            # linux
            install_path = "/usr/bin/google-chrome"
        elif platform == "darwin":
            # OS X
            install_path = "/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"
        elif platform == "win32":
            # Windows...
            try:
                # Try registry key.
                stream = os.popen(
                    'reg query "HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Google Chrome"')
                output = stream.read()
                version = extract_version_registry(output)
            except Exception as ex:
                # Try folder path.
                version = extract_version_folder()
    except Exception as ex:
        print(ex)

    version = os.popen(f"{install_path} --version").read().strip(
        'Google Chrome ').strip() if install_path else version

    return version

================
File: services/scripts/match_scraper.py
================
import logging
from typing import Dict, Any, Optional
import pandas as pd
from selenium import webdriver
from django.db import transaction

from sbapi.services.main.main import getMatchData, createMatchesDF, createEventsDF
from sbapi.services.loaders.match_loader import MatchLoader
from sbapi.services.loaders.event_loader import load_match_events

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Also add this to make sure handlers are configured
logger.setLevel(logging.DEBUG)


class MatchScraper:
    """Handles scraping and processing of match data"""

    def __init__(self):
        self.match_loader = MatchLoader()

    def scrape_match(self, url: str) -> Dict[str, Any]:
        """
        Get match data from URL
        """
        try:
            driver = webdriver.Chrome()
            match_data = getMatchData(driver, url, close_window=True)
            return match_data
        except Exception as e:
            logger.error(f"Error scraping match data: {str(e)}")
            raise

    def process_match_data(
            self, match_data: Dict[str, Any]) -> Optional[Dict[str, pd.DataFrame]]:
        """
        Process raw match data into DataFrames and load into database
        """
        try:
            # Create DataFrames
            matches_df = createMatchesDF(match_data)
            events_df = createEventsDF(match_data)

            # Load data into database using transaction
            with transaction.atomic():
                # Load match data first
                match = self.match_loader.load_match(match_data)

                # Load events data
                load_match_events(match, events_df)

                logger.info(
                    f"Successfully processed match {match_data['matchId']}")

            return {
                'matches': matches_df,
                'events': events_df
            }

        except Exception as e:
            logger.error(f"Error processing match data: {str(e)}")
            raise

================
File: v1/serializers/base/__init__.py
================
from .common import BaseStatsSerializer, BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer, BaseTeamStatsSerializer
from .competition import CompetitionListSerializer, CompetitionDetailSerializer, SeasonSerializer
from .events import (
    BaseEventSerializer,
    DefendingEventSerializer,
    GoalkeeperEventSerializer,
    PassEventSerializer,
    PossessionEventSerializer,
    ShootingEventSerializer,
    SummaryEventSerializer,
    get_event_serializer
)
from .match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'DefendingEventSerializer',
    'GoalkeeperEventSerializer',
    'PassEventSerializer',
    'PossessionEventSerializer',
    'ShootingEventSerializer',
    'SummaryEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer'
]

================
File: v1/serializers/base/common.py
================
from rest_framework import serializers


class BaseStatsSerializer(serializers.Serializer):
    """Base serializer for all stats"""
    competition_name = serializers.CharField(required=False)
    season_name = serializers.CharField(required=False)
    total_events = serializers.IntegerField(required=False)


class BasePlayerStatsSerializer(BaseStatsSerializer):
    """Base serializer for all player stats"""
    games_played = serializers.IntegerField(required=False)
    games_started = serializers.IntegerField(required=False)
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()


class BaseTeamStatsSerializer(BaseStatsSerializer):
    """Base serializer for all team stats"""
    matches_played = serializers.IntegerField(required=False)
    team = serializers.DictField(required=False)  # For team basic info


class BaseMatchStatsSerializer(BaseStatsSerializer):
    """Base serializer for match-specific stats"""
    match_date = serializers.DateTimeField(required=False)


class BaseSeasonStatsSerializer(BaseStatsSerializer):
    """Base serializer for season aggregated stats"""
    pass

================
File: v1/serializers/base/competition.py
================
from rest_framework import serializers
from sbapi.models import Competition, Season
from ..base.base import BaseSerializer, HalModelSerializer


class SeasonSerializer(BaseSerializer):
    class Meta:
        model = Season
        fields = ['season_id', 'name', 'is_current']


class CompetitionListSerializer(BaseSerializer):
    class Meta:
        model = Competition
        fields = ['competition_id', 'name', 'country']


class CompetitionDetailSerializer(HalModelSerializer):
    seasons = SeasonSerializer(source='season_set', many=True, read_only=True)

    class Meta:
        model = Competition
        fields = ['competition_id', 'name', 'country', 'seasons', '_links']

    def get__links(self, obj):
        return {
            'seasons': f'/sbapi/v1/competitions/{obj.competition_id}/seasons'
        }

================
File: v1/serializers/base/events.py
================
from rest_framework import serializers
from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)
from ..base.base import BaseSerializer


class BaseEventSerializer(BaseSerializer):
    """Base serializer for common event fields"""
    team_name = serializers.CharField(source='team.name')
    player_name = serializers.CharField(source='player.name', allow_null=True)

    class Meta:
        model = SummaryEvent
        abstract = True
        fields = [
            'event_id',
            'type',
            'minute',
            'second',
            'period',
            'team_name',
            'player_name',
            'x',
            'y',
            'end_x',
            'end_y',
            'outcome_type',
            'situation'
        ]


class DefendingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = DefendingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_tackle',
            'is_interception',
            'is_clearance',
            'is_ball_recovery',
            'aerial_success',
            'clearance_effective',
            'tackle_won',
            'interception_won',
            'defensive_duel',
            'error_leads_to_goal',
            'error_leads_to_shot',
        ]


class GoalkeeperEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = GoalkeeperEvent
        fields = BaseEventSerializer.Meta.fields + [
            'keeper_save_total',
            'keeper_claim_won',
            'keeper_claim_lost',
            'keeper_diving_save',
            'keeper_save_in_the_box',
            'keeper_penalty_saved',
            'save_high_centre',
            'save_high_left',
            'save_high_right',
            'save_low_centre',
            'save_low_left',
            'save_low_right',
        ]


class PassEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PassEvent
        fields = BaseEventSerializer.Meta.fields + [
            'pass_accurate',
            'pass_inaccurate',
            'assist',
            'key_pass_cross',
            'key_pass_throughball',
            'pass_cross_accurate',
            'pass_through_ball_accurate',
            'big_chance_created',
            'successful_final_third_passes',
        ]


class PossessionEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PossessionEvent
        fields = BaseEventSerializer.Meta.fields + [
            'dispossessed',
            'touches',
            'dribble_won',
            'dribble_lost',
            'penalty_won',
            'offside_given',
        ]


class ShootingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = ShootingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_goal',
            'is_shot',
            'shot_on_target',
            'big_chance_scored',
            'big_chance_missed',
            'goal_mouth_y',
            'goal_mouth_z',
            'shot_body_type',
            'shot_penalty_area',
            'shot_six_yard_box',
        ]


class SummaryEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = SummaryEvent
        fields = BaseEventSerializer.Meta.fields + [
            'card_type',
            'yellow_card',
            'red_card',
            'second_yellow',
            'foul_committed',
            'sub_on',
            'sub_off',
        ]


# Factory function to get appropriate serializer
EVENT_TYPE_SERIALIZERS = {
    'defending': DefendingEventSerializer,
    'goalkeeper': GoalkeeperEventSerializer,
    'passing': PassEventSerializer,
    'possession': PossessionEventSerializer,
    'shooting': ShootingEventSerializer,
    'summary': SummaryEventSerializer,
}


def get_event_serializer(event_type):
    """Returns appropriate serializer based on event type"""
    return EVENT_TYPE_SERIALIZERS.get(event_type, BaseEventSerializer)

================
File: v1/serializers/base/match.py
================
from rest_framework import serializers
from ....models import Match, Team, MatchPlayer, Formation
from .base import BaseSerializer, HalModelSerializer


class TeamBasicSerializer(serializers.Serializer):
    """Team serializer specifically for stats responses"""
    team_id = serializers.IntegerField()
    name = serializers.CharField()
    country = serializers.CharField()


class LineupPlayerSerializer(BaseSerializer):
    """Simplified player information for lineups"""
    name = serializers.CharField(source='player.name')

    class Meta:
        model = MatchPlayer
        fields = ['name', 'shirt_no', 'position']


class TeamLineupSerializer(serializers.Serializer):
    """Serializer for single team lineup data"""
    team = TeamBasicSerializer()
    starting_formation = serializers.CharField(allow_null=True)
    formation_changes = serializers.ListField(
        child=serializers.DictField()
    )
    starting_lineup = LineupPlayerSerializer(many=True)
    substitutions = serializers.ListField(
        child=serializers.DictField()
    )


class LineupResponseSerializer(serializers.Serializer):
    """Serializer for complete lineup response data"""
    status = serializers.CharField(default='success')
    message = serializers.CharField(allow_null=True, default=None)
    data = serializers.SerializerMethodField()

    def get_data(self, obj):
        return {
            'home_team': TeamLineupSerializer(obj['home_team']).data,
            'away_team': TeamLineupSerializer(obj['away_team']).data
        }


class MatchListSerializer(HalModelSerializer):
    """Simplified match list serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'start_datetime',
            'home_team',
            'away_team',
            'score',
            'venue',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/sbapi/v1/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events'
        }


class MatchDetailSerializer(HalModelSerializer):
    """Detailed match information serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    competition_name = serializers.CharField(source='season.competition.name')
    season_name = serializers.CharField(source='season.name')
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'competition_name',
            'season_name',
            'start_datetime',
            'venue',
            'attendance',
            'referee_name',
            'home_team',
            'away_team',
            'home_manager_name',
            'away_manager_name',
            'home_team_average_age',
            'away_team_average_age',
            'home_score_ft',
            'away_score_ft',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events',
            'stats': f'/sbapi/v1/matches/{obj.match_id}/stats'
        }

================
File: v1/serializers/player_analytics/match_events/base.py
================
from rest_framework import serializers
from ...base.base import BaseSerializer

class BaseEventSerializer(BaseSerializer):
    """Base serializer for common event fields"""
    team_name = serializers.CharField(source='team.name')
    player_name = serializers.CharField(source='player.name', allow_null=True)

    class Meta:
        model = None  # Set by child classes
        fields = [
            'event_id',
            'type',
            'minute',
            'second',
            'period',
            'team_name',
            'player_name',
            'x',
            'y',
            'end_x',
            'end_y',
            'outcome_type',
            'situation'
        ]

================
File: v1/serializers/player_analytics/match_events/passing.py
================
from rest_framework import serializers
from .base import BaseEventSerializer
from sbapi.models.events import PassEvent


class PassEventSerializer(BaseEventSerializer):
    """Basic serializer for pass events - used for listings"""
    pass_type = serializers.SerializerMethodField()
    pass_accuracy = serializers.BooleanField()

    class Meta(BaseEventSerializer.Meta):
        model = PassEvent
        fields = BaseEventSerializer.Meta.fields + [
            'pass_type',
            'pass_accuracy',
            'assist',
            'pass_key',
            'big_chance_created'
        ]
    
    def get_pass_type(self, obj):
        """Simple pass type for listings"""
        if obj.pass_corner:
            return 'corner'
        elif obj.pass_cross_accurate or obj.pass_cross_inaccurate:
            return 'cross'
        elif obj.pass_freekick:
            return 'freekick'
        elif obj.pass_through_ball_accurate or obj.pass_through_ball_inaccurate:
            return 'through_ball'
        return 'regular'

class DetailedPassEventSerializer(PassEventSerializer):
    """Detailed serializer with all pass attributes"""
    assist_details = serializers.SerializerMethodField()
    key_pass_details = serializers.SerializerMethodField()
    pass_details = serializers.SerializerMethodField()
    location_stats = serializers.SerializerMethodField()

    class Meta(PassEventSerializer.Meta):
        fields = PassEventSerializer.Meta.fields + [
            'assist_details',
            'key_pass_details',
            'pass_details',
            'location_stats'
        ]

    def get_assist_details(self, obj):
        """Group assist-related attributes"""
        return {
            'is_assist': obj.assist,
            'types': {
                'corner': obj.assist_corner,
                'cross': obj.assist_cross,
                'freekick': obj.assist_freekick,
                'throughball': obj.assist_throughball,
                'throwin': obj.assist_throwin,
                'other': obj.assist_other
            },
            'intentional': obj.intentional_assist
        }

    def get_key_pass_details(self, obj):
        """Group key pass attributes"""
        return {
            'is_key_pass': obj.pass_key,
            'types': {
                'corner': obj.key_pass_corner,
                'cross': obj.key_pass_cross,
                'freekick': obj.key_pass_freekick,
                'long': obj.key_pass_long,
                'short': obj.key_pass_short,
                'throughball': obj.key_pass_throughball,
                'throwin': obj.key_pass_throwin,
                'other': obj.key_pass_other
            }
        }

    def get_pass_details(self, obj):
        """Group pass attributes"""
        return {
            'accuracy': {
                'accurate': obj.pass_accurate,
                'inaccurate': obj.pass_inaccurate
            },
            'types': {
                'corner': {
                    'attempted': obj.pass_corner,
                    'accurate': obj.pass_corner_accurate,
                    'inaccurate': obj.pass_corner_inaccurate
                },
                'cross': {
                    'accurate': obj.pass_cross_accurate,
                    'inaccurate': obj.pass_cross_inaccurate,
                    'blocked': obj.pass_cross_blocked_defensive
                },
                'freekick': {
                    'attempted': obj.pass_freekick,
                    'accurate': obj.pass_freekick_accurate,
                    'inaccurate': obj.pass_freekick_inaccurate
                },
                'long_ball': {
                    'accurate': obj.pass_long_ball_accurate,
                    'inaccurate': obj.pass_long_ball_inaccurate
                },
                'short': {
                    'accurate': obj.short_pass_accurate,
                    'inaccurate': obj.short_pass_inaccurate
                },
                'through_ball': {
                    'accurate': obj.pass_through_ball_accurate,
                    'inaccurate': obj.pass_through_ball_inaccurate
                }
            },
            'direction': {
                'forward': obj.pass_forward,
                'back': obj.pass_back,
                'left': obj.pass_left,
                'right': obj.pass_right
            },
            'body_part': {
                'head': obj.pass_head,
                'left_foot': obj.pass_left_foot,
                'right_foot': obj.pass_right_foot
            }
        }

    def get_location_stats(self, obj):
        """Location-based statistics"""
        return {
            'final_third': obj.successful_final_third_passes,
            'big_chance_created': obj.big_chance_created,
            'coordinates': {
                'start': {'x': obj.x, 'y': obj.y},
                'end': {'x': obj.end_x, 'y': obj.end_y}
            }
        }

================
File: v1/serializers/stats/__init__.py
================
from .player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from .team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer

__all__ = [
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: v1/serializers/stats/player_stats.py
================
from rest_framework import serializers
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer


class PlayerMatchStatsSerializer(
        BaseMatchStatsSerializer, BasePlayerStatsSerializer):
    """Detailed stats for a player in a specific match"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    # Changed from DateField to DateTimeField to match match.start_datetime
    match_date = serializers.DateTimeField()
    position = serializers.CharField()
    shirt_no = serializers.IntegerField()
    is_first_eleven = serializers.BooleanField()

    # Shooting stats
    shots = serializers.IntegerField(default=0)
    shots_on_target = serializers.IntegerField(default=0)
    goals = serializers.IntegerField(default=0)
    big_chances = serializers.IntegerField(default=0)

    # Passing stats
    passes_attempted = serializers.IntegerField(default=0)
    passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    key_passes = serializers.IntegerField(default=0)
    assists = serializers.IntegerField(default=0)

    # Defending stats
    tackles = serializers.IntegerField(default=0)
    interceptions = serializers.IntegerField(default=0)
    ball_recoveries = serializers.IntegerField(default=0)
    duels_won = serializers.IntegerField(default=0)


class PlayerSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BasePlayerStatsSerializer):
    """Season stats serializer"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()
    games_played = serializers.IntegerField()
    games_started = serializers.IntegerField()

    # Aggregated shooting stats
    total_shots = serializers.IntegerField(default=0)
    total_shots_on_target = serializers.IntegerField(default=0)
    total_goals = serializers.IntegerField(default=0)
    total_big_chances = serializers.IntegerField(default=0)

    # Aggregated passing stats
    total_passes = serializers.IntegerField(default=0)
    total_passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    total_key_passes = serializers.IntegerField(default=0)
    total_assists = serializers.IntegerField(default=0)

    # Aggregated defending stats
    total_tackles = serializers.IntegerField(default=0)
    total_interceptions = serializers.IntegerField(default=0)
    total_ball_recoveries = serializers.IntegerField(default=0)
    total_duels_won = serializers.IntegerField(default=0)

    # Per game averages
    avg_shots = serializers.FloatField(default=0.0)
    avg_passes = serializers.FloatField(default=0.0)
    avg_tackles = serializers.FloatField(default=0.0)

================
File: v1/serializers/stats/team_stats.py
================
from rest_framework import serializers
from ..base.match import TeamBasicSerializer
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BaseTeamStatsSerializer


class TeamMatchStatsSerializer(
        BaseMatchStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics for a specific match"""
    team = TeamBasicSerializer()
    manager_name = serializers.CharField()
    average_age = serializers.FloatField()

    # Event stats from 'possession' category
    possession = serializers.FloatField(
        source='event_stats.possession.possession_pct', default=0)
    touches = serializers.IntegerField(
        source='event_stats.possession.touches', default=0)
    possession_lost = serializers.IntegerField(
        source='event_stats.possession.possession_lost', default=0)

    # Event stats from 'shooting' category
    total_shots = serializers.IntegerField(
        source='event_stats.shooting.total_shots', default=0)
    shots_on_target = serializers.IntegerField(
        source='event_stats.shooting.shots_on_target', default=0)
    goals = serializers.IntegerField(
        source='event_stats.shooting.goals', default=0)
    big_chances = serializers.IntegerField(
        source='event_stats.shooting.big_chances', default=0)

    # Event stats from 'passing' category
    total_passes = serializers.IntegerField(
        source='event_stats.passing.total_passes', default=0)
    accurate_passes = serializers.IntegerField(
        source='event_stats.passing.accurate_passes', default=0)
    key_passes = serializers.IntegerField(
        source='event_stats.passing.key_passes', default=0)
    assists = serializers.IntegerField(
        source='event_stats.passing.assists', default=0)

    # Event stats from 'defending' category
    tackles_won = serializers.IntegerField(
        source='event_stats.defending.tackles_won', default=0)
    interceptions = serializers.IntegerField(
        source='event_stats.defending.interceptions', default=0)
    clearances = serializers.IntegerField(
        source='event_stats.defending.clearances', default=0)
    blocks = serializers.IntegerField(
        source='event_stats.defending.blocks', default=0)


class TeamSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics aggregated over a season"""
    team = TeamBasicSerializer()
    matches_played = serializers.IntegerField()
    goals_for = serializers.IntegerField()
    avg_possession = serializers.FloatField()
    avg_age = serializers.FloatField(allow_null=True)
    home_matches = serializers.IntegerField()
    away_matches = serializers.IntegerField()
    manager = serializers.CharField()
    formation = serializers.CharField()

================
File: v1/serializers/__init__.py
================
from .base.common import (
    BaseStatsSerializer,
    BaseMatchStatsSerializer,
    BaseSeasonStatsSerializer,
    BasePlayerStatsSerializer,
    BaseTeamStatsSerializer,
)
from .base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)
from .base.events import (
    BaseEventSerializer,
    get_event_serializer
)
from .base.match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)
from .stats.player_stats import (
    PlayerMatchStatsSerializer,
    PlayerSeasonStatsSerializer
)
from .stats.team_stats import (
    TeamMatchStatsSerializer,
    TeamSeasonStatsSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer',
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: v1/serializers/base.py
================
from rest_framework import serializers


class BaseSerializer(serializers.ModelSerializer):
    """Base serializer adding success wrapper"""

    def to_representation(self, instance):
        data = super().to_representation(instance)
        if isinstance(data, list):
            return {
                'status': 'success',
                'data': data,
                'message': None
            }
        return data


class HalModelSerializer(BaseSerializer):
    """Base serializer that adds HAL-style _links"""
    _links = serializers.SerializerMethodField('get__links')

    def get__links(self, obj):
        """Default empty implementation"""
        return {}

    def to_representation(self, instance):
        data = super().to_representation(instance)
        links = self.get__links(instance)
        if links:
            data['_links'] = links
        return data

================
File: v1/services/events/__init__.py
================
from .event_aggregator import EventAggregator

__all__ = ['EventAggregator']

================
File: v1/services/events/event_aggregator.py
================
from django.db.models import Count, Q, Sum, F
from sbapi.models.events import (
    ShootingEvent,
    PassEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent
)


class EventAggregator:
    """Service for aggregating and calculating event statistics"""

    def get_match_events(self, match_id, event_type=None):
        """Get events for a match with optional type filtering"""
        try:
            event_mapping = {
                'shooting': ShootingEvent,
                'passing': PassEvent,
                'defending': DefendingEvent,
                'goalkeeper': GoalkeeperEvent,
                'possession': PossessionEvent
            }

            if event_type:
                if event_type not in event_mapping:
                    return {'status': 'error', 'message': 'Invalid event type'}

                events = event_mapping[event_type].objects.filter(
                    match_id=match_id
                ).select_related('team', 'player')

                return {
                    'events': events,
                    'count': events.count(),
                    'status': 'success'
                }

            # If no type specified, return counts for each type
            return {
                'counts': {
                    event_type: model.objects.filter(
                        match_id=match_id
                    ).count()
                    for event_type, model in event_mapping.items()
                },
                'status': 'success'
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_team_match_events(self, match_id, team_id):
        """Aggregate all events for a team in a match"""
        try:
            event_stats = {
                'possession': self._get_possession_stats(match_id, team_id),
                'shooting': self._get_shooting_stats(match_id, team_id),
                'passing': self._get_passing_stats(match_id, team_id),
                'defending': self._get_defending_stats(match_id, team_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_player_match_events(self, match_id, player_id):
        """Aggregate all events for a player in a match"""
        try:
            event_stats = {
                'shooting': self._get_player_shooting_stats(match_id, player_id),
                'passing': self._get_player_passing_stats(match_id, player_id),
                'defending': self._get_player_defending_stats(match_id, player_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def _get_possession_stats(self, match_id, team_id):
        """Calculate possession-related stats"""
        return PossessionEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            touches=Count('touches', filter=Q(touches=True)),
            possession_lost=Count('dispossessed', filter=Q(dispossessed=True)),
            dribbles_won=Count('dribble_won', filter=Q(dribble_won=True)),
            dribbles_lost=Count('dribble_lost', filter=Q(dribble_lost=True))
        )

    def _get_shooting_stats(self, match_id, team_id):
        """Calculate shooting-related stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_passing_stats(self, match_id, team_id):
        """Calculate passing-related stats"""
        return PassEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_passes=Count('id'),
            accurate_passes=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True)),
            big_chances_created=Count(
                'big_chance_created', filter=Q(
                    big_chance_created=True))
        )

    def _get_defending_stats(self, match_id, team_id):
        """Calculate defending-related stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            tackles_won=Count('tackle_won', filter=Q(tackle_won=True)),
            interceptions=Count(
                'interception_won', filter=Q(
                    interception_won=True)),
            clearances=Count('is_clearance', filter=Q(is_clearance=True)),
            blocks=Count('outfielder_block', filter=Q(outfielder_block=True))
        )

    def _get_player_shooting_stats(self, match_id, player_id):
        """Calculate player shooting stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_player_passing_stats(self, match_id, player_id):
        """Calculate player passing stats"""
        stats = PassEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            passes_attempted=Count('id'),
            passes_completed=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True))
        )

        # Calculate pass accuracy if there were attempts
        if stats['passes_attempted'] > 0:
            stats['pass_accuracy'] = (
                stats['passes_completed'] / stats['passes_attempted']) * 100
        else:
            stats['pass_accuracy'] = 0

        return stats

    def _get_player_defending_stats(self, match_id, player_id):
        """Calculate player defending stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            tackles=Count('is_tackle', filter=Q(is_tackle=True)),
            interceptions=Count(
                'is_interception', filter=Q(
                    is_interception=True)),
            ball_recoveries=Count(
                'is_ball_recovery', filter=Q(
                    is_ball_recovery=True)),
            duels_won=Count('defensive_duel', filter=Q(defensive_duel=True))
        )

================
File: v1/services/player_analytics/__init__.py
================
from .base import BaseStatsService
from .passing import PassingStatsService
# Add other services as you create them:
# from .shooting import ShootingStatsService

__all__ = [
    'BaseStatsService',
    'PassingStatsService'
]

================
File: v1/services/player_analytics/base.py
================
from django.db.models import Count, Q


class BaseStatsService:
    """Base class for all stats services"""
    
    def get_match_events(self, match_id, player_id):
        """Get raw events for a player in a match"""
        queryset = self.get_base_queryset(match_id, player_id)
        return self.get_events_serializer()(queryset, many=True).data

    def get_base_queryset(self, match_id, player_id):
        """Get base queryset for events"""
        raise NotImplementedError
    
    def get_events_serializer(self):
        """Get serializer for events"""
        raise NotImplementedError

================
File: v1/services/player_analytics/passing.py
================
# services/stats.py
from django.db.models import Count, Q
from sbapi.models.events import PassEvent
from ...serializers.match_events.passing import DetailedPassEventSerializer
from .base import BaseStatsService

class PassingStatsService(BaseStatsService):
    """Service for calculating passing statistics"""
    
    def get_base_queryset(self, match_id, player_id):
        return PassEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).select_related('team', 'player')
    
    def get_events_serializer(self):
        return DetailedPassEventSerializer
    
    def get_player_match_stats(self, match_id, player_id):
        """Get aggregated pass stats for a match"""
        try:
            queryset = self.get_base_queryset(match_id, player_id)
            
            if not queryset.exists():
                return {
                    'status': 'error',
                    'message': f'No passing events found for player {player_id} in match {match_id}'
                }
            
            # Calculate basic stats
            basic_stats = queryset.aggregate(
                total_passes=Count('id'),
                accurate_passes=Count('id', filter=Q(pass_accurate=True)),
                assists=Count('id', filter=Q(assist=True)),
                key_passes=Count('id', filter=Q(pass_key=True)),
                big_chances=Count('id', filter=Q(big_chance_created=True))
            )
            
            # Pass types
            pass_types = queryset.aggregate(
                corners=Count('id', filter=Q(pass_corner=True)),
                crosses_accurate=Count('id', filter=Q(pass_cross_accurate=True)),
                crosses_inaccurate=Count('id', filter=Q(pass_cross_inaccurate=True)),
                through_balls_accurate=Count('id', filter=Q(pass_through_ball_accurate=True)),
                through_balls_inaccurate=Count('id', filter=Q(pass_through_ball_inaccurate=True))
            )
            
            # Calculate percentages
            total_passes = basic_stats['total_passes']
            
            return {
                'status': 'success',
                'stats': {
                    'basic': {
                        'total_passes': total_passes,
                        'accurate_passes': basic_stats['accurate_passes'],
                        'pass_accuracy': self._calculate_percentage(
                            basic_stats['accurate_passes'], 
                            total_passes
                        ),
                        'assists': basic_stats['assists'],
                        'key_passes': basic_stats['key_passes'],
                        'big_chances_created': basic_stats['big_chances']
                    },
                    'types': {
                        'corners': pass_types['corners'],
                        'crosses': {
                            'total': pass_types['crosses_accurate'] + pass_types['crosses_inaccurate'],
                            'accurate': pass_types['crosses_accurate'],
                            'accuracy': self._calculate_percentage(
                                pass_types['crosses_accurate'],
                                pass_types['crosses_accurate'] + pass_types['crosses_inaccurate']
                            )
                        },
                        'through_balls': {
                            'total': pass_types['through_balls_accurate'] + pass_types['through_balls_inaccurate'],
                            'accurate': pass_types['through_balls_accurate'],
                            'accuracy': self._calculate_percentage(
                                pass_types['through_balls_accurate'],
                                pass_types['through_balls_accurate'] + pass_types['through_balls_inaccurate']
                            )
                        }
                    }
                }
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def get_player_season_stats(self, competition_id, season_id, player_id):
        """Get season aggregated stats"""
        try:
            from sbapi.models import Match
            
            # Get all matches for the player in this season
            matches = Match.objects.filter(
                season__competition_id=competition_id,
                season_id=season_id,
                matchplayer__player_id=player_id
            ).values_list('id', flat=True)
            
            if not matches:
                return {
                    'status': 'error',
                    'message': f'No matches found for player {player_id} in season {season_id}'
                }
            
            # Get all passing events for these matches
            events = PassEvent.objects.filter(
                match_id__in=matches,
                player_id=player_id
            )
            
            # Calculate totals
            totals = events.aggregate(
                total_passes=Count('id'),
                accurate_passes=Count('id', filter=Q(pass_accurate=True)),
                assists=Count('id', filter=Q(assist=True)),
                key_passes=Count('id', filter=Q(pass_key=True)),
                big_chances=Count('id', filter=Q(big_chance_created=True))
            )
            
            matches_played = len(matches)
            
            return {
                'status': 'success',
                'stats': {
                    'matches_played': matches_played,
                    'totals': {
                        'passes': totals['total_passes'],
                        'accurate_passes': totals['accurate_passes'],
                        'pass_accuracy': self._calculate_percentage(
                            totals['accurate_passes'],
                            totals['total_passes']
                        ),
                        'assists': totals['assists'],
                        'key_passes': totals['key_passes'],
                        'big_chances_created': totals['big_chances']
                    },
                    'per_90': {
                        'passes': self._calculate_per_90(
                            totals['total_passes'], 
                            matches_played
                        ),
                        'key_passes': self._calculate_per_90(
                            totals['key_passes'],
                            matches_played
                        ),
                        'assists': self._calculate_per_90(
                            totals['assists'],
                            matches_played
                        )
                    }
                }
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def _calculate_percentage(self, part, total):
        """Calculate percentage with zero handling"""
        return round((part / total * 100) if total > 0 else 0, 2)
    
    def _calculate_per_90(self, value, matches):
        """Calculate per 90 minutes value"""
        return round((value / matches) * 90, 2)

================
File: v1/services/stats/__init__.py
================
from .player_stats import PlayerStatsService
from .team_stats import TeamStatsService

__all__ = [
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: v1/services/stats/player_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from sbapi.models import (
    ShootingEvent,
    PassEvent,
    DefendingEvent
)
from ..events.event_aggregator import EventAggregator

from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from ..events.event_aggregator import EventAggregator


class PlayerStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, player_id):
        """Calculate detailed player stats for a specific match"""
        try:
            # Get basic match player info
            match_player = MatchPlayer.objects.get(
                match_id=match_id,
                player_id=player_id
            )

            # Get event-based stats
            event_stats = self.event_aggregator.get_player_match_events(
                match_id,
                player_id
            )

            if event_stats['status'] == 'error':
                return event_stats

            return {
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except MatchPlayer.DoesNotExist:
            return {
                'status': 'error',
                'message': f'No stats found for player {player_id} in match {match_id}'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, player_id):
        """Calculate player stats for entire season"""
        try:
            # Get all matches for player in season
            matches = MatchPlayer.objects.filter(
                match__season__competition_id=competition_id,
                match__season_id=season_id,
                player_id=player_id
            ).select_related(
                'match',
                'player',
                'team'
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No stats found for player {player_id} in season {season_id}'
                }

            # Get latest match for player info
            latest_match = matches.order_by('-match__start_datetime').first()
            games_played = matches.count()

            # Get event stats for all matches
            match_ids = list(matches.values_list('match_id', flat=True))

            # Initialize totals
            totals = {
                'total_shots': 0,
                'total_shots_on_target': 0,
                'total_goals': 0,
                'total_big_chances': 0,
                'total_passes': 0,
                'total_passes_completed': 0,
                'total_key_passes': 0,
                'total_assists': 0,
                'total_tackles': 0,
                'total_interceptions': 0,
                'total_ball_recoveries': 0,
                'total_duels_won': 0
            }

            # Calculate totals across all matches
            for match_id in match_ids:
                match_stats = self.event_aggregator.get_player_match_events(
                    match_id, player_id)
                if match_stats['status'] == 'success':
                    # Add shooting stats
                    shooting = match_stats['stats']['shooting']
                    totals['total_shots'] += shooting.get('shots', 0)
                    totals['total_shots_on_target'] += shooting.get(
                        'shots_on_target', 0)
                    totals['total_goals'] += shooting.get('goals', 0)
                    totals['total_big_chances'] += shooting.get(
                        'big_chances', 0)

                    # Add passing stats
                    passing = match_stats['stats']['passing']
                    totals['total_passes'] += passing.get(
                        'passes_attempted', 0)
                    totals['total_passes_completed'] += passing.get(
                        'passes_completed', 0)
                    totals['total_key_passes'] += passing.get('key_passes', 0)
                    totals['total_assists'] += passing.get('assists', 0)

                    # Add defending stats
                    defending = match_stats['stats']['defending']
                    totals['total_tackles'] += defending.get('tackles', 0)
                    totals['total_interceptions'] += defending.get(
                        'interceptions', 0)
                    totals['total_ball_recoveries'] += defending.get(
                        'ball_recoveries', 0)
                    totals['total_duels_won'] += defending.get('duels_won', 0)

            # Calculate averages
            stats = {
                # Basic info
                'player_name': latest_match.player.name,
                'team_name': latest_match.team.name,
                'position': latest_match.position,
                'games_played': games_played,
                'games_started': matches.filter(is_first_eleven=True).count(),

                # Add all totals
                **totals,

                # Calculate overall pass accuracy
                'pass_accuracy': (
                    (totals['total_passes_completed'] /
                     totals['total_passes'] * 100)
                    if totals['total_passes'] > 0 else 0
                ),

                # Calculate per game averages
                'avg_shots': totals['total_shots'] / games_played if games_played > 0 else 0,
                'avg_passes': totals['total_passes'] / games_played if games_played > 0 else 0,
                'avg_tackles': totals['total_tackles'] / games_played if games_played > 0 else 0
            }

            return {
                'status': 'success',
                'stats': stats
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: v1/services/stats/team_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q, Case, When, FloatField
from django.db.models.functions import Cast
from sbapi.models import Team, Match
from ..events.event_aggregator import EventAggregator


class TeamStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, team_id):
        """Calculate detailed team stats for a match"""
        try:
            # Get base match info
            match = Match.objects.select_related(
                'home_team',
                'away_team'
            ).get(match_id=match_id)

            # Verify team participated in match
            if team_id not in [match.home_team_id, match.away_team_id]:
                return {
                    'status': 'error',
                    'message': f'Team {team_id} did not participate in match {match_id}'
                }

            # Add team context for serializer
            match.team = match.home_team if match.home_team_id == team_id else match.away_team

            # Get event-based stats
            event_stats = self.event_aggregator.get_team_match_events(
                match_id, team_id)

            if event_stats['status'] == 'error':
                return event_stats

            # Calculate possession percentage if not already included
            if 'possession' not in event_stats['stats']:
                total_touches = event_stats['stats']['possession'].get(
                    'touches', 0)
                opponent_id = match.away_team_id if team_id == match.home_team_id else match.home_team_id
                opponent_stats = self.event_aggregator.get_team_match_events(
                    match_id, opponent_id)
                if opponent_stats['status'] == 'success':
                    opponent_touches = opponent_stats['stats']['possession'].get(
                        'touches', 0)
                    if total_touches + opponent_touches > 0:
                        possession_pct = (
                            total_touches / (total_touches + opponent_touches)) * 100
                        event_stats['stats']['possession']['possession_pct'] = round(
                            possession_pct, 1)
                    else:
                        event_stats['stats']['possession']['possession_pct'] = 0

            # Calculate pass accuracy if not already included
            if 'pass_accuracy' not in event_stats['stats'].get('passing', {}):
                total_passes = event_stats['stats']['passing'].get(
                    'total_passes', 0)
                accurate_passes = event_stats['stats']['passing'].get(
                    'accurate_passes', 0)
                if total_passes > 0:
                    pass_accuracy = (accurate_passes / total_passes) * 100
                    event_stats['stats']['passing']['pass_accuracy'] = round(
                        pass_accuracy, 1)
                else:
                    event_stats['stats']['passing']['pass_accuracy'] = 0

            return {
                'match': match,
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except Match.DoesNotExist:
            return {
                'status': 'error',
                'message': f'Match {match_id} not found'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, team_id):
        """Calculate season aggregated stats for a team"""
        try:
            # Get all matches for the team in this season
            matches = (
                Match.objects
                .filter(
                    Q(home_team_id=team_id) | Q(away_team_id=team_id),
                    season__competition_id=competition_id,
                    season_id=season_id
                )
                .select_related('home_team', 'away_team', 'season')
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No matches found for team {team_id} in season {season_id}'
                }

            # Get team info from first match
            first_match = matches.first()
            team = first_match.home_team if first_match.home_team_id == team_id else first_match.away_team
            match_count = matches.count()

            # Initialize aggregated stats with properly formatted team dict
            stats = {
                'team': {
                    'team_id': team.team_id,  # Changed from id to team_id
                    'name': team.name,
                    'country': team.country
                },
                'matches_played': match_count,
                'home_matches': matches.filter(home_team_id=team_id).count(),
                'away_matches': matches.filter(away_team_id=team_id).count(),
                'avg_possession': 0,
                'total_shots': 0,
                'shots_on_target': 0,
                'goals_for': 0,
                'total_passes': 0,
                'accurate_passes': 0,
                'key_passes': 0,
                'assists': 0,
                'tackles_won': 0,
                'interceptions': 0,
                'clearances': 0
            }

        # Rest of the method remains the same...

            # Calculate goals
            goals = matches.aggregate(
                goals_for=Sum(Case(
                    When(home_team_id=team_id, then='home_score_ft'),
                    When(away_team_id=team_id, then='away_score_ft'),
                    default=0,
                    output_field=FloatField()
                ))
            )
            stats['goals_for'] = goals['goals_for'] or 0

            # Calculate average age
            ages = matches.aggregate(
                avg_age=Avg(Case(
                    When(home_team_id=team_id, then='home_team_average_age'),
                    When(away_team_id=team_id, then='away_team_average_age'),
                    default=None,
                    output_field=FloatField()
                ))
            )
            stats['avg_age'] = round(
                ages['avg_age'], 1) if ages['avg_age'] else None

            # Get latest match info
            latest_match = matches.order_by('-start_datetime').first()
            if latest_match:
                stats['manager'] = (
                    latest_match.home_manager_name
                    if latest_match.home_team_id == team_id
                    else latest_match.away_manager_name
                )

                latest_formation = latest_match.formation_set.filter(
                    team_id=team_id
                ).order_by('-start_minute').first()

                stats['formation'] = latest_formation.formation_name if latest_formation else 'Unknown'

                # Aggregate event stats from all matches
                total_possession = 0
                for match in matches:
                    event_stats = self.event_aggregator.get_team_match_events(
                        match.match_id,
                        team_id
                    )
                    if event_stats['status'] == 'success':
                        # Add up possession %
                        possession = event_stats['stats']['possession'].get(
                            'possession_pct', 0)
                        total_possession += possession

                        # Add up other stats
                        shooting = event_stats['stats']['shooting']
                        stats['total_shots'] += shooting.get('total_shots', 0)
                        stats['shots_on_target'] += shooting.get(
                            'shots_on_target', 0)

                        passing = event_stats['stats']['passing']
                        stats['total_passes'] += passing.get('total_passes', 0)
                        stats['accurate_passes'] += passing.get(
                            'accurate_passes', 0)
                        stats['key_passes'] += passing.get('key_passes', 0)
                        stats['assists'] += passing.get('assists', 0)

                        defending = event_stats['stats']['defending']
                        stats['tackles_won'] += defending.get('tackles_won', 0)
                        stats['interceptions'] += defending.get(
                            'interceptions', 0)
                        stats['clearances'] += defending.get('clearances', 0)

                # Calculate averages
                if match_count > 0:
                    stats['avg_possession'] = round(
                        total_possession / match_count, 1)
                    stats['avg_shots'] = round(
                        stats['total_shots'] / match_count, 1)
                    stats['avg_passes'] = round(
                        stats['total_passes'] / match_count, 1)

                # Calculate pass accuracy
                if stats['total_passes'] > 0:
                    stats['pass_accuracy'] = round(
                        (stats['accurate_passes'] /
                         stats['total_passes']) * 100,
                        1
                    )
                else:
                    stats['pass_accuracy'] = 0

            return {
                'stats': stats,
                'status': 'success'
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: v1/services/__init__.py
================
from .events.event_aggregator import EventAggregator
from .stats.player_stats import PlayerStatsService
from .stats.team_stats import TeamStatsService

__all__ = [
    'EventAggregator',
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: v1/views/base/__init__.py
================
from .base import BaseViewSet
from .competition import CompetitionViewSet, CompetitionSeasonsView
from .events import MatchEventsViewSet, EventTypeView
from .match import MatchViewSet

__all__ = [
    'BaseViewSet',
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet'
]

================
File: v1/views/base/base.py
================
from rest_framework import viewsets
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound


class BaseViewSet(viewsets.ReadOnlyModelViewSet):
    """Base ViewSet adding success wrapper and lookup field configuration"""

    # Use match_id/competition_id instead of pk where appropriate
    lookup_field = 'pk'  # Override in child classes if needed

    def get_object(self):
        try:
            queryset = self.filter_queryset(self.get_queryset())

            lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
            lookup_value = self.kwargs.get(
                lookup_url_kwarg) or self.kwargs.get('pk')

            if not lookup_value:
                return None

            filter_kwargs = {self.lookup_field: lookup_value}
            obj = queryset.get(**filter_kwargs)

            self.check_object_permissions(self.request, obj)
            return obj
        except (self.queryset.model.DoesNotExist, ValidationError):
            raise NotFound(f"{self.queryset.model.__name__} not found")
        except Exception as e:
            raise ValidationError(f"Error retrieving object: {str(e)}")

    def get_response(self, data):
        """Wrap response in success format"""
        if isinstance(data, list) or (
                isinstance(data, dict) and 'results' in data):
            return Response({
                'status': 'success',
                'data': data,
                'message': None
            })
        # Individual objects already wrapped by serializer
        return Response(data)

    def list(self, request, *args, **kwargs):
        response = super().list(request, *args, **kwargs)
        return self.get_response(response.data)

    def retrieve(self, request, *args, **kwargs):
        response = super().retrieve(request, *args, **kwargs)
        return self.get_response(response.data)

================
File: v1/views/base/competition.py
================
from rest_framework import viewsets, generics
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .base import BaseViewSet
from ....models import Competition, Season
from ...serializers.base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)


class CompetitionViewSet(BaseViewSet):
    """API endpoint for viewing competitions"""
    queryset = Competition.objects.all()
    lookup_field = 'competition_id'
    lookup_url_kwarg = 'competition_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return CompetitionListSerializer
        return CompetitionDetailSerializer


class CompetitionSeasonsView(generics.ListAPIView):
    """API endpoint for viewing seasons of a competition"""
    serializer_class = SeasonSerializer

    def get_queryset(self):
        competition_id = self.kwargs['competition_id']
        return Season.objects.filter(competition_id=competition_id)

================
File: v1/views/base/events.py
================
from rest_framework import viewsets, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from django.db.models import Count, Q
from itertools import chain

from ..base.base import BaseViewSet

from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)

from ...serializers.base.events import (
    BaseEventSerializer,
    get_event_serializer,
    EVENT_TYPE_SERIALIZERS
)

EVENT_TYPE_MODELS = {
    'defending': DefendingEvent,
    'goalkeeper': GoalkeeperEvent,
    'passing': PassEvent,
    'possession': PossessionEvent,
    'shooting': ShootingEvent,
    'summary': SummaryEvent,
}


class MatchEventsViewSet(BaseViewSet):
    """ViewSet for handling all match events"""
    serializer_class = BaseEventSerializer

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.request.query_params.get('type', None)

        if not match_id:
            raise ValidationError("Match ID is required")

        # If specific event type requested
        if event_type and event_type.lower() in EVENT_TYPE_MODELS:
            model = EVENT_TYPE_MODELS[event_type.lower()]
            return model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            ).order_by('minute', 'second')

        # If no specific type, combine all event types
        all_events = []
        for model in EVENT_TYPE_MODELS.values():
            events = model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            )
            all_events.append(events)

        # Handle None values by defaulting to 0 during sorting
        def sort_key(x):
            return (x.minute, x.second if x.second is not None else 0)

        combined_events = sorted(chain(*all_events), key=sort_key)

        return combined_events

    def get_serializer_class(self):
        event_type = self.request.query_params.get('type')
        if event_type and event_type.lower() in EVENT_TYPE_SERIALIZERS:
            return EVENT_TYPE_SERIALIZERS[event_type.lower()]
        return BaseEventSerializer

    @action(detail=False, methods=['get'])
    def stats(self, request, match_id=None):
        """Get aggregated stats for match events"""
        stats = {
            'total_events': 0,
            'by_type': {},
            'by_team': {},
            'by_period': {
                'FirstHalf': 0,
                'SecondHalf': 0
            }
        }

        # Aggregate stats across all event types
        for event_type, model in EVENT_TYPE_MODELS.items():
            events = model.objects.filter(match_id=match_id)
            event_count = events.count()
            stats['total_events'] += event_count

            # Stats by event type
            stats['by_type'][event_type] = event_count

            # Stats by period
            first_half = events.filter(period='FirstHalf').count()
            second_half = events.filter(period='SecondHalf').count()
            stats['by_period']['FirstHalf'] += first_half
            stats['by_period']['SecondHalf'] += second_half

            # Stats by team
            team_counts = events.values(
                'team__name'
            ).annotate(
                count=Count('id')
            )

            for team in team_counts:
                team_name = team['team__name']
                if team_name not in stats['by_team']:
                    stats['by_team'][team_name] = 0
                stats['by_team'][team_name] += team['count']

        return Response({
            'status': 'success',
            'data': stats,
            'message': None
        })


class EventTypeView(generics.ListAPIView):
    """View for handling specific event types for a match"""

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.kwargs.get('event_type', '').lower()

        if event_type not in EVENT_TYPE_MODELS:
            raise ValidationError(f"Invalid event type: {event_type}")

        model = EVENT_TYPE_MODELS[event_type]
        return model.objects.filter(
            match_id=match_id
        ).select_related(
            'team',
            'player'
        ).order_by('minute', 'second')

    def get_serializer_class(self):
        event_type = self.kwargs.get('event_type', '').lower()
        return get_event_serializer(event_type)

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: v1/views/base/match.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Q, Prefetch
from django.shortcuts import get_object_or_404
from sbapi.models import Match, MatchPlayer, Formation, SummaryEvent
from ...serializers.base.match import (
    MatchListSerializer,
    MatchDetailSerializer,
    LineupResponseSerializer
)
from .base import BaseViewSet


class MatchViewSet(BaseViewSet):
    """ViewSet for managing match data."""
    lookup_field = 'match_id'
    lookup_url_kwarg = 'match_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return MatchListSerializer
        return MatchDetailSerializer

    def get_queryset(self):
        """Retrieve matches with relevant data."""
        queryset = Match.objects.select_related(
            'home_team',
            'away_team',
            'season',
            'season__competition'
        )

        if self.action == 'lineups':
            queryset = queryset.prefetch_related(
                Prefetch(
                    'formation_set',
                    queryset=Formation.objects.select_related(
                        'team').order_by('start_minute')
                ),
                Prefetch(
                    'matchplayer_set',
                    queryset=MatchPlayer.objects.select_related(
                        'player', 'team')
                )
            )

        # Get query parameters
        competition_id = self.request.query_params.get('competition_id')
        season_id = self.request.query_params.get('season_id')

        if competition_id and season_id:
            queryset = queryset.filter(
                season__competition_id=competition_id,
                season_id=season_id
            )

        return queryset.order_by('-start_datetime')

    @action(detail=True, methods=['get'], url_path='lineups')
    def lineups(self, request, **kwargs):
        """Retrieve detailed lineup information."""
        match = self.get_object()

        # Retrieve formations
        home_formations = Formation.objects.filter(
            match=match,
            team=match.home_team
        ).order_by('start_minute')

        away_formations = Formation.objects.filter(
            match=match,
            team=match.away_team
        ).order_by('start_minute')

        # Retrieve starting lineups
        home_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.home_team,
            is_first_eleven=True
        ).select_related('player')

        away_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.away_team,
            is_first_eleven=True
        ).select_related('player')

        # Retrieve substitutions
        substitutions = (
            SummaryEvent.objects.filter(
                Q(sub_on=True) | Q(sub_off=True),
                match=match
            )
            .select_related('team')
            .order_by('minute')
        )

        # Organize substitutions by team
        home_subs = []
        away_subs = []
        for sub in substitutions:
            sub_data = {
                'minute': sub.minute,
                'player': sub.player_name,
                'type': 'on' if sub.sub_on else 'off'
            }
            if sub.team_id == match.home_team_id:
                home_subs.append(sub_data)
            else:
                away_subs.append(sub_data)

        # Prepare response data
        response_data = {
            'home_team': {
                'team': match.home_team,
                'starting_formation': home_formations.first().formation_name if home_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in home_formations[1:]
                ],
                'starting_lineup': home_starters,
                'substitutions': home_subs
            },
            'away_team': {
                'team': match.away_team,
                'starting_formation': away_formations.first().formation_name if away_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in away_formations[1:]
                ],
                'starting_lineup': away_starters,
                'substitutions': away_subs
            }
        }

        serializer = LineupResponseSerializer(response_data)
        return Response({
            'status': 'success',
            'data': serializer.data,
            'message': None
        })

================
File: v1/views/player_analytics/match_events.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base import BaseViewSet
from ...services.player_analytics.passing import PassingStatsService

class EventsViewSet(BaseViewSet):
    """ViewSet for raw event data"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.passing_service = PassingStatsService()
        # Will add other services as needed:
        # self.shooting_service = ShootingStatsService()

    @action(detail=True, methods=['get'])
    def player_events(self, request, match_id, player_id):
        """Get all events for a player in a match"""
        try:
            events = self.passing_service.get_match_events(match_id, player_id)
            if events['status'] == 'error':
                raise NotFound(events['message'])
            
            return self.get_response(events['data'])
            
        except Exception as e:
            raise ValidationError(str(e))

================
File: v1/views/player_analytics/match.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import MatchPlayer, Season
from ...services.player_analytics.passing import PassingStatsService

class PlayerStatsViewSet(BaseViewSet):
    """ViewSet for player statistics"""
    passing_stats_service = PassingStatsService()
    # Add other services as needed:
    # shooting_stats_service = ShootingStatsService()
    
    @action(detail=True, methods=['get'])
    def match_stats(self, request, *args, **kwargs):
        """Get player stats for a specific match"""
        match_id = kwargs.get('match_id')
        player_id = kwargs.get('player_id')

        # Get event stats first
        stats_result = self.passing_stats_service.get_player_match_stats(
            match_id, player_id)

        if stats_result['status'] == 'error':
            raise NotFound(stats_result['message'])

        # Get match player info
        match_player = get_object_or_404(
            MatchPlayer.objects.select_related('player', 'team', 'match'),
            match_id=match_id,
            player_id=player_id
        )

        # Create data dictionary combining match player info and event stats
        all_stats = {
            'player_name': match_player.player.name,
            'team_name': match_player.team.name,
            'match_date': match_player.match.start_datetime,
            'position': match_player.position,
            'shirt_no': match_player.shirt_no,
            'is_first_eleven': match_player.is_first_eleven,
            'passing': stats_result['stats']
            # Add other event types as you create them:
            # 'shooting': shooting_result['stats']
        }

        return self.get_response(all_stats)

    @action(detail=True, methods=['get'])
    def season_stats(self, request, *args, **kwargs):
        """Get player stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        player_id = kwargs.get('player_id')

        result = self.passing_stats_service.get_player_season_stats(
            competition_id,
            season_id,
            player_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        stats_data = {
            'competition_name': season.competition.name,
            'season_name': season.name,
            'passing': result['stats']
            # Add other event types as you create them:
            # 'shooting': shooting_result['stats']
        }

        return self.get_response(stats_data)

================
File: v1/views/stats/__init__.py
================
from .player_stats import PlayerStatsViewSet
from .team_stats import TeamStatsViewSet

__all__ = [
    'PlayerStatsViewSet',
    'TeamStatsViewSet'
]

================
File: v1/views/stats/player_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import MatchPlayer, Season
from ...serializers.stats.player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from ...services.stats.player_stats import PlayerStatsService


class PlayerStatsViewSet(BaseViewSet):
    """ViewSet for player statistics"""
    player_stats_service = PlayerStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get player stats for a specific match"""
        match_id = kwargs.get('match_id')
        player_id = kwargs.get('player_id')

        # Get event stats first
        stats_result = self.player_stats_service.calculate_match_stats(
            match_id, player_id)

        if stats_result['status'] == 'error':
            raise NotFound(stats_result['message'])

        # Get match player info
        match_player = get_object_or_404(
            MatchPlayer.objects.select_related('player', 'team', 'match'),
            match_id=match_id,
            player_id=player_id
        )

        # Create data dictionary combining match player info and event stats
        all_stats = {
            'player_name': match_player.player.name,
            'team_name': match_player.team.name,
            'match_date': match_player.match.start_datetime,
            'position': match_player.position,
            'shirt_no': match_player.shirt_no,
            'is_first_eleven': match_player.is_first_eleven,
            **stats_result['event_stats']['shooting'],
            **stats_result['event_stats']['passing'],
            **stats_result['event_stats']['defending']
        }

        serializer = PlayerMatchStatsSerializer(all_stats)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get player stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        player_id = kwargs.get('player_id')

        result = self.player_stats_service.calculate_season_stats(
            competition_id,
            season_id,
            player_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = PlayerSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)
        return Response(serializer.data)

================
File: v1/views/stats/team_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import Season
from ...serializers.stats.team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer
from ...services.stats.team_stats import TeamStatsService


class TeamStatsViewSet(BaseViewSet):
    """ViewSet for team statistics"""
    team_stats_service = TeamStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get team stats for a specific match"""
        match_id = kwargs.get('match_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_match_stats(
            match_id, team_id)

        if result['status'] == 'error':
            raise NotFound(result['message'])

        match = result['match']
        # Determine if team is home or away
        is_home = match.home_team_id == team_id

        match_data = {
            'team': match.home_team if is_home else match.away_team,
            'manager_name': match.home_manager_name if is_home else match.away_manager_name,
            'average_age': match.home_team_average_age if is_home else match.away_team_average_age,
            'event_stats': result['event_stats']
        }

        serializer = TeamMatchStatsSerializer(match_data)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get team stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_season_stats(
            competition_id=competition_id,
            season_id=season_id,
            team_id=team_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = TeamSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)

        return Response(serializer.data)

================
File: v1/views/__init__.py
================
from .base.competition import CompetitionViewSet, CompetitionSeasonsView
from .base.events import MatchEventsViewSet, EventTypeView
from .base.match import MatchViewSet
from .stats.player_stats import PlayerStatsViewSet
from .stats.team_stats import TeamStatsViewSet

__all__ = [
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet',
    'PlayerStatsViewSet',
    'TeamStatsViewSet',
]

================
File: v1/urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views.base.competition import CompetitionViewSet, CompetitionSeasonsView
from .views.base.match import MatchViewSet
from .views.base.events import MatchEventsViewSet, EventTypeView
from .views.stats.player_stats import PlayerStatsViewSet
from .views.stats.team_stats import TeamStatsViewSet

# Create router for viewsets
router = DefaultRouter()
router.register(r'competitions', CompetitionViewSet, basename='competition')
router.register(r'matches', MatchViewSet, basename='match')

urlpatterns = [
    # Include router URLs
    path('', include(router.urls)),

    # Competition and season routes
    path('competitions/<int:competition_id>/seasons/',
         CompetitionSeasonsView.as_view()),  # ALL COMPS
    path('competitions/<int:competition_id>/seasons/<int:season_id>/', include([  # ALL SEASONS OF A COMP
        path('stats/players/<int:player_id>/',
             PlayerStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A PLAYER
        path('stats/teams/<int:team_id>/',
             TeamStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A TEAM
    ])),

    # Match routes
    path('matches/<int:match_id>/', include([
        # Match events
        path('events/', MatchEventsViewSet.as_view({'get': 'list'})),
        path('events/stats/', MatchEventsViewSet.as_view({'get': 'stats'})),
        path('events/<str:event_type>/', EventTypeView.as_view()),

        # Match stats
        path('stats/', include([
            path('players/<int:player_id>/',
                 PlayerStatsViewSet.as_view({'get': 'get_match_stats'})),
            path('teams/<int:team_id>/',
                 TeamStatsViewSet.as_view({'get': 'get_match_stats'})),
        ])),

        # Match lineups
        path('lineups/', MatchViewSet.as_view({'get': 'lineups'})),
    ])),
]

================
File: v1/utils.py
================
from rest_framework.views import exception_handler
from rest_framework.response import Response


def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)

    if response is not None:
        response.data = {
            'status': 'error',
            'message': str(exc),
            'data': response.data
        }

    return response

================
File: admin.py
================
from django.contrib import admin
from django.db.models import Count, Q
from .models import (
    Competition,
    Season,
    Team,
    Player,
    Match,
    Formation,
    MatchPlayer,
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)


@admin.register(Competition)
class CompetitionAdmin(admin.ModelAdmin):
    list_display = ('competition_id', 'name', 'country', 'get_seasons',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('country',)
    search_fields = ('name', 'country')

    def get_seasons(self, obj):
        return ", ".join([season.name for season in obj.season_set.all()])
    get_seasons.short_description = 'Seasons'

    def get_match_count(self, obj):
        return obj.season_set.aggregate(
            match_count=Count('match')
        )['match_count']
    get_match_count.short_description = 'Matches'


@admin.register(Season)
class SeasonAdmin(admin.ModelAdmin):
    list_display = ('season_id', 'name', 'competition', 'is_current',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('competition', 'is_current')
    search_fields = ('name', 'competition__name')

    def get_match_count(self, obj):
        return obj.match_set.count()
    get_match_count.short_description = 'Matches'


@admin.register(Team)
class TeamAdmin(admin.ModelAdmin):
    list_display = ('team_id', 'name', 'country')
    list_filter = ('country',)
    search_fields = ('name', 'country')
    list_per_page = 50


@admin.register(Player)
class PlayerAdmin(admin.ModelAdmin):
    list_display = ('player_id', 'name', 'get_matches_played')
    search_fields = ('name',)
    list_filter = ('matchplayer__team',)
    list_per_page = 50

    def get_matches_played(self, obj):
        return obj.matchplayer_set.count()
    get_matches_played.short_description = 'Matches Played'


@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('match_id', 'season', 'competition', 'start_datetime', 'home_team',
                    'score', 'away_team', 'venue', 'attendance', 'referee_name')
    list_filter = ('season__competition', 'season', 'start_datetime')
    search_fields = ('home_team__name', 'away_team__name', 'venue',
                     'season__competition__name', 'season__name')
    date_hierarchy = 'start_datetime'
    raw_id_fields = ('home_team', 'away_team', 'season')
    list_per_page = 50


@admin.register(Formation)
class FormationAdmin(admin.ModelAdmin):
    list_display = (
        'match',
        'team',
        'formation_name',
        'start_minute',
        'end_minute')
    list_filter = ('formation_name',)
    search_fields = (
        'match__home_team__name',
        'match__away_team__name',
        'team__name',
        'formation_name')
    list_per_page = 50


@admin.register(MatchPlayer)
class MatchPlayerAdmin(admin.ModelAdmin):
    list_display = ('match', 'player', 'team', 'position', 'is_first_eleven',
                    'is_man_of_match')
    list_filter = ('position', 'is_first_eleven', 'is_man_of_match')
    search_fields = ('player__name', 'team__name')
    raw_id_fields = ('match', 'player', 'team')
    list_per_page = 50

# Base Event Admin


class BaseEventAdmin(admin.ModelAdmin):
    list_display = ('id', 'match', 'team', 'player_name', 'minute', 'x', 'y', 'type',
                    'outcome_type', 'situation')
    list_filter = ('type', 'period', 'outcome_type', 'situation')
    search_fields = ('player_name', 'team__name')
    date_hierarchy = 'match__start_datetime'
    raw_id_fields = ('match', 'team', 'player')
    ordering = ('-match__start_datetime', 'minute')
    list_per_page = 50


@admin.register(PassEvent)
class PassEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('pass_accurate', 'assist', 'pass_key')
    list_filter = BaseEventAdmin.list_filter + (
        'pass_accurate', 'assist', 'pass_key', 'big_chance_created'
    )


@admin.register(ShootingEvent)
class ShootingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('is_goal', 'shot_on_target',
                                                  'big_chance_missed')
    list_filter = BaseEventAdmin.list_filter + (
        'is_goal', 'shot_on_target', 'big_chance_missed', 'penalty_scored'
    )


@admin.register(DefendingEvent)
class DefendingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('duel_aerial_won', 'tackle_won', 'interception_won', 'aerial_success',
                                                  'offensive_duel', 'defensive_duel')
    list_filter = BaseEventAdmin.list_filter + (
        'tackle_won', 'interception_won', 'duel_aerial_won', 'offensive_duel', 'defensive_duel', 'goal_own',
    )


@admin.register(GoalkeeperEvent)
class GoalkeeperEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )
    list_filter = BaseEventAdmin.list_filter + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )

    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'match',
            'team',
            'player'  # Changed from player__matchplayer
        ).prefetch_related(
            'player__matchplayer_set'  # Added prefetch_related for MatchPlayer
        )


@admin.register(PossessionEvent)
class PossessionEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('dispossessed', 'dribble_won',
                                                  'turnover')
    list_filter = BaseEventAdmin.list_filter + (
        'dispossessed', 'dribble_won', 'turnover'
    )


@admin.register(SummaryEvent)
class SummaryEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('card_type', 'sub_on', 'sub_off', 'foul_committed')
    list_filter = BaseEventAdmin.list_filter + \
        ('card_type',
         'sub_on',
         'sub_off',
         'foul_committed',
         'penalty_conceded',
         'penalty_won')

================
File: apps.py
================
from django.apps import AppConfig


class SbapiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sbapi'

================
File: tests.py
================
from django.test import TestCase

# Create your tests here.
