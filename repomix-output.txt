This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-10T22:32:45.656Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
backend/
  api/
    core/
      base.py
      imports.py
    migrations/
      0001_initial.py
    urls/
      competition.py
      match.py
      player.py
    views/
      competition/
        info.py
        matches.py
      match/
        info.py
        lineups.py
      player/
        match/
          defending.py
          goalkeeping.py
          passing.py
          possession.py
          shooting.py
          touches.py
    admin.py
    apps.py
    models.py
    serializers.py
    tests.py
  backend/
    asgi.py
    settings.py
    urls.py
    wsgi.py
  sbapi/
    management/
      commands/
        sm.py
    migrations/
      0001_initial.py
    models/
      events/
        __init__.py
        base.py
        defending.py
        goalkeeper.py
        passing.py
        possession.py
        shooting.py
        summary.py
      __init__.py
      competition.py
      formation.py
      match.py
      player.py
      team.py
    services/
      loaders/
        event_loader.py
        match_loader.py
      main/
        main.py
        test.py
        utils.py
      scripts/
        match_scraper.py
    v1/
      serializers/
        base/
          __init__.py
          common.py
          competition.py
          events.py
          match.py
        player_analytics/
          match_events/
            base.py
            passing.py
        stats/
          __init__.py
          player_stats.py
          team_stats.py
        __init__.py
        base.py
      services/
        events/
          __init__.py
          event_aggregator.py
        player_analytics/
          __init__.py
          base.py
          passing.py
        stats/
          __init__.py
          player_stats.py
          team_stats.py
        __init__.py
      views/
        base/
          __init__.py
          base.py
          competition.py
          events.py
          match.py
        player_analytics/
          match_events.py
          match.py
        stats/
          __init__.py
          player_stats.py
          team_stats.py
        __init__.py
      urls.py
      utils.py
    admin.py
    apps.py
    repomix-output.txt
    tests.py
  manage.py
  requirements.txt
frontend/
  public/
    index.html
    manifest.json
    robots.txt
  src/
    components/
      common/
        BaseLayout.js
        ErrorMessage1.js
        index.js
        LoadingSpinner1.js
        Modal.js
        Navbar.js
      competition/
        CompetitionOverview.js
      homepage/
        Home.js
      match/
        MatchDetails.js
        MatchHeader.js
        MatchLineups.js
        TeamLineup.js
        TeamLineupTable.js
      pitch/
        BasePitch.js
        constants.js
        GoalPost.js
        HalfVerticalPitch.js
        HeatSoccerPitch.js
        index.js
        SoccerPitch.js
        VerticalSoccerPitch.js
      player/
        features/
          defending/
            DefendingItemDetails.js
          passing/
            PassingItemDetails.js
          shooting/
            ShootingItemDetails.js
          summary/
            SummaryItemDetails.js
        PlayerMatchPerformance/
          components/
            statoverview/
              ShootingStatsOverview.js
              StatCard.js
              SummaryStatsOverview.js
            ItemDetails.js
            PlayerProfile.js
            StatNavigation.js
            StatOverview.js
            SubStatNavigation.js
            Visualization.js
          config/
            statConfig.js
            statTypes.js
          hooks/
            useStatData.js
          visualizations/
            index.js
            PlayerMatchShots.js
            PlayerMatchTouches.js
          PlayerMatchPerformance.js
    services/
      api.js
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    reportWebVitals.js
    setupTests.js
  .gitignore
  .prettierrc
  package.json
  README.md
  repomix-output.txt
  tailwind.config.js
.gitignore
README.md

================================================================
Repository Files
================================================================

================
File: backend/api/core/base.py
================
from rest_framework.views import APIView
from rest_framework.response import Response
import logging
import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)


class BaseStatsBombView(APIView):
    event_columns = [
        'id', 'index', 'period', 'timestamp', 'minute', 'second', 'type',
        'possession', 'possession_team', 'play_pattern', 'team', 'player',
        'position', 'location', 'duration', 'under_pressure', 'off_camera',
        'out', 'related_events', '50_50'
    ]

    def handle_error(self, error, message="An error occurred"):
        logger.error(f"{message}: {str(error)}")
        return Response({
            'error': str(error),
            'message': message
        }, status=500)

    def clean_dataframe(self, df):
        """Clean DataFrame for JSON serialization"""
        # Make a copy to avoid modifying the original
        df = df.copy()

        # First, handle all numeric columns
        numeric_cols = df.select_dtypes(include=[np.number]).columns
        for col in numeric_cols:
            df[col] = df[col].replace({
                np.nan: None,
                np.inf: None,
                -np.inf: None
            })

        # Handle all object/string columns
        object_cols = df.select_dtypes(include=['object']).columns
        for col in object_cols:
            df[col] = df[col].replace({np.nan: None})

        # Convert DataFrame to records
        records = df.to_dict(orient='records')

        # Final cleanup to ensure JSON serialization will work
        clean_records = []
        for record in records:
            clean_record = {}
            for key, value in record.items():
                if isinstance(value, np.integer):
                    clean_record[key] = int(value)
                elif isinstance(value, np.floating):
                    clean_record[key] = float(
                        value) if not np.isnan(value) else None
                elif isinstance(value, (np.ndarray, list)):
                    # Handle array-like values
                    if isinstance(value, np.ndarray):
                        value = value.tolist()
                    clean_record[key] = [
                        None if isinstance(x, (float, np.floating)) and np.isnan(x)
                        else x for x in value
                    ]
                else:
                    clean_record[key] = None if pd.isna(value) else value
            clean_records.append(clean_record)

        return clean_records

================
File: backend/api/core/imports.py
================
from api.core.base import BaseStatsBombView
from rest_framework.response import Response
from statsbombpy import sb
import pandas as pd
import numpy as np
import logging

logger = logging.getLogger(__name__)

# Common HTTP status codes
HTTP_404_NOT_FOUND = 404
HTTP_500_INTERNAL_SERVER_ERROR = 500

================
File: backend/api/migrations/0001_initial.py
================
# Generated by Django 5.1.2 on 2024-12-06 09:09

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='League',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('code', models.CharField(max_length=10, unique=True)),
                ('emblem', models.URLField(blank=True, null=True)),
            ],
        ),
        migrations.CreateModel(
            name='Player',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('nationality', models.CharField(max_length=100)),
            ],
        ),
        migrations.CreateModel(
            name='Team',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=100)),
                ('short_name', models.CharField(
                    blank=True, max_length=50, null=True)),
                ('crest', models.URLField()),
            ],
        ),
        migrations.CreateModel(
            name='TeamParticipation',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('position', models.IntegerField()),
                ('playedGames', models.IntegerField()),
                ('won', models.IntegerField()),
                ('draw', models.IntegerField()),
                ('lost', models.IntegerField()),
                ('points', models.IntegerField()),
                ('goalDifference', models.IntegerField()),
                ('league',
                 models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,
                                   related_name='participations',
                                   to='api.league')),
                ('team',
                 models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,
                                   related_name='participations',
                                   to='api.team')),
            ],
            options={
                'unique_together': {('team', 'league')},
            },
        ),
        migrations.CreateModel(
            name='Standings',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('season', models.CharField(max_length=100)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('league',
                 models.ForeignKey(on_delete=django.db.models.deletion.CASCADE,
                                   related_name='standings',
                                   to='api.league')),
                ('teams', models.ManyToManyField(
                    related_name='standings', to='api.teamparticipation')),
            ],
        ),
    ]

================
File: backend/api/urls/competition.py
================
# api/urls/competition.py
from django.urls import path
from ..views.competition.matches import CompetitionMatchesView
from ..views.competition.info import (
    CompetitionsView,
    SeasonsView,
    CompetitionInfoView,
)

urlpatterns = [
    path('competitions/',
         CompetitionsView.as_view(),
         name='competitions'),

    path('seasons/<int:competition_id>/',
         SeasonsView.as_view(),
         name='competition-seasons'),

    path('matches/<int:competition_id>/<int:season_id>/',
         CompetitionMatchesView.as_view(),
         name='competition-matches'),

    path('competition-info/<int:competition_id>/<int:season_id>/',
         CompetitionInfoView.as_view(),
         name='competition-info'),
]

================
File: backend/api/urls/match.py
================
# api/urls/match.py
from django.urls import path
from ..views.match.info import MatchInformationView
from ..views.match.lineups import MatchLineupsView

urlpatterns = [
    path('match-info/<int:match_id>/',
         MatchInformationView.as_view(),
         name='match-data'),

    path('match-lineups/<int:match_id>/',
         MatchLineupsView.as_view(),
         name='match-lineups'),
]


================
File: backend/sbapi/management/commands/sm.py
================
from django.core.management.base import BaseCommand
from sbapi.services.scripts.match_scraper import MatchScraper
from sbapi.services.main.main import getMatchUrls
import json
from pathlib import Path
import time
from datetime import datetime, timedelta
from selenium import webdriver


class Command(BaseCommand):
    help = 'Get match data and stores it in the database'
    BASE_URL = "https://1xbet.whoscored.com"

    def add_arguments(self, parser):
        # Original arguments remain the same
        parser.add_argument('-u', '--urls', nargs='+', type=str,
                            help='List of match URLs to scrape')
        parser.add_argument('-f', '--file', type=str,
                            help='JSON file with URLs')
        parser.add_argument('-d', '--delay', type=float, default=2,
                            help='Delay between scrapes in seconds (default: 2)')

        parser.add_argument('-l', '--league', type=str,
                            help='League to scrape (e.g., England-Premier-League)')
        parser.add_argument('-s', '--season', type=str,
                            help='Season to scrape (format: 2024/2025)')
        parser.add_argument('--preview', action='store_true',
                            help='Preview URLs without scraping')

    def format_time(self, seconds):
        return str(timedelta(seconds=int(seconds)))

    def get_league_urls(self, league: str, season: str):
        """Get URLs for all matches in a league season"""
        league_url = f"{self.BASE_URL}/Regions/252/Tournaments/2/{league}"

        driver = webdriver.Chrome()
        try:
            match_urls = getMatchUrls(
                comp_urls={league: league_url},
                competition=league,
                season=season
            )
            driver.quit()
            return match_urls
        except Exception as e:
            driver.quit()
            raise e

    def format_url(self, url_or_data):
        """Convert relative URLs to absolute URLs or extract URL from match data"""
        if isinstance(url_or_data, dict):
            relative_url = url_or_data.get('url', '')
        else:
            relative_url = url_or_data

        if relative_url.startswith('http'):
            return relative_url
        return f"{self.BASE_URL}{relative_url}"

    def save_urls(self, urls, filename):
        """Save URLs to a JSON file"""
        with open(filename, 'w') as f:
            json.dump(urls, f, indent=2)
        return filename

    def handle(self, *args, **options):
        start_time = time.time()
        urls = []

        # Handle league option
        if options.get('league'):
            if not options.get('season'):
                self.stderr.write(
                    "Season (-s) required when using league option")
                return

            try:
                self.stdout.write(
                    f"Getting matches for {options['league']} {options['season']}...")
                match_data = self.get_league_urls(
                    options['league'], options['season'])

                # Save league URLs for reference
                league_file = f"league_matches_{options['league']}_{options['season'].replace('/', '_')}.json"
                self.save_urls(match_data, league_file)
                self.stdout.write(f"\nFound {len(match_data)} matches")
                self.stdout.write(f"URLs saved to {league_file}")

                if options.get('preview'):
                    self.stdout.write("\nPreview mode - not scraping")
                    self.stdout.write(
                        "Review the JSON file and run again with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                confirm = input("\nProceed with scraping? [y/N]: ").lower()
                if confirm != 'y':
                    self.stdout.write("Aborted. You can run later with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                # Store full URLs from match data
                urls.extend(self.format_url(match) for match in match_data)

            except Exception as e:
                self.stderr.write(f"Error getting league matches: {str(e)}")
                return

        # Handle direct URLs
        if options.get('urls'):
            urls.extend(self.format_url(url) for url in options['urls'])

        # Handle file input
        if options.get('file'):
            try:
                with open(Path(options['file'])) as f:
                    file_data = json.load(f)
                    # Handle both URL lists and match data lists
                    if isinstance(file_data, list):
                        urls.extend(self.format_url(item)
                                    for item in file_data)
            except Exception as e:
                self.stderr.write(f"Error reading URLs file: {e}")
                return

        if not urls:
            self.stderr.write(
                "No URLs provided. Use -u/--urls, -f/--file, or -l/--league")
            return

        # Initialize counters
        total = len(urls)
        successful = failed = 0
        failed_urls = []

        # Progress header
        self.stdout.write(
            f"\nStarting scrape of {total} matches at {datetime.now().strftime('%H:%M:%S')}")
        self.stdout.write("-" * 50)

        # Process URLs
        for i, url in enumerate(urls, 1):
            loop_start = time.time()
            try:
                self.stdout.write(f"\nMatch {i}/{total}: {url}")
                scraper = MatchScraper()
                match_data = scraper.scrape_match(url)
                processed_data = scraper.process_match_data(match_data)

                successful += 1
                elapsed = time.time() - loop_start
                self.stdout.write(self.style.SUCCESS(
                    f"✓ Success - {len(processed_data['events'])} events "
                    f"({elapsed:.1f}s)"
                ))

            except Exception as e:
                failed += 1
                failed_urls.append(url)
                self.stdout.write(self.style.ERROR(f"✗ Failed: {str(e)}"))

            if i < total:  # Don't sleep after last URL
                time.sleep(options['delay'])

        # Final summary
        total_time = time.time() - start_time
        self.stdout.write("\n" + "=" * 50)
        self.stdout.write(self.style.SUCCESS(
            f"\nScraping completed in {self.format_time(total_time)}\n"
            f"✓ Successful: {successful}/{total}\n"
            f"✗ Failed: {failed}/{total}"
        ))

        # Save failed URLs if any
        if failed_urls:
            failed_file = f"failed_urls_{int(time.time())}.json"
            self.save_urls(failed_urls, failed_file)
            self.stdout.write(f"\nFailed URLs saved to {failed_file}")


"""
USAGE EXAMPLES:

# Get league matches with preview
python manage.py sm -l England-Premier-League -s 2024/2025 --preview

# Get and scrape league matches (with confirmation prompt)
python manage.py sm -l England-Premier-League -s 2024/2025

# Use previously saved league file
python manage.py sm -f league_matches_England-Premier-League_2024_2025.json

# Direct URLs and file still work as before
python manage.py sm -u http://url1 http://url2
python manage.py sm -f urls.json
python manage.py sm -u http://url1 -d 1.5
"""

================
File: backend/sbapi/models/events/base.py
================
from django.db import models


class Event(models.Model):
    """Base model for all match events, these fields are informative"""
    # Core identification
    # Django's auto-incrementing primary key
    id = models.AutoField(primary_key=True)
    # The original DataFrame id (2.755319e+09)
    source_id = models.BigIntegerField()
    # The original eventId that groups related actions (21, 22, etc)
    event_id = models.IntegerField()
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    player = models.ForeignKey(
        'sbapi.Player', null=True, on_delete=models.CASCADE)
    player_name = models.CharField(max_length=100, null=True)

    # Timing
    minute = models.IntegerField()  # Range: [0 to 102]
    second = models.FloatField(null=True)  # Range: [0.0 to 59.0]
    expanded_minute = models.IntegerField()  # Range: [0 to 108]
    # FirstHalf, SecondHalf, PenaltyShootout, FirstPeriodOfExtraTime, SecondPeriodOfExtraTime
    period = models.CharField(max_length=20)
    max_minute = models.IntegerField()  # [102]

    # Location
    x = models.FloatField()  # Range: [0.0 to 100]
    y = models.FloatField()  # Range: [0.0 to 100.0]
    end_x = models.FloatField(null=True)  # Range: [0.0 to 100.0]
    end_y = models.FloatField(null=True)  # Range: [0.0 to 100.0]

    # Did this event involve a touch?
    is_touch = models.BooleanField(default=False)
    touches = models.BooleanField(default=False)

    # Field position
    defensive_third = models.BooleanField(default=False)
    mid_third = models.BooleanField(default=False)
    final_third = models.BooleanField(default=False)

    # Type and outcome
    # Pass, Shot, etc. (see type in docs/)
    type = models.CharField(max_length=50)
    outcome_type = models.CharField(
        max_length=20, null=True)  # Successful, Unsuccessful

    # Related events/players
    # Changed to FloatField, Range: [63.0 to 924.0]
    related_event_id = models.FloatField(null=True)
    # Changed to FloatField, Range: [22079.0 to 494120.0]
    related_player_id = models.FloatField(null=True)

    # Match context
    h_a = models.CharField(max_length=1)  # 'h' or 'a'

    # OpenPlay, SetPiece, etc.
    situation = models.CharField(max_length=50, null=True)
    """Regular an attempt created from an open-play attack.
Set-piece  an attempt created where the ball starts from an indirect free-kick dead-ball situation.
Throw-in  an attempt created from a throw-in.
Direct free-kick  an attempt at goal directly from free-kick situation.
Direct corner  a goal scored directly from a corner by the corner-taker, or an attempt created from a corner situation.
Fast break  an attempt created after a team quickly turn defence into attack, winning the ball in their own half (counter-attack).
Penalty  The penalty attempt itself, any follow-up shot would be classed as a set-piece attempt. Passed penalties are also counted as penalty pattern of play"""

    # Additional data
    qualifiers = models.JSONField(default=list)
    satisfied_events_types = models.JSONField(default=list)

    class Meta:
        abstract = True
        indexes = [
            models.Index(fields=['match', 'minute']),
            models.Index(fields=['player', 'type']),
            models.Index(fields=['team', 'type']),
            models.Index(fields=['event_id']),
            # Meaningful for finding related actions
            # Index for the original DataFrame id
            models.Index(fields=['source_id']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['match', 'source_id'],
                name='%(app_label)s_%(class)s_unique_match_source'
            )
        ]

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: backend/sbapi/models/events/defending.py
================
from django.db import models
from .base import Event


class DefendingEvent(Event):
    """
    Model representing defensive actions in football/soccer matches.
    Inherits from base Event model.

    This model tracks various defensive actions including tackles, interceptions,
    clearances, aerial duels, and defensive errors.
    """

    # Core defensive actions
    is_tackle = models.BooleanField(
        default=False,
        help_text="Quick identifier for tackle events"
    )
    is_interception = models.BooleanField(
        default=False,
        help_text="Quick identifier for interception events. Occurs when a player reads and "
        "intercepts an opponent's pass by moving into the line of the intended pass"
    )
    is_clearance = models.BooleanField(
        default=False,
        help_text="Quick identifier for clearance events. Represents an action where "
        "a player attempts to get the ball away from a dangerous zone"
    )
    is_ball_recovery = models.BooleanField(
        default=False,
        help_text="Quick identifier for ball recovery events. Occurs when a player recovers "
        "the ball in a situation where neither team has possession"
    )

    # Aerial duels
    aerial_success = models.BooleanField(
        default=False,
        help_text="Indicates successful aerial duel"
    )
    duel_aerial_lost = models.BooleanField(
        default=False,
        help_text="Indicates lost aerial duel"
    )
    duel_aerial_won = models.BooleanField(
        default=False,
        help_text="Indicates won aerial duel"
    )

    # Block coordinates
    blocked_x = models.FloatField(
        null=True,
        help_text="X-coordinate of block location"
    )
    blocked_y = models.FloatField(
        null=True,
        help_text="Y-coordinate of block location"
    )

    # Clearance types
    clearance_effective = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was effective"
    )
    clearance_head = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made with the head"
    )
    clearance_off_the_line = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made off the goal line"
    )
    clearance_total = models.BooleanField(
        default=False,
        help_text="Total clearance indicator (purpose needs clarification)"
    )

    # Duels and challenges
    challenge_lost = models.BooleanField(
        default=False,
        help_text="Indicates when a player is dribbled past and fails to win the ball"
    )
    defensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in a defensive duel"
    )
    offensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in an offensive duel"
    )

    # Defensive errors
    error_leads_to_goal = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a goal"
    )
    error_leads_to_shot = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a shot"
    )
    goal_own = models.BooleanField(
        default=False,
        help_text="Indicates if an own goal was scored"
    )

    # Interception details
    interception_all = models.BooleanField(
        default=False,
        help_text="Indicates any type of interception"
    )
    interception_in_the_box = models.BooleanField(
        default=False,
        help_text="Indicates interception made inside the penalty box"
    )
    interception_won = models.BooleanField(
        default=False,
        help_text="Indicates successful interception"
    )

    # Block types
    outfielder_block = models.BooleanField(
        default=False,
        help_text="Indicates block made by an outfield player (for shots?)"
    )
    outfielder_blocked_pass = models.BooleanField(
        default=False,
        help_text="Indicates blocked pass by an outfield player. Similar to interception "
        "but with less reading of the pass"
    )
    six_yard_block = models.BooleanField(
        default=False,
        help_text="Indicates block made in the six-yard box"
    )

    # Tackle outcomes
    tackle_last_man = models.BooleanField(
        default=False,
        help_text="Indicates tackle made as the last defending player"
    )
    tackle_lost = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the ball goes to an opposition player"
    )
    tackle_won = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the tackler or teammate regains possession, "
        "or the ball goes safely out of play"
    )

    class Meta:
        db_table = 'sbapi_event_defending'
        verbose_name = 'Events - Defending'
        verbose_name_plural = 'Events - Defending'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['is_tackle']),
            models.Index(fields=['is_interception']),
            models.Index(fields=['is_clearance']),
            models.Index(fields=['aerial_success']),
        ]

================
File: backend/sbapi/models/events/goalkeeper.py
================
from django.db import models
from .base import Event


class GoalkeeperEvent(Event):
    """Goalkeeper-specific event details"""
    # Core actions
    is_collected = models.BooleanField(default=False)

    # Claims
    keeper_claim_high_lost = models.BooleanField(default=False)
    keeper_claim_high_won = models.BooleanField(default=False)
    keeper_claim_lost = models.BooleanField(default=False)
    keeper_claim_won = models.BooleanField(default=False)

    # Save types
    keeper_diving_save = models.BooleanField(default=False)
    keeper_missed = models.BooleanField(default=False)
    keeper_one_to_one_won = models.BooleanField(default=False)
    standing_save = models.BooleanField(default=False)
    save_feet = models.BooleanField(default=False)
    save_hands = models.BooleanField(default=False)

    # Save locations
    save_high_centre = models.BooleanField(default=False)
    save_high_left = models.BooleanField(default=False)
    save_high_right = models.BooleanField(default=False)
    save_low_centre = models.BooleanField(default=False)
    save_low_left = models.BooleanField(default=False)
    save_low_right = models.BooleanField(default=False)

    # Save zones
    save_obox = models.BooleanField(default=False)  # Outside box
    save_obp = models.BooleanField(default=False)   # Outside box proper
    save_penalty_area = models.BooleanField(default=False)
    save_six_yard_box = models.BooleanField(default=False)
    keeper_save_in_the_box = models.BooleanField(default=False)
    keeper_save_total = models.BooleanField(default=False)

    # Penalties
    keeper_penalty_saved = models.BooleanField(default=False)
    penalty_shootout_saved = models.BooleanField(default=False)
    penalty_shootout_saved_gk = models.BooleanField(default=False)
    penalty_shootout_conceded_gk = models.BooleanField(default=False)

    # Other actions
    keeper_smother = models.BooleanField(default=False)
    keeper_sweeper_lost = models.BooleanField(default=False)
    parried_danger = models.BooleanField(default=False)
    parried_safe = models.BooleanField(default=False)
    punches = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_goalkeeping'  # Specific table name
        verbose_name = 'Events - Goalkeeper'
        verbose_name_plural = 'Events - Goalkeeper'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['keeper_diving_save']),
            models.Index(fields=['keeper_save_total']),
            models.Index(fields=['keeper_penalty_saved']),
        ]

================
File: backend/sbapi/models/events/passing.py
================
from django.db import models
from .base import Event


class PassEvent(Event):
    """Pass-specific event details"""
    # Core pass attributes
    pass_accurate = models.BooleanField(default=False)
    pass_inaccurate = models.BooleanField(default=False)
    pass_accuracy = models.BooleanField(default=False)

    # Assist types
    assist = models.BooleanField(default=False)
    assist_corner = models.BooleanField(default=False)
    assist_cross = models.BooleanField(default=False)
    assist_freekick = models.BooleanField(default=False)
    assist_other = models.BooleanField(default=False)
    assist_throughball = models.BooleanField(default=False)
    assist_throwin = models.BooleanField(default=False)
    intentional_assist = models.BooleanField(default=False)

    # Key pass types
    key_pass_corner = models.BooleanField(default=False)
    key_pass_cross = models.BooleanField(default=False)
    key_pass_freekick = models.BooleanField(default=False)
    key_pass_long = models.BooleanField(default=False)
    key_pass_other = models.BooleanField(default=False)
    key_pass_short = models.BooleanField(default=False)
    key_pass_throughball = models.BooleanField(default=False)
    key_pass_throwin = models.BooleanField(default=False)
    pass_key = models.BooleanField(default=False)

    # Corner passes
    pass_corner = models.BooleanField(default=False)
    pass_corner_accurate = models.BooleanField(default=False)
    pass_corner_inaccurate = models.BooleanField(default=False)

    # Cross passes
    pass_cross_accurate = models.BooleanField(default=False)
    pass_cross_blocked_defensive = models.BooleanField(default=False)
    pass_cross_inaccurate = models.BooleanField(default=False)

    # Freekick passes
    pass_freekick = models.BooleanField(default=False)
    pass_freekick_accurate = models.BooleanField(default=False)
    pass_freekick_inaccurate = models.BooleanField(default=False)

    # Pass direction/zone
    pass_back = models.BooleanField(default=False)
    pass_back_zone_inaccurate = models.BooleanField(default=False)
    pass_forward = models.BooleanField(default=False)
    pass_forward_zone_accurate = models.BooleanField(default=False)
    pass_left = models.BooleanField(default=False)
    pass_right = models.BooleanField(default=False)

    # Pass types
    pass_chipped = models.BooleanField(default=False)
    pass_head = models.BooleanField(default=False)
    pass_left_foot = models.BooleanField(default=False)
    pass_right_foot = models.BooleanField(default=False)

    # Long/short passes
    pass_long_ball_accurate = models.BooleanField(default=False)
    pass_long_ball_inaccurate = models.BooleanField(default=False)
    short_pass_accurate = models.BooleanField(default=False)
    short_pass_inaccurate = models.BooleanField(default=False)

    # Through balls
    pass_through_ball_accurate = models.BooleanField(default=False)
    pass_through_ball_inaccurate = models.BooleanField(default=False)

    # Additional characteristics
    big_chance_created = models.BooleanField(default=False)
    successful_final_third_passes = models.BooleanField(default=False)
    throw_in = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_passing'  # Specific table name
        verbose_name = 'Events - Passing'
        verbose_name_plural = 'Events - Passing'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['pass_accurate']),
            models.Index(fields=['assist']),
            models.Index(fields=['pass_key']),
            models.Index(fields=['big_chance_created']),
        ]

================
File: backend/sbapi/models/events/possession.py
================
# sbapi/models/events/possession.py
from django.db import models
from .base import Event


class PossessionEvent(Event):
    """Possession-related event details"""
    # Set pieces
    corner_awarded = models.BooleanField(
        default=False)  # recorded as h/a for conceded/won

    # Ball control
    dispossessed = models.BooleanField(default=False)
    turnover = models.BooleanField(default=False)
    overrun = models.BooleanField(default=False)

    # Dribbling
    dribble_lastman = models.BooleanField(default=False)
    dribble_lost = models.BooleanField(default=False)
    dribble_won = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_possession'  # Specific table name
        verbose_name = 'Events - Possession'
        verbose_name_plural = 'Events - Possession'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['dribble_won']),
            models.Index(fields=['dispossessed']),
            models.Index(fields=['touches']),
        ]


# 
# Location of each pass
# End location of each pass
# Pass accuracy so all passes, (for this we need to use pass accurate and pass innac)then use accuract erand innacruate

# Type of pass, so this too:

# was it an assist
# was it a corner?
# was it a cross? most times when its a corner its a cross but not always lol
# what about:
# Assist freekick
# Assist other
# Assist throughball
# Assist throwin
# was it Intentional assist

# then for a # Passkey key pass was it a ?

# Key pass corner

# Key pass cross

# Key pass freekick

# Key pass long

# Key pass other

# Key pass short

# Key pass throughball

# Key pass throwin

# then chances created too (this mean key passes + assists), so for alter when trying to find the cahcne created find ti from events
# Note theres also BCC BUT THIS ALREADY CO MES TWITH THE DAT SO WE ODNT NEED TO FIND




# doing  it this way will help me aggregate it for a season, so aggreagte for amcth foir a player i wil show u this too

# then use this too i want to kmow every detaila but my passes
# Pass corner

# Pass corner accurate

# Pass corner inaccurate

# Pass cross accurate

# Pass cross blocked defensive

# Pass cross inaccurate

# Pass freekick

# Pass freekick accurate

# Pass freekick inaccurate

# Pass back

# Pass back zone inaccurate

# Pass forward

# Pass forward zone accurate

# Pass left

# Pass right

# Pass chipped

# Pass head

# Pass left foot

# Pass right foot

# Pass long ball accurate

# Pass long ball inaccurate

# Short pass accurate

# Short pass inaccurate

# Pass through ball accurate

# Pass through ball inaccurate

# Big chance created

# Successful final third passes

# Throw in

# i wanna be clear what im trying to do so you know,
# basically i havce api routes fior diffrent stats i ie match events, im staring with passing that needs upgradingf and pottnetially changing idk yuoull help
# the route return all passing events from a amtchn adn com, eptiotn good, firstly i want to be able to from ym front end (so perhaps i need an api rotue backend oidk0, see
# passinmg events for a speicifc player form trhat macth you get me
# alsoo,i currently have a playere macth stats rotue showingg stats from a specifi cmathc thats no problem but then, i feel liek its goo ig ic a=could get mor edtail fo the stuff 
# i aggregate, for example asists in match a playe rmay have 3, but then i want to see what was true, ie was he asis tyf rom a corner or fk or sdomehting
# or even a regualr passes a paleyr had 90 passes, i want to get the detail of each pass as well or know i mean we have all the dat in one palc eits kind of jus tfil;t
# fi;lteroig it in the righ wya or somethign , liek a players passes all them then the type and then aggregated (and then knowing what those aggregate stuff are clealryl)
# liek i dont jsu wnan aknow he had 3 chances cretaed or 5 bgi chnces created wold be ncie to know if it was a coner ans stuff idk if i m vlear o hwo this woulkd work
# caus e i ahevb an matches/1282309/events/passing and matches/stats/players/1282309 showing detail too 

#  i wil lalso calculate further stats based on ther attribuyte s latesr, the reason i want match level agrgegation and with detial is so that my
# player season is easy to sdo ie cna use match possibley but for all amcthes idk, liek perhaps isot sjust getting the ful row of passing event btu perhas theres abter way, hope ive been clear and lmk
# if u have any qs, i am goonn share my code


# on my endx and start x coroidnates, like i want to do stuff liek finding out progressive passes, later tho

================
File: backend/sbapi/models/events/shooting.py
================
from django.db import models
from .base import Event


class ShootingEvent(Event):
    """Shot-specific event details"""
    # Big chances
    big_chance_missed = models.BooleanField(default=False)
    big_chance_scored = models.BooleanField(default=False)

    # Close misses
    close_miss_high = models.BooleanField(default=False)
    close_miss_high_left = models.BooleanField(default=False)
    close_miss_high_right = models.BooleanField(default=False)
    close_miss_left = models.BooleanField(default=False)
    close_miss_right = models.BooleanField(default=False)

    # Goals
    is_goal = models.BooleanField(default=False)
    goal_counter = models.BooleanField(default=False)
    goal_head = models.BooleanField(default=False)
    goal_left_foot = models.BooleanField(default=False)
    goal_right_foot = models.BooleanField(default=False)
    goal_normal = models.BooleanField(default=False)
    goal_open_play = models.BooleanField(default=False)
    goal_set_piece = models.BooleanField(default=False)

    # Goal location
    goal_obox = models.BooleanField(default=False)
    goal_obp = models.BooleanField(default=False)
    goal_penalty_area = models.BooleanField(default=False)
    goal_six_yard_box = models.BooleanField(default=False)
    goal_mouth_y = models.FloatField(null=True)  # Range: 7.1 to 93.4
    goal_mouth_z = models.FloatField(null=True)  # Range: 1.3 to 86.1

    # Shot flags
    is_shot = models.BooleanField(default=False)
    shot_blocked = models.BooleanField(default=False)
    shot_counter = models.BooleanField(default=False)
    shot_direct_corner = models.BooleanField(default=False)
    shot_on_post = models.BooleanField(default=False)
    shot_on_target = models.BooleanField(default=False)
    shot_off_target = models.BooleanField(default=False)
    shot_off_target_inside_box = models.BooleanField(default=False)
    shots_total = models.BooleanField(default=False)

    # Shot body part
    shot_body_type = models.CharField(max_length=20, null=True)
    shot_head = models.BooleanField(default=False)
    shot_left_foot = models.BooleanField(default=False)
    shot_right_foot = models.BooleanField(default=False)

    # Shot location
    shot_obox_total = models.BooleanField(default=False)
    shot_obp = models.BooleanField(default=False)
    shot_penalty_area = models.BooleanField(default=False)
    shot_six_yard_box = models.BooleanField(default=False)

    # Shot type
    shot_open_play = models.BooleanField(default=False)
    shot_set_piece = models.BooleanField(default=False)

    # Penalties (note diff in open play vs shootouts)
    penalty_missed = models.BooleanField(default=False)
    penalty_scored = models.BooleanField(default=False)
    penalty_shootout_missed_off_target = models.BooleanField(default=False)
    penalty_shootout_scored = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_shooting'  # Specific table name
        verbose_name = 'Events - Shooting'
        verbose_name_plural = 'Events - Shooting '
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['is_goal']),
            models.Index(fields=['is_shot']),
            models.Index(fields=['shot_on_target']),
            models.Index(fields=['big_chance_scored']),
        ]

================
File: backend/sbapi/models/events/summary.py
================
from django.db import models
from .base import Event


class SummaryEvent(Event):
    """Summary events such as fouls, cards and substitutions"""
    # Cards
    # Yellow, Red, SecondYellow
    card_type = models.CharField(max_length=20, null=True)
    yellow_card = models.BooleanField(default=False)
    red_card = models.BooleanField(default=False)
    second_yellow = models.BooleanField(default=False)
    void_yellow_card = models.BooleanField(default=False)

    # Fouls
    foul_committed = models.BooleanField(
        default=False)  # player that gave foul away
    foul_given = models.BooleanField(
        default=False)  # player/team foul was given to

    # Penalty
    penalty_conceded = models.BooleanField(default=False)
    penalty_won = models.BooleanField(default=False)

    # Offsides
    # An event attributed to the player deemed to be in an offside position
    # when a free kick is awarded
    offside_given = models.BooleanField(default=False)
    # The deepest player in the defensive line when an offside has been given
    offside_provoked = models.BooleanField(default=False)

    # Substitutions
    sub_on = models.BooleanField(default=False)  # Renamed from is_sub_on
    sub_off = models.BooleanField(default=False)  # Renamed from is_sub_off

    class Meta:
        db_table = 'sbapi_event_summary'  # Specific table name
        verbose_name = 'Events - Summary'
        verbose_name_plural = 'Events - Summary'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['card_type']),
            models.Index(fields=['foul_committed']),
            models.Index(fields=['penalty_conceded', 'penalty_won']),
            models.Index(fields=['sub_on', 'sub_off']),
        ]

================
File: backend/sbapi/models/__init__.py
================
from .competition import Competition, Season
from .team import Team
from .match import Match
from .formation import Formation
from .player import Player, MatchPlayer
from .events import (
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)

__all__ = [
    'Competition',
    'Season',
    'Team',
    'Match',
    'Formation',
    'Player',
    'MatchPlayer',
    'PassEvent',
    'ShootingEvent',
    'DefendingEvent',
    'GoalkeeperEvent',
    'PossessionEvent',
    'SummaryEvent'
]

================
File: backend/sbapi/models/competition.py
================
from django.db import models


class Competition(models.Model):
    """Core competition/league information"""
    competition_id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('name', 'country')
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]

    def __str__(self):
        return f"{self.name} ({self.country})"


class Season(models.Model):
    """Season information for a competition"""
    season_id = models.AutoField(primary_key=True)
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE)
    name = models.CharField(max_length=20)  # e.g., "2023/24"
    # start_date = models.DateField()
    # end_date = models.DateField()
    is_current = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('competition', 'name')
        indexes = [
            models.Index(fields=['is_current']),
        ]

    def __str__(self):
        return f"{self.competition.name} {self.name}"

================
File: backend/sbapi/models/formation.py
================
from django.db import models


class Formation(models.Model):
    """Store formation information for a team in a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    formation_name = models.CharField(max_length=10)  # e.g. "4231"
    captain_player_id = models.IntegerField()
    start_minute = models.IntegerField()
    end_minute = models.IntegerField()

    # Store player information
    player_ids = models.JSONField(default=list)
    jersey_numbers = models.JSONField(default=list)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['formation_name']),
            models.Index(fields=['captain_player_id']),
            models.Index(fields=['match', 'team']),
        ]
        # Add uniqueness constraint for formations
        unique_together = ('match', 'team', 'start_minute', 'end_minute')
        verbose_name = 'Match Formation'
        verbose_name_plural = 'Match Formations'

    def __str__(self):
        """
        Provides a detailed string representation of the Formation instance.
        """
        match_date = self.match.start_datetime.date()

        # Show the formation team first, then vs their opponent
        if self.team == self.match.home_team:
            opponent = self.match.away_team.name
        else:
            opponent = self.match.home_team.name

        return f"{self.team.name} formation ({self.formation_name}) vs {opponent} ({match_date})"

================
File: backend/sbapi/models/match.py
================
from django.db import models
from django.utils import timezone


class Match(models.Model):
    match_id = models.IntegerField(primary_key=True)
    season = models.ForeignKey('sbapi.Season', on_delete=models.CASCADE)

    # Date/Time fields
    start_datetime = models.DateTimeField()
    venue = models.CharField(max_length=200)
    attendance = models.IntegerField(null=True)

    # Referee information
    referee_id = models.IntegerField(null=True)
    referee_name = models.CharField(max_length=100, null=True)

    # Team relationships
    home_team = models.ForeignKey(
        'sbapi.Team', related_name='home_matches', on_delete=models.CASCADE)
    away_team = models.ForeignKey(
        'sbapi.Team', related_name='away_matches', on_delete=models.CASCADE)

    # Manager information (moved from MatchTeamStats)
    home_manager_name = models.CharField(max_length=100, null=True)
    away_manager_name = models.CharField(max_length=100, null=True)

    # Team average age (moved from MatchTeamStats)
    home_team_average_age = models.FloatField(null=True)
    away_team_average_age = models.FloatField(null=True)

    # Scores
    # score = models.CharField(max_length=10)
    home_score_ht = models.IntegerField()
    away_score_ht = models.IntegerField()
    home_score_ft = models.IntegerField()
    away_score_ft = models.IntegerField()
    home_score_et = models.IntegerField(null=True)
    away_score_et = models.IntegerField(null=True)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['start_datetime']),
            models.Index(fields=['home_team']),
            models.Index(fields=['away_team']),
            models.Index(fields=['referee_id']),
            models.Index(fields=['season']),
        ]
        verbose_name = 'Match'
        verbose_name_plural = 'Matches'

    @property
    def competition(self):
        return self.season.competition

    @property
    def score(self):
        return f"{self.home_score_ft} : {self.away_score_ft}"

    def __str__(self):
        return f"{self.home_team} vs {self.away_team} ({self.start_datetime.date()})"

================
File: backend/sbapi/models/player.py
================
from django.db import models


class Player(models.Model):
    """Store player information"""
    player_id = models.IntegerField(primary_key=True)  # Changed to primary_key
    name = models.CharField(max_length=100)
    height = models.IntegerField(null=True)
    weight = models.IntegerField(null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
        ]

    def __str__(self):
        return self.name


class MatchPlayer(models.Model):
    """Store player information specific to a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    player = models.ForeignKey('sbapi.Player', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)

    # Match-specific info
    shirt_no = models.IntegerField()
    position = models.CharField(max_length=20)  # e.g. 'GK'
    is_first_eleven = models.BooleanField()
    is_man_of_match = models.BooleanField(default=False)
    age = models.IntegerField()
    height = models.IntegerField(null=True)  # in cm
    weight = models.IntegerField(null=True)  # in kg

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('match', 'player', 'team')
        indexes = [
            models.Index(fields=['position']),
            models.Index(fields=['match', 'team']),
            models.Index(fields=['is_first_eleven']),
        ]
        verbose_name = 'Match - Player Information'
        verbose_name_plural = 'Matches - Player Information'

    def __str__(self):
        return f"{self.player.name} ({self.team.name}) - Match {self.match.match_id}"

    @property
    def match_date(self):
        return self.match.start_datetime.date()

================
File: backend/sbapi/models/team.py
================
from django.db import models


class Team(models.Model):
    """Team model representing a football team"""
    team_id = models.IntegerField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]
        verbose_name = 'Team'
        verbose_name_plural = 'Teams'

    def __str__(self):
        return f"{self.name} ({self.country})"

================
File: backend/sbapi/services/loaders/event_loader.py
================
from django.db import transaction
import pandas as pd
import logging

from ...models.events import (
    PassEvent, ShootingEvent, DefendingEvent,
    GoalkeeperEvent, PossessionEvent, SummaryEvent
)
from ...models import Player

logger = logging.getLogger(__name__)


def load_match_events(match, events_df):
    """Loads all events for a match"""
    with transaction.atomic():
        for _, event in events_df.iterrows():
            try:
                # Skip 'Start' events
                event_type = str(event.get('type', '')).strip()
                if event_type == 'Start':
                    logger.info("Skipping 'Start' event")
                    continue

                # Get player if exists - safer conversion
                player = None
                if not pd.isna(event.get('playerId')):
                    try:
                        player = Player.objects.get(
                            player_id=int(float(event['playerId'])))
                    except (ValueError, Player.DoesNotExist):
                        logger.warning(
                            f"Player not found or invalid ID: {event['playerId']}")

                # Get team - with safety check
                team = match.home_team if str(
                    event.get('h_a', '')).lower() == 'h' else match.away_team

                # Base event data with safer gets
                base_event_data = {
                    'source_id': int(float(event.get('id', 0))),
                    'event_id': int(float(event.get('eventId', 0))),
                    'match': match,
                    'team': team,
                    'player': player,
                    'player_name': event.get('playerName') if not pd.isna(event.get('playerName')) else None,
                    'minute': event.get('minute'),
                    'second': float(event.get('second', 0.0)),
                    'expanded_minute': event.get('expandedMinute'),
                    'period': event.get('period'),
                    'max_minute': event.get('maxMinute'),
                    'x': event.get('x'),
                    'y': event.get('y'),
                    'touches': event.get('touches', False),
                    'is_touch': event.get('isTouch', False),
                    'end_x': event.get('endX') if not pd.isna(event.get('endX')) else None,
                    'end_y': event.get('endY') if not pd.isna(event.get('endY')) else None,
                    'defensive_third': bool(event.get('defensiveThird', False)),
                    'mid_third': bool(event.get('midThird', False)),
                    'final_third': bool(event.get('finalThird', False)),
                    'type': str(event.get('type', '')),
                    'outcome_type': event.get('outcomeType') if not pd.isna(event.get('outcomeType')) else None,
                    'related_event_id': event.get('relatedEventId') if not pd.isna(event.get('relatedEventId')) else None,
                    'related_player_id': event.get('relatedPlayerId') if not pd.isna(event.get('relatedPlayerId')) else None,
                    'h_a': str(event.get('h_a', '')),
                    'situation': str(event.get('situation')).strip() if pd.notna(event.get('situation')) else None,
                    'qualifiers': event.get('qualifiers').tolist() if hasattr(event.get('qualifiers'), 'tolist') else event.get('qualifiers', []),
                    'satisfied_events_types': event.get('satisfiedEventsTypes').tolist() if hasattr(event.get('satisfiedEventsTypes'), 'tolist') else event.get('satisfiedEventsTypes', [])
                }

                # Route to appropriate event handler
                try:
                    event_type = event.get('type', '')

                    # Pass events
                    if event_type == 'Pass':
                        _update_or_create_pass_event(event, base_event_data)

                    # Defending events
                    elif event_type in ['Tackle', 'Interception', 'Clearance', 'BallRecovery',
                                        'Aerial', 'Challenge', 'Error', 'BlockedPass'] or \
                            event.get('goalOwn', False) or \
                            event.get('sixYardBlock', False) or \
                            event.get('outfielderBlock', False):
                        _update_or_create_defending_event(
                            event, base_event_data)

                    # Goalkeeper events
                    elif event_type in ['Save', 'Smother', 'Punch', 'PenaltyFaced', 'CrossNotClaimed',
                                        'KeeperSweeper', 'KeeperPickup', 'Claim'] or \
                            any(event.get(f'keeper_{x}', False) for x in ['save', 'claim', 'punch']):
                        _update_or_create_goalkeeper_event(
                            event, base_event_data)

                    # Shooting events
                    elif event_type in ['Goal', 'Shot', 'SavedShot', 'ChanceMissed', 'MissedShots'] or event.get('isShot', False):
                        _update_or_create_shooting_event(
                            event, base_event_data)

                    # Possession events
                    elif event_type in ['BallTouch', 'TakeOn', 'Dispossessed', 'ShieldBallOpp']:
                        _update_or_create_possession_event(
                            event, base_event_data)

                    # Summary/other events
                    elif event_type in ['Card', 'SubstitutionOn', 'SubstitutionOff', 'Start', 'Foul', 'GoodSkill',
                                        'OffsideProvoked', 'OffsideGiven', 'OffsidePass', 'FormationSet',
                                        'FormationChange', 'CornerAwarded', 'End']:
                        _update_or_create_summary_event(event, base_event_data)

                    else:
                        logger.warning(f"Unhandled event type: {event_type}")

                except Exception as e:
                    logger.error(
                        f"Error processing event type {event_type}: {str(e)}")
                    continue

            except Exception as e:
                logger.error(
                    f"Error processing event {event.get('id')}: {str(e)}")
                continue


def _update_or_create_pass_event(event, base_data):
    """Updates or creates a passing event"""
    try:
        pass_data = {
            # Core pass attributes
            'pass_accurate': event.get('passAccurate', False),
            'pass_inaccurate': event.get('passInaccurate', False),
            'pass_accuracy': event.get('passAccuracy', False),

            # Assist types
            'assist': event.get('assist', False),
            'assist_corner': event.get('assistCorner', False),
            'assist_cross': event.get('assistCross', False),
            'assist_freekick': event.get('assistFreekick', False),
            'assist_other': event.get('assistOther', False),
            'assist_throughball': event.get('assistThroughball', False),
            'assist_throwin': event.get('assistThrowin', False),
            'intentional_assist': event.get('intentionalAssist', False),

            # Key pass types
            'key_pass_corner': event.get('keyPassCorner', False),
            'key_pass_cross': event.get('keyPassCross', False),
            'key_pass_freekick': event.get('keyPassFreekick', False),
            'key_pass_long': event.get('keyPassLong', False),
            'key_pass_other': event.get('keyPassOther', False),
            'key_pass_short': event.get('keyPassShort', False),
            'key_pass_throughball': event.get('keyPassThroughball', False),
            'key_pass_throwin': event.get('keyPassThrowin', False),
            'pass_key': event.get('passKey', False),

            # Corner passes
            'pass_corner': event.get('passCorner', False),
            'pass_corner_accurate': event.get('passCornerAccurate', False),
            'pass_corner_inaccurate': event.get('passCornerInaccurate', False),

            # Cross passes
            'pass_cross_accurate': event.get('passCrossAccurate', False),
            'pass_cross_blocked_defensive': event.get('passCrossBlockedDefensive', False),
            'pass_cross_inaccurate': event.get('passCrossInaccurate', False),

            # Freekick passes
            'pass_freekick': event.get('passFreekick', False),
            'pass_freekick_accurate': event.get('passFreekickAccurate', False),
            'pass_freekick_inaccurate': event.get('passFreekickInaccurate', False),

            # Direction/zone
            'pass_back': event.get('passBack', False),
            'pass_back_zone_inaccurate': event.get('passBackZoneInaccurate', False),
            'pass_forward': event.get('passForward', False),
            'pass_forward_zone_accurate': event.get('passForwardZoneAccurate', False),
            'pass_left': event.get('passLeft', False),
            'pass_right': event.get('passRight', False),

            # Pass types
            'pass_chipped': event.get('passChipped', False),
            'pass_head': event.get('passHead', False),
            'pass_left_foot': event.get('passLeftFoot', False),
            'pass_right_foot': event.get('passRightFoot', False),

            # Long/short passes
            'pass_long_ball_accurate': event.get('passLongBallAccurate', False),
            'pass_long_ball_inaccurate': event.get('passLongBallInaccurate', False),
            'short_pass_accurate': event.get('shortPassAccurate', False),
            'short_pass_inaccurate': event.get('shortPassInaccurate', False),

            # Through balls
            'pass_through_ball_accurate': event.get('passThroughBallAccurate', False),
            'pass_through_ball_inaccurate': event.get('passThroughBallInaccurate', False),

            # Additional characteristics
            'big_chance_created': event.get('bigChanceCreated', False),
            'successful_final_third_passes': event.get('successfulFinalThirdPasses', False),
            'throw_in': event.get('throwIn', False),
        }

        PassEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **pass_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating pass event: {str(e)}")
        raise


def _update_or_create_defending_event(event, base_data):
    """Updates or creates a defending event"""
    try:
        defending_data = {
            # Core defensive actions - determined by event type
            'is_tackle': event['type'] == 'Tackle',
            'is_interception': event['type'] == 'Interception',
            'is_clearance': event['type'] == 'Clearance',
            'is_ball_recovery': event['type'] == 'BallRecovery',

            # Aerial duels
            'aerial_success': event.get('aerialSuccess', False),
            'duel_aerial_lost': event.get('duelAerialLost', False),
            'duel_aerial_won': event.get('duelAerialWon', False),

            # Block details
            'blocked_x': event['blockedX'] if not pd.isna(event.get('blockedX')) else None,
            'blocked_y': event['blockedY'] if not pd.isna(event.get('blockedY')) else None,

            # Clearances
            'clearance_effective': event.get('clearanceEffective', False),
            'clearance_head': event.get('clearanceHead', False),
            'clearance_off_the_line': event.get('clearanceOffTheLine', False),
            'clearance_total': event.get('clearanceTotal', False),

            # Different types of duels
            'challenge_lost': event.get('challengeLost', False),
            'defensive_duel': event.get('defensiveDuel', False),
            'offensive_duel': event.get('offensiveDuel', False),

            # Defensive errors
            'error_leads_to_goal': event.get('errorLeadsToGoal', False),
            'error_leads_to_shot': event.get('errorLeadsToShot', False),
            'goal_own': event.get('goalOwn', False),

            # Interceptions
            'interception_all': event.get('interceptionAll', False),
            'interception_in_the_box': event.get('interceptionIntheBox', False),
            'interception_won': event.get('interceptionWon', False),

            # Blocks
            'outfielder_block': event.get('outfielderBlock', False),
            'outfielder_blocked_pass': event.get('outfielderBlockedPass', False),
            'six_yard_block': event.get('sixYardBlock', False),

            # Tackles
            'tackle_last_man': event.get('tackleLastMan', False),
            'tackle_lost': event.get('tackleLost', False),
            'tackle_won': event.get('tackleWon', False),

        }

        DefendingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **defending_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating defending event: {str(e)}")
        raise


def _update_or_create_shooting_event(event, base_data):
    try:
        shooting_data = {
            # Big chances
            'big_chance_missed': event.get('bigChanceMissed', False),
            'big_chance_scored': event.get('bigChanceScored', False),

            # Close misses
            'close_miss_high': event.get('closeMissHigh', False),
            'close_miss_high_left': event.get('closeMissHighLeft', False),
            'close_miss_high_right': event.get('closeMissHighRight', False),
            'close_miss_left': event.get('closeMissLeft', False),
            'close_miss_right': event.get('closeMissRight', False),

            # Goals
            'is_goal': event.get('isGoal', False),
            'goal_counter': event.get('goalCounter', False),
            'goal_head': event.get('goalHead', False),
            'goal_left_foot': event.get('goalLeftFoot', False),
            'goal_right_foot': event.get('goalRightFoot', False),
            'goal_normal': event.get('goalNormal', False),
            'goal_open_play': event.get('goalOpenPlay', False),
            'goal_set_piece': event.get('goalSetPiece', False),

            # Goal location
            'goal_obox': event.get('goalObox', False),
            'goal_obp': event.get('goalObp', False),
            'goal_penalty_area': event.get('goalPenaltyArea', False),
            'goal_six_yard_box': event.get('goalSixYardBox', False),
            'goal_mouth_y': event['goalMouthY'] if not pd.isna(event.get('goalMouthY')) else None,
            'goal_mouth_z': event['goalMouthZ'] if not pd.isna(event.get('goalMouthZ')) else None,

            # Shot flags
            'is_shot': event.get('isShot', False),
            'shot_blocked': event.get('shotBlocked', False),
            'shot_counter': event.get('shotCounter', False),
            'shot_direct_corner': event.get('shotDirectCorner', False),
            'shot_on_post': event.get('shotOnPost', False),
            'shot_on_target': event.get('shotOnTarget', False),
            'shot_off_target': event.get('shotOffTarget', False),
            'shot_off_target_inside_box': event.get('shotOffTargetInsideBox', False),
            'shots_total': event.get('shotsTotal', False),

            # Shot body part
            'shot_body_type': event['shotBodyType'] if not pd.isna(event.get('shotBodyType')) else None,
            'shot_head': event.get('shotHead', False),
            'shot_left_foot': event.get('shotLeftFoot', False),
            'shot_right_foot': event.get('shotRightFoot', False),

            # Shot location
            'shot_obox_total': event.get('shotOboxTotal', False),
            'shot_obp': event.get('shotObp', False),
            'shot_penalty_area': event.get('shotPenaltyArea', False),
            'shot_six_yard_box': event.get('shotSixYardBox', False),

            # Shot type
            'shot_open_play': event.get('shotOpenPlay', False),
            'shot_set_piece': event.get('shotSetPiece', False),

            # Penalties
            'penalty_missed': event.get('penaltyMissed', False),
            'penalty_scored': event.get('penaltyScored', False),
            'penalty_shootout_missed_off_target': event.get('penaltyShootoutMissedOffTarget', False),
            'penalty_shootout_scored': event.get('penaltyShootoutScored', False),
        }

        ShootingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **shooting_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating shooting event: {str(e)}")
        raise


def _update_or_create_goalkeeper_event(event, base_data):
    try:
        """Creates a goalkeeper event with all keeper-specific fields"""
        goalkeeper_data = {
            # Core actions
            'is_collected': event.get('collected', False),

            # Claims
            'keeper_claim_high_lost': event.get('keeperClaimHighLost', False),
            'keeper_claim_high_won': event.get('keeperClaimHighWon', False),
            'keeper_claim_lost': event.get('keeperClaimLost', False),
            'keeper_claim_won': event.get('keeperClaimWon', False),

            # Save types
            'keeper_diving_save': event.get('keeperDivingSave', False),
            # failed to make a save on a penalty
            'keeper_missed': event.get('keeperMissed', False),
            'keeper_one_to_one_won': event.get('keeperOneToOneWon', False),
            'standing_save': event.get('standingSave', False),
            'save_feet': event.get('saveFeet', False),
            'save_hands': event.get('saveHands', False),

            # Save locations
            'save_high_centre': event.get('saveHighCentre', False),
            'save_high_left': event.get('saveHighLeft', False),
            'save_high_right': event.get('saveHighRight', False),
            'save_low_centre': event.get('saveLowCentre', False),
            'save_low_left': event.get('saveLowLeft', False),
            'save_low_right': event.get('saveLowRight', False),

            # Save zones
            'save_obox': event.get('saveObox', False),
            'save_obp': event.get('saveObp', False),  # save outside the box?
            'save_penalty_area': event.get('savePenaltyArea', False),
            'save_six_yard_box': event.get('saveSixYardBox', False),
            'keeper_save_in_the_box': event.get('keeperSaveInTheBox', False),
            'keeper_save_total': event.get('keeperSaveTotal', False),

            # Penalties
            'keeper_penalty_saved': event.get('keeperPenaltySaved', False),
            'penalty_shootout_saved': event.get('penaltyShootoutSaved', False),
            'penalty_shootout_saved_gk': event.get('penaltyShootoutSavedGK', False),
            'penalty_shootout_conceded_gk': event.get('penaltyShootoutConcededGK', False),

            # Other actions
            'keeper_smother': event.get('keeperSmother', False),
            'keeper_sweeper_lost': event.get('keeperSweeperLost', False),
            'parried_danger': event.get('parriedDanger', False),
            'parried_safe': event.get('parriedSafe', False),
            'punches': event.get('punches', False),
        }

        GoalkeeperEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **goalkeeper_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating goalkeeper event: {str(e)}")
        raise


def _update_or_create_possession_event(event, base_data):

    try:
        """Creates a possession event with all possession-specific fields"""
        possession_data = {
            # Set pieces
            'corner_awarded': event.get('cornerAwarded', False),

            # Ball control
            'dispossessed': event.get('dispossessed', False),
            'turnover': event.get('turnover', False),
            'overrun': event.get('overrun', False),

            # Dribbling
            'dribble_lastman': event.get('dribbleLastman', False),
            'dribble_lost': event.get('dribbleLost', False),
            'dribble_won': event.get('dribbleWon', False),
        }

        PossessionEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **possession_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating possession event: {str(e)}")
        raise


def _update_or_create_summary_event(event, base_data):

    try:

        """Creates a summary event with all summary-specific fields"""
        summary_data = {
            # Cards
            'card_type': event['cardType'] if not pd.isna(event.get('cardType')) and event['cardType'] != 'False' else None,
            'yellow_card': event.get('yellowCard', False),
            'red_card': event.get('redCard', False),
            'second_yellow': event.get('secondYellow', False),
            'void_yellow_card': event.get('voidYellowCard', False),

            # Substitutions
            'sub_on': event.get('subOn', False),
            'sub_off': event.get('subOff', False),

            # Fouls
            'foul_committed': event.get('foulCommitted', False),
            'foul_given': event.get('foulGiven', False),
            'penalty_conceded': event.get('penaltyConceded', False),
            'penalty_won': event.get('penaltyWon', False),

            # Offsides
            'offside_given': event.get('offsideGiven', False),
            'offside_provoked': event.get('offsideProvoked', False),
        }

        SummaryEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **summary_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating summary event: {str(e)}")
        raise

================
File: backend/sbapi/services/loaders/match_loader.py
================
from typing import Dict, Any, Tuple, Optional
import logging
from datetime import datetime
from dataclasses import dataclass
from django.db import transaction
from django.core.exceptions import ValidationError
from django.db.models import Model
from django.utils import timezone
import pytz

from ...models import (
    Competition,
    Season,
    Team,
    Match,
    Formation,
    Player,
    MatchPlayer
)

# Initialise
uk_tz = pytz.timezone('Europe/London')
logger = logging.getLogger(__name__)


@dataclass
class ScoreData:
    """Structured container for match score data"""
    home: int
    away: int

    @classmethod
    def from_string(cls, score_str: str) -> 'ScoreData':
        """Parse score string in format '0:0' into ScoreData object"""
        try:
            home, away = map(int, score_str.split(':'))
            return cls(home=home, away=away)
        except (ValueError, AttributeError) as e:
            raise ValidationError(f"Invalid score format: {score_str}") from e


class MatchDataValidator:
    """Handles validation of match data"""

    REQUIRED_MATCH_FIELDS = {
        'matchId', 'league', 'region', 'season', 'home', 'away',
        'startDate', 'startTime', 'venueName', 'score', 'htScore', 'ftScore'
    }

    REQUIRED_TEAM_FIELDS = {
        'teamId', 'name', 'averageAge', 'managerName',
        'countryName', 'scores', 'stats', 'formations', 'players'
    }

    @classmethod
    def validate(cls, data: Dict[str, Any]) -> None:
        """Validate all match data"""
        cls._validate_required_fields(data, cls.REQUIRED_MATCH_FIELDS, "match")
        cls._validate_scores(data)
        cls._validate_teams(data)

    @staticmethod
    def _validate_required_fields(
            data: Dict[str, Any], required_fields: set, context: str) -> None:
        """Check for presence of required fields"""
        missing = required_fields - data.keys()
        if missing:
            raise ValidationError(
                f"Missing required {context} fields: {', '.join(sorted(missing))}")

    @classmethod
    def _validate_teams(cls, data: Dict[str, Any]) -> None:
        """Validate both teams' data"""
        for venue in ['home', 'away']:
            team_data = data.get(venue, {})
            if not isinstance(team_data, dict):
                raise ValidationError(f"Invalid {venue} team data format")
            cls._validate_required_fields(
                team_data, cls.REQUIRED_TEAM_FIELDS, f"{venue} team")

    @staticmethod
    def _validate_scores(data: Dict[str, Any]) -> None:
        """Validate all score fields"""
        for field in ['score', 'htScore', 'ftScore']:
            # Will raise ValidationError if invalid
            ScoreData.from_string(data[field])


class MatchLoader:
    """Handles loading match data into the database"""

    def __init__(self):
        self.validator = MatchDataValidator()

    @transaction.atomic
    def load_match(self, match_data: Dict[str, Any]) -> Model:
        """
        Load match data into database with transaction handling

        Args:
            match_data: Dictionary containing match data

        Returns:
            Match: Created Match instance

        Raises:
            ValidationError: If data validation fails
            Exception: For other errors during loading
        """
        try:
            # Validate all input data
            self.validator.validate(match_data)

            # Load core match data
            competition, season = self._get_or_create_competition_and_season(
                match_data)
            teams = self._create_teams(match_data)
            match = self._create_match(match_data, competition, season, teams)

            # Load related data
            self._create_formations(match, match_data, teams)
            self._create_players(match, match_data, teams)

            logger.info(f"Successfully loaded match {match_data['matchId']}")
            return match

        except ValidationError as e:
            logger.error(
                f"Validation error for match {match_data.get('matchId')}: {str(e)}")
            raise
        except Exception as e:
            logger.error(
                f"Error loading match {match_data.get('matchId')}: {str(e)}")
            raise

    def _get_or_create_competition_and_season(
            self, data: Dict[str, Any]) -> Tuple[Model, Model]:
        """Create or retrieve competition and season"""
        try:
            # First get or create the competition
            competition, _ = Competition.objects.get_or_create(
                name=data['league'],
                country=data['region']
            )

            # Parse the season name from the data
            season_name = data['season']  # e.g., "2023/24"

            # Get or create the season
            season, created = Season.objects.get_or_create(
                competition=competition,
                name=season_name,
                defaults={
                    'is_current': False  # This should be managed separately
                }
            )

            if created:
                logger.info(f"Created new season: {season}")

            return competition, season
        except Exception as e:
            logger.error(f"Error creating competition and season: {str(e)}")
            raise

    def _create_teams(self, data: Dict[str, Any]) -> Dict[str, Model]:
        """Create or retrieve both teams"""
        teams = {}
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team, created = Team.objects.get_or_create(
                    team_id=team_data['teamId'],
                    defaults={
                        'name': team_data['name'],
                        'country': data['region']
                    }
                )
                if created:
                    logger.info(f"Created new team: {team}")
                else:
                    logger.info(f"Updated team: {team}")
                teams[venue] = team
            return teams
        except Exception as e:
            logger.error(f"Error creating or updating teams: {str(e)}")
            raise

    def _create_match(self, data: Dict[str, Any], competition: Model,
                      season: Model, teams: Dict[str, Model]) -> Model:
        """Create or update the main match record"""

        start_datetime = None

        try:
            # Parse all scores
            ht_score = ScoreData.from_string(data['htScore'])
            ft_score = ScoreData.from_string(data['ftScore'])
            et_score = None
            if data.get('etScore'):
                et_score = ScoreData.from_string(data['etScore'])

            # Parse the datetime
            start_datetime = None
            try:
                if 'T' in data['startDate']:
                    # New format: "2023-11-06T00:00:00"
                    start_date = datetime.strptime(
                        data['startDate'].split('T')[0], "%Y-%m-%d")
                    # New format: "2023-11-06T20:00:00"
                    start_time = datetime.strptime(
                        data['startTime'].split('T')[1], "%H:%M:%S")
                    start_datetime = datetime.combine(
                        start_date.date(), start_time.time())
                    # Add timezone info
                    start_datetime = uk_tz.localize(start_datetime)
                else:
                    # Old format handling
                    start_datetime = datetime.strptime(
                        f"{data['startDate']} {data['startTime']}",
                        "%Y-%m-%d %H:%M:%S"
                    )
                    # Add timezone info here too
                    start_datetime = uk_tz.localize(start_datetime)

            except (ValueError, TypeError) as e:
                logger.error(f"Error parsing datetime: {e}")
                raise ValidationError(
                    f"Invalid datetime format: {data['startDate']} {data['startTime']}")

            defaults = {
                'season': season,  # Add season reference
                'start_datetime': start_datetime,
                'venue': data['venueName'],
                'attendance': data.get('attendance'),
                'referee_id': data.get('referee', {}).get('officialId'),
                'referee_name': data.get('referee', {}).get('name'),
                # 'score': data['score'],
                'home_team': teams['home'],
                'away_team': teams['away'],
                'home_score_ht': ht_score.home,
                'away_score_ht': ht_score.away,
                'home_score_ft': ft_score.home,
                'away_score_ft': ft_score.away,
                'home_score_et': et_score.home if et_score else None,
                'away_score_et': et_score.away if et_score else None,
                'home_manager_name': data['home']['managerName'],
                'away_manager_name': data['away']['managerName'],
                'home_team_average_age': data['home']['averageAge'],
                'away_team_average_age': data['away']['averageAge']
            }

            match, created = Match.objects.update_or_create(
                match_id=data['matchId'],
                defaults=defaults
            )

            action = "Created new" if created else "Updated existing"
            logger.info(f"{action} match: {match}")

            return match

        except Exception as e:
            logger.error(
                f"Error creating or updating match {data.get('matchId')}: {str(e)}")
            raise

    def _create_formations(
            self, match: Model, data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update formation records for both teams"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                for formation_data in team_data['formations']:
                    # Extract formation details
                    formation_name = formation_data['formationName']
                    captain_id = formation_data['captainPlayerId']

                    # Get the full minute range
                    start_minute = formation_data.get(
                        'startMinuteExpanded', 0)  # Default to 0 if not specified
                    end_minute = formation_data.get(
                        'endMinuteExpanded', 90)  # Default to 90 if not specified

                    # Create or update formation record
                    Formation.objects.update_or_create(
                        match=match,
                        team=teams[venue],
                        start_minute=start_minute,
                        end_minute=end_minute,  # Add this to uniqueness constraint
                        defaults={
                            'formation_name': formation_name,
                            'captain_player_id': captain_id,
                            'player_ids': formation_data.get('playerIds', []),
                            'jersey_numbers': formation_data.get('jerseyNumbers', [])
                        }
                    )

                    logger.info(
                        f"Created/updated formation for {teams[venue].name}: "
                        f"{formation_name} ({start_minute}-{end_minute})"
                    )

        except Exception as e:
            logger.error(f"Error creating/updating formations: {str(e)}")
            logger.error(f"Formation data: {formation_data}")
            raise

    def _create_players(self, match: Model,
                        data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update player records and match-player relationships"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team = teams[venue]

                for player_data in team_data['players']:
                    # First update or create the base player record
                    try:
                        player, player_created = Player.objects.update_or_create(
                            player_id=player_data['playerId'],
                            defaults={
                                'name': player_data['name'],
                                'height': player_data.get('height'),
                                'weight': player_data.get('weight'),
                            }
                        )

                        # Then update or create the match-specific player
                        # record
                        MatchPlayer.objects.update_or_create(
                            match=match,
                            player=player,
                            team=team,
                            defaults={
                                'shirt_no': player_data['shirtNo'],
                                'position': player_data['position'],
                                # 'field': player_data['field'],
                                'is_first_eleven': player_data.get('isFirstEleven', False),
                                'is_man_of_match': player_data.get('isManOfTheMatch', False),
                                'age': player_data.get('age', 0),
                                'height': player_data.get('height', 0),
                                'weight': player_data.get('weight', 0),
                                # 'stats': player_data.get('stats', {})
                            }
                        )

                    except Exception as e:
                        logger.error(
                            f"Error processing player {player_data.get('playerId')}: {str(e)}")
                        raise

        except Exception as e:
            logger.error(f"Error creating/updating players: {str(e)}")
            raise

================
File: backend/sbapi/services/main/main.py
================
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 14 14:20:02 2020

@author: aliha
@twitter: rockingAli5 
"""

import re
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import NoSuchElementException, WebDriverException
from selenium import webdriver
import numpy as np
import itertools
from datetime import datetime as dt
import datetime
from collections import OrderedDict
from bs4 import BeautifulSoup as soup
import json
import warnings
import time
import pandas as pd
pd.options.mode.chained_assignment = None
try:
    from tqdm import trange
except ModuleNotFoundError:
    pass


options = webdriver.ChromeOptions()

options.add_experimental_option('excludeSwitches', ['enable-logging'])


TRANSLATE_DICT = {'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mac': 'Mar',
                  'Apr': 'Apr',
                  'Mei': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Ago': 'Aug',
                  'Sep': 'Sep',
                  'Okt': 'Oct',
                  'Nov': 'Nov',
                  'Des': 'Dec',
                  'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mar': 'Mar',
                  'Apr': 'Apr',
                  'May': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Aug': 'Aug',
                  'Sep': 'Sep',
                  'Oct': 'Oct',
                  'Nov': 'Nov',
                  'Dec': 'Dec'}

main_url = 'https://1xbet.whoscored.com/'


def getLeagueUrls(minimize_window=True):

    driver = webdriver.Chrome()

    if minimize_window:
        driver.minimize_window()

    driver.get(main_url)
    league_names = []
    league_urls = []
    try:
        cookie_button = driver.find_element(
            By.XPATH, '//*[@class=" css-gweyaj"]').click()
    except NoSuchElementException:
        pass
    tournaments_btn = driver.find_element(
        By.XPATH, '//*[@id="All-Tournaments-btn"]').click()
    n_button = soup(driver.find_element(
        By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[1]/div/div').get_attribute('innerHTML')).find_all('button')
    n_tournaments = []
    for button in n_button:
        id_button = button.get('id')
        driver.find_element(By.ID, id_button).click()
        n_country = soup(driver.find_element(By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute(
            'innerHTML')).find_all('div', {'class': 'TournamentsDropdownMenu-module_countryDropdownContainer__I9P6n'})

        for country in n_country:
            country_id = country.find(
                'div', {'class': 'TournamentsDropdownMenu-module_countryDropdown__8rtD-'}).get('id')

            # Trouver l'élément avec Selenium et cliquer dessus
            country_element = driver.find_element(By.ID, country_id)
            country_element.click()

            html_tournaments_list = driver.find_element(
                By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute('innerHTML')

            # Parse le HTML avec BeautifulSoup pour trouver les liens des tournois
            soup_tournaments = soup(html_tournaments_list, 'html.parser')
            tournaments = soup_tournaments.find_all('a')

            # Ajouter les tournois à la liste n_tournaments
            n_tournaments.extend(tournaments)

            driver.execute_script("arguments[0].click();", country_element)

    for tournament in n_tournaments:
        league_name = tournament.get('href').split('/')[-1]
        league_link = main_url[:-1]+tournament.get('href')
        league_names.append(league_name)
        league_urls.append(league_link)

    leagues = {}
    for name, link in zip(league_names, league_urls):
        leagues[name] = link

    driver.close()
    return leagues


def getMatchUrls(comp_urls, competition, season, maximize_window=True):

    driver = webdriver.Chrome()

    if maximize_window:
        driver.maximize_window()

    comp_url = comp_urls[competition]
    driver.get(comp_url)
    time.sleep(5)

    seasons = driver.find_element(
        By.XPATH, '//*[@id="seasons"]').get_attribute('innerHTML').split(sep='\n')
    seasons = [i for i in seasons if i]

    for i in range(1, len(seasons)+1):
        if driver.find_element(By.XPATH, '//*[@id="seasons"]/option['+str(i)+']').text == season:
            driver.find_element(
                By.XPATH, '//*[@id="seasons"]/option['+str(i)+']').click()

            time.sleep(5)
            try:
                stages = driver.find_element(
                    By.XPATH, '//*[@id="stages"]').get_attribute('innerHTML').split(sep='\n')
                stages = [i for i in stages if i]

                all_urls = []

                for i in range(1, len(stages)+1):
                    print(driver.find_element(
                        By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text)
                    if competition == 'Champions League' or competition == 'Europa League':
                        if 'Grp' in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text or 'Final Stage' in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    elif competition == 'Major League Soccer':
                        if 'Grp. ' not in driver.find_element(By.XPATH, '//*[@id="stages"]/option['+str(i)+']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    else:
                        driver.find_element(
                            By.XPATH, '//*[@id="stages"]/option['+str(i)+']').click()
                        time.sleep(5)

                        driver.execute_script("window.scrollTo(0, 400)")

                        match_urls = getFixtureData(driver)

                        match_urls = getSortedData(match_urls)

                        match_urls2 = [
                            url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                        all_urls += match_urls2

            except NoSuchElementException:
                all_urls = []

                driver.execute_script("window.scrollTo(0, 400)")

                match_urls = getFixtureData(driver)

                match_urls = getSortedData(match_urls)

                match_urls2 = [
                    url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                all_urls += match_urls2

            remove_dup = [dict(t) for t in {tuple(
                sorted(d.items())) for d in all_urls}]
            all_urls = getSortedData(remove_dup)

            driver.close()

            return all_urls

    season_names = [re.search(r'\>(.*?)\<', season).group(1)
                    for season in seasons]
    driver.close()
    print('Seasons available: {}'.format(season_names))
    raise ('Season Not Found.')


def getTeamUrls(team, match_urls):

    team_data = []
    for fixture in match_urls:
        if fixture['home'] == team or fixture['away'] == team:
            team_data.append(fixture)
    team_data = [a[0] for a in itertools.groupby(team_data)]

    return team_data


def getMatchesData(match_urls, minimize_window=True):

    matches = []

    driver = webdriver.Chrome()
    if minimize_window:
        driver.minimize_window()

    try:
        for i in trange(len(match_urls), desc='Getting Match Data'):
            # recommended to avoid getting blocked by incapsula/imperva bots
            time.sleep(7)
            match_data = getMatchData(
                driver, main_url+match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)
    except NameError:
        print('Recommended: \'pip install tqdm\' for a progress bar while the data gets scraped....')
        time.sleep(7)
        for i in range(len(match_urls)):
            match_data = getMatchData(
                driver, main_url+match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)

    driver.close()

    return matches


def getFixtureData(driver):
    matches_ls = []
    while True:
        initial = driver.page_source
        all_fixtures = driver.find_elements(
            By.CLASS_NAME, 'Accordion-module_accordion__UuHD0')
        for dates in all_fixtures:
            fixtures = dates.find_elements(
                By.CLASS_NAME, 'Match-module_row__zwBOn')
            date_row = dates.find_element(
                By.CLASS_NAME, 'Accordion-module_header__HqzWD')
            for row in fixtures:
                url = row.find_element(By.TAG_NAME, 'a')
                if 'Live' in url.get_attribute('href'):
                    match_dict = {}
                    element = soup(row.get_attribute(
                        'innerHTML'), features='lxml')
                    teams_tag = element.find(
                        "div", {"class": "Match-module_teams__sGVeq"})
                    link_tag = element.find("a")
                    match_dict['date'] = date_row.text
                    match_dict['home'] = teams_tag.find_all('a')[0].text
                    match_dict['away'] = teams_tag.find_all('a')[1].text
                    match_dict['score'] = ':'.join(
                        [t.text for t in link_tag.find_all('span')])
                    match_dict['url'] = link_tag['href']
                    matches_ls.append(match_dict)
        prev_btn = driver.find_element(By.ID, 'dayChangeBtn-prev')
        prev_btn.click()
        time.sleep(1)
        final = driver.page_source
        if initial == final:
            break

    return matches_ls


def translateDate(data):

    unwanted = []
    for match in data:
        date = match['date'].split()
        if '?' not in date[0]:
            try:
                match['date'] = ' '.join(
                    [TRANSLATE_DICT[date[0]], date[1], date[2]])
            except KeyError:
                print(date)
        else:
            unwanted.append(data.index(match))

    # remove matches that got suspended/postponed
    for i in sorted(unwanted, reverse=True):
        del data[i]

    return data


def getSortedData(data):
    data = sorted(data, key=lambda i: dt.strptime(i['date'], '%A, %b %d %Y'))
    return data


def getMatchData(driver, url, display=True, close_window=True):
    try:
        driver.get(url)
    except WebDriverException:
        driver.get(url)

    time.sleep(5)
    # get script data from page source
    script_content = driver.find_element(
        By.XPATH, '//*[@id="layout-wrapper"]/script[1]').get_attribute('innerHTML')

    # clean script content
    script_content = re.sub(r"[\n\t]*", "", script_content)
    script_content = script_content[script_content.index(
        "matchId"):script_content.rindex("}")]

    # this will give script content in list form
    script_content_list = list(
        filter(None, script_content.strip().split(',            ')))
    metadata = script_content_list.pop(1)

    # string format to json format
    match_data = json.loads(metadata[metadata.index('{'):])
    keys = [item[:item.index(':')].strip() for item in script_content_list]
    values = [item[item.index(':')+1:].strip() for item in script_content_list]
    for key, val in zip(keys, values):
        match_data[key] = json.loads(val)

    # get other details about the match
    region = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/span[1]').text
    league = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[0]
    season = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[1]
    if len(driver.find_element(By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 2:
        competition_type = 'League'
        competition_stage = ''
    elif len(driver.find_element(By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 3:
        competition_type = 'Knock Out'
        competition_stage = driver.find_element(
            By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[-1]
    else:
        print('Getting more than 3 types of information about the competition.')

    match_data['region'] = region
    match_data['league'] = league
    match_data['season'] = season
    match_data['competitionType'] = competition_type
    match_data['competitionStage'] = competition_stage

    # sort match_data dictionary alphabetically
    match_data = OrderedDict(sorted(match_data.items()))
    match_data = dict(match_data)
    if display:
        print('Region: {}, League: {}, Season: {}, Match Id: {}'.format(
            region, league, season, match_data['matchId']))

    if close_window:
        driver.close()

    return match_data


def createEventsDF(data):
    events = data['events']
    for event in events:
        event.update({'matchId': data['matchId'],
                      'startDate': data['startDate'],
                      'startTime': data['startTime'],
                      'score': data['score'],
                      'ftScore': data['ftScore'],
                      'htScore': data['htScore'],
                      'etScore': data['etScore'],
                      'venueName': data['venueName'],
                      'maxMinute': data['maxMinute']})
    events_df = pd.DataFrame(events)

    # clean period column
    events_df['period'] = pd.json_normalize(events_df['period'])['displayName']

    # clean type column
    events_df['type'] = pd.json_normalize(events_df['type'])['displayName']

    # clean outcomeType column
    events_df['outcomeType'] = pd.json_normalize(
        events_df['outcomeType'])['displayName']

    # clean outcomeType column
    try:
        x = events_df['cardType'].fillna({i: {} for i in events_df.index})
        events_df['cardType'] = pd.json_normalize(
            x)['displayName'].fillna(False)
    except KeyError:
        events_df['cardType'] = False

    eventTypeDict = data['matchCentreEventTypeJson']
    events_df['satisfiedEventsTypes'] = events_df['satisfiedEventsTypes'].apply(
        lambda x: [list(eventTypeDict.keys())[list(eventTypeDict.values()).index(event)] for event in x])

    # clean qualifiers column
    try:
        for i in events_df.index:
            row = events_df.loc[i, 'qualifiers'].copy()
            if len(row) != 0:
                for irow in range(len(row)):
                    row[irow]['type'] = row[irow]['type']['displayName']
    except TypeError:
        pass

    # clean isShot column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        if 'isShot' in events_df.columns:
            events_df['isShot'] = events_df['isShot'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isShot'] = False

        # clean isGoal column
        if 'isGoal' in events_df.columns:
            events_df['isGoal'] = events_df['isGoal'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isGoal'] = False

    # add player name column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        events_df.loc[events_df.playerId.notna(
        ), 'playerId'] = events_df.loc[events_df.playerId.notna(), 'playerId'].astype(int).astype(str)
    player_name_col = events_df.loc[:, 'playerId'].map(
        data['playerIdNameDictionary'])
    events_df.insert(loc=events_df.columns.get_loc("playerId")+1,
                     column='playerName', value=player_name_col)

    # add home/away column
    h_a_col = events_df['teamId'].map(
        {data['home']['teamId']: 'h', data['away']['teamId']: 'a'})
    events_df.insert(loc=events_df.columns.get_loc(
        "teamId")+1, column='h_a', value=h_a_col)

    # adding shot body part column
    events_df['shotBodyType'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'RightFoot' or j['type'] == 'LeftFoot' or j['type'] == 'Head' or j['type'] == 'OtherBodyPart':
                    events_df.loc[i, 'shotBodyType'] = j['type']

    # adding shot situation column
    events_df['situation'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'FromCorner' or j['type'] == 'SetPiece' or j['type'] == 'DirectFreekick':
                    events_df.loc[i, 'situation'] = j['type']
                if j['type'] == 'RegularPlay':
                    events_df.loc[i, 'situation'] = 'OpenPlay'

    event_types = list(data['matchCentreEventTypeJson'].keys())
    event_type_cols = pd.DataFrame({event_type: pd.Series(
        [event_type in row for row in events_df['satisfiedEventsTypes']]) for event_type in event_types})
    events_df = pd.concat([events_df, event_type_cols], axis=1)

    return events_df


def createMatchesDF(data):
    columns_req_ls = ['matchId', 'attendance', 'venueName', 'startTime', 'startDate',
                      'score', 'home', 'away', 'referee']
    matches_df = pd.DataFrame(columns=columns_req_ls)
    if type(data) == dict:
        matches_dict = dict(
            [(key, val) for key, val in data.items() if key in columns_req_ls])
        matches_df = pd.DataFrame(
            matches_dict, columns=columns_req_ls).reset_index(drop=True)
        matches_df[['home', 'away']] = np.nan
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=FutureWarning)
            matches_df['home'].iloc[0] = [data['home']]
            matches_df['away'].iloc[0] = [data['away']]
    else:
        for match in data:
            matches_dict = dict(
                [(key, val) for key, val in match.items() if key in columns_req_ls])
            matches_df = pd.DataFrame(
                matches_dict, columns=columns_req_ls).reset_index(drop=True)

    matches_df = matches_df.set_index('matchId')
    return matches_df


def load_EPV_grid(fname='EPV_grid.csv'):
    """ load_EPV_grid(fname='EPV_grid.csv')

    # load pregenerated EPV surface from file. 

    Parameters
    -----------
        fname: filename & path of EPV grid (default is 'EPV_grid.csv' in the curernt directory)

    Returns
    -----------
        EPV: The EPV surface (default is a (32,50) grid)

    """
    epv = np.loadtxt(fname, delimiter=',')
    return epv


def get_EPV_at_location(position, EPV, attack_direction, field_dimen=(106., 68.)):
    """ get_EPV_at_location

    Returns the EPV value at a given (x,y) location

    Parameters
    -----------
        position: Tuple containing the (x,y) pitch position
        EPV: tuple Expected Possession value grid (loaded using load_EPV_grid() )
        attack_direction: Sets the attack direction (1: left->right, -1: right->left)
        field_dimen: tuple containing the length and width of the pitch in meters. Default is (106,68)

    Returrns
    -----------
        EPV value at input position

    """

    x, y = position
    if abs(x) > field_dimen[0]/2. or abs(y) > field_dimen[1]/2.:
        return 0.0  # Position is off the field, EPV is zero
    else:
        if attack_direction == -1:
            EPV = np.fliplr(EPV)
        ny, nx = EPV.shape
        dx = field_dimen[0]/float(nx)
        dy = field_dimen[1]/float(ny)
        ix = (x+field_dimen[0]/2.-0.0001)/dx
        iy = (y+field_dimen[1]/2.-0.0001)/dy
        return EPV[int(iy), int(ix)]


def to_metric_coordinates_from_whoscored(data, field_dimen=(106., 68.)):
    '''
    Convert positions from Whoscored units to meters (with origin at centre circle)
    '''
    x_columns = [c for c in data.columns if c[-1].lower() == 'x'][:2]
    y_columns = [c for c in data.columns if c[-1].lower() == 'y'][:2]
    x_columns_mod = [c+'_metrica' for c in x_columns]
    y_columns_mod = [c+'_metrica' for c in y_columns]
    data[x_columns_mod] = (data[x_columns]/100*106)-53
    data[y_columns_mod] = (data[y_columns]/100*68)-34
    return data


def addEpvToDataFrame(data):

    # loading EPV data
    EPV = load_EPV_grid('EPV_grid.csv')

    # converting opta coordinates to metric coordinates
    data = to_metric_coordinates_from_whoscored(data)

    # calculating EPV for events
    EPV_difference = []
    for i in data.index:
        if data.loc[i, 'type'] == 'Pass' and data.loc[i, 'outcomeType'] == 'Successful':
            start_pos = (data.loc[i, 'x_metrica'], data.loc[i, 'y_metrica'])
            start_epv = get_EPV_at_location(start_pos, EPV, attack_direction=1)

            end_pos = (data.loc[i, 'endX_metrica'],
                       data.loc[i, 'endY_metrica'])
            end_epv = get_EPV_at_location(end_pos, EPV, attack_direction=1)

            diff = end_epv - start_epv
            EPV_difference.append(diff)

        else:
            EPV_difference.append(np.nan)

    data = data.assign(EPV_difference=EPV_difference)

    # dump useless columns
    drop_cols = ['x_metrica', 'endX_metrica', 'y_metrica',
                 'endY_metrica']
    data.drop(drop_cols, axis=1, inplace=True)
    data.rename(columns={'EPV_difference': 'EPV'}, inplace=True)

    return data

================
File: backend/sbapi/services/main/test.py
================
# import relevant functions
from main import getLeagueUrls, getMatchUrls, getTeamUrls, getMatchesData, getMatchData, createEventsDF, createMatchesDF, addEpvToDataFrame

# import relevant variables
from main import main_url

# import relevant packages
import pandas as pd

from selenium import webdriver
options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])


# write test functions for all functions in file
def test():
    print('Testing getLeagueUrls function...')
    leagues = getLeagueUrls()


assert isinstance(leagues,     assert )    assert len(leagues) == 23
print('getLeagueUrls function passed all tests.')

print('Testing getMatchUrls function...')
comp_urls = getLeagueUrls()
match_urls = getMatchUrls(comp_urls, 'Premier League', '2019/2020')
assert isinstance(match_urls,     assert )    assert len(match_urls) == 380
print('getMatchUrls function passed all tests.')

print('Testing getTeamUrls function...')
team_urls = getTeamUrls('Liverpool', match_urls)
assert isinstance(team_urls,     assert )    assert len(team_urls) == 38
print('getTeamUrls function passed all tests.')

print('Testing getMatchesData function...')
matches = getMatchesData(team_urls)
assert isinstance(matches,     assert )    assert len(matches) == 38
print('getMatchesData function passed all tests.')

print('Testing getMatchData function...')
driver = webdriver.Chrome('drivers/chromedriver.exe', options=options)
match_data = getMatchData(
    driver, main_url + '/Matches/1375927/Live/England-Premier-League-2019-2020-Liverpool-Norwich')
assert isinstance(match_data,     assert )    assert len(match_data) == 36
print('getMatchData function passed all tests.')

print('Testing createEventsDF function...')
events_df = createEventsDF(match_data)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 259
print('createEventsDF function passed all tests.')

print('Testing createMatchesDF function...')
matches_df = createMatchesDF(match_data)
assert isinstance(matches_df,     assert )    assert matches_df.shape[1] == 8
print('createMatchesDF function passed all tests.')

print('Testing addEpvToDataFrame function...')
events_df = addEpvToDataFrame(events_df)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 260
print('addEpvToDataFrame function passed all tests.')

print('All tests passed.')


if __name__ == '__main__':
    test()

================
File: backend/sbapi/services/main/utils.py
================
import os
import re
from sys import platform


def extract_version_registry(output):
    try:
        google_version = ''
        for letter in output[output.rindex('DisplayVersion    REG_SZ') + 24:]:
            if letter != '\n':
                google_version += letter
            else:
                break
        return (google_version.strip())
    except TypeError:
        return


def extract_version_folder():
    # Check if the Chrome folder exists in the x32 or x64 Program Files
    # folders.
    for i in range(2):
        path = 'C:\\Program Files' + \
            (' (x86)' if i else '') + '\\Google\\Chrome\\Application'
        if os.path.isdir(path):
            paths = [f.path for f in os.scandir(path) if f.is_dir()]
            for path in paths:
                filename = os.path.basename(path)
                pattern = '\\d+\\.\\d+\\.\\d+\\.\\d+'
                match = re.search(pattern, filename)
                if match and match.group():
                    # Found a Chrome version.
                    return match.group(0)

    return None


def get_chrome_version():
    version = None
    install_path = None

    try:
        if platform == "linux" or platform == "linux2":
            # linux
            install_path = "/usr/bin/google-chrome"
        elif platform == "darwin":
            # OS X
            install_path = "/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"
        elif platform == "win32":
            # Windows...
            try:
                # Try registry key.
                stream = os.popen(
                    'reg query "HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Google Chrome"')
                output = stream.read()
                version = extract_version_registry(output)
            except Exception as ex:
                # Try folder path.
                version = extract_version_folder()
    except Exception as ex:
        print(ex)

    version = os.popen(f"{install_path} --version").read().strip(
        'Google Chrome ').strip() if install_path else version

    return version

================
File: backend/sbapi/services/scripts/match_scraper.py
================
import logging
from typing import Dict, Any, Optional
import pandas as pd
from selenium import webdriver
from django.db import transaction

from sbapi.services.main.main import getMatchData, createMatchesDF, createEventsDF
from sbapi.services.loaders.match_loader import MatchLoader
from sbapi.services.loaders.event_loader import load_match_events

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Also add this to make sure handlers are configured
logger.setLevel(logging.DEBUG)


class MatchScraper:
    """Handles scraping and processing of match data"""

    def __init__(self):
        self.match_loader = MatchLoader()

    def scrape_match(self, url: str) -> Dict[str, Any]:
        """
        Get match data from URL
        """
        try:
            driver = webdriver.Chrome()
            match_data = getMatchData(driver, url, close_window=True)
            return match_data
        except Exception as e:
            logger.error(f"Error scraping match data: {str(e)}")
            raise

    def process_match_data(
            self, match_data: Dict[str, Any]) -> Optional[Dict[str, pd.DataFrame]]:
        """
        Process raw match data into DataFrames and load into database
        """
        try:
            # Create DataFrames
            matches_df = createMatchesDF(match_data)
            events_df = createEventsDF(match_data)

            # Load data into database using transaction
            with transaction.atomic():
                # Load match data first
                match = self.match_loader.load_match(match_data)

                # Load events data
                load_match_events(match, events_df)

                logger.info(
                    f"Successfully processed match {match_data['matchId']}")

            return {
                'matches': matches_df,
                'events': events_df
            }

        except Exception as e:
            logger.error(f"Error processing match data: {str(e)}")
            raise

================
File: backend/sbapi/v1/serializers/base/__init__.py
================
from .common import BaseStatsSerializer, BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer, BaseTeamStatsSerializer
from .competition import CompetitionListSerializer, CompetitionDetailSerializer, SeasonSerializer
from .events import (
    BaseEventSerializer,
    DefendingEventSerializer,
    GoalkeeperEventSerializer,
    PassEventSerializer,
    PossessionEventSerializer,
    ShootingEventSerializer,
    SummaryEventSerializer,
    get_event_serializer
)
from .match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'DefendingEventSerializer',
    'GoalkeeperEventSerializer',
    'PassEventSerializer',
    'PossessionEventSerializer',
    'ShootingEventSerializer',
    'SummaryEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer'
]

================
File: backend/sbapi/v1/serializers/base/common.py
================
from rest_framework import serializers


class BaseStatsSerializer(serializers.Serializer):
    """Base serializer for all stats"""
    competition_name = serializers.CharField(required=False)
    season_name = serializers.CharField(required=False)
    total_events = serializers.IntegerField(required=False)


class BasePlayerStatsSerializer(BaseStatsSerializer):
    """Base serializer for all player stats"""
    games_played = serializers.IntegerField(required=False)
    games_started = serializers.IntegerField(required=False)
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()




================
File: backend/sbapi/v1/serializers/base/events.py
================
from rest_framework import serializers
from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)
from ..base.base import BaseSerializer


class BaseEventSerializer(BaseSerializer):
    """Base serializer for common event fields"""
    team_name = serializers.CharField(source='team.name')
    player_name = serializers.CharField(source='player.name', allow_null=True)

    class Meta:
        model = SummaryEvent
        abstract = True
        fields = [
            'event_id',
            'type',
            'minute',
            'second',
            'period',
            'team_name',
            'player_name',
            'x',
            'y',
            'end_x',
            'end_y',
            'outcome_type',
            'situation'
        ]


class DefendingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = DefendingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_tackle',
            'is_interception',
            'is_clearance',
            'is_ball_recovery',
            'aerial_success',
            'clearance_effective',
            'tackle_won',
            'interception_won',
            'defensive_duel',
            'error_leads_to_goal',
            'error_leads_to_shot',
        ]


class GoalkeeperEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = GoalkeeperEvent
        fields = BaseEventSerializer.Meta.fields + [
            'keeper_save_total',
            'keeper_claim_won',
            'keeper_claim_lost',
            'keeper_diving_save',
            'keeper_save_in_the_box',
            'keeper_penalty_saved',
            'save_high_centre',
            'save_high_left',
            'save_high_right',
            'save_low_centre',
            'save_low_left',
            'save_low_right',
        ]


class PassEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PassEvent
        fields = BaseEventSerializer.Meta.fields + [
            'pass_accurate',
            'pass_inaccurate',
            'assist',
            'key_pass_cross',
            'key_pass_throughball',
            'pass_cross_accurate',
            'pass_through_ball_accurate',
            'big_chance_created',
            'successful_final_third_passes',
        ]


class PossessionEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PossessionEvent
        fields = BaseEventSerializer.Meta.fields + [
            'dispossessed',
            'touches',
            'dribble_won',
            'dribble_lost',
            'penalty_won',
            'offside_given',
        ]


class ShootingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = ShootingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_goal',
            'is_shot',
            'shot_on_target',
            'big_chance_scored',
            'big_chance_missed',
            'goal_mouth_y',
            'goal_mouth_z',
            'shot_body_type',
            'shot_penalty_area',
            'shot_six_yard_box',
        ]


class SummaryEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = SummaryEvent
        fields = BaseEventSerializer.Meta.fields + [
            'card_type',
            'yellow_card',
            'red_card',
            'second_yellow',
            'foul_committed',
            'sub_on',
            'sub_off',
        ]


# Factory function to get appropriate serializer
EVENT_TYPE_SERIALIZERS = {
    'defending': DefendingEventSerializer,
    'goalkeeper': GoalkeeperEventSerializer,
    'passing': PassEventSerializer,
    'possession': PossessionEventSerializer,
    'shooting': ShootingEventSerializer,
    'summary': SummaryEventSerializer,
}


def get_event_serializer(event_type):
    """Returns appropriate serializer based on event type"""
    return EVENT_TYPE_SERIALIZERS.get(event_type, BaseEventSerializer)

================
File: backend/sbapi/v1/serializers/base/match.py
================
from rest_framework import serializers
from ....models import Match, Team, MatchPlayer, Formation
from .base import BaseSerializer, HalModelSerializer


class TeamBasicSerializer(serializers.Serializer):
    """Team serializer specifically for stats responses"""
    team_id = serializers.IntegerField()
    name = serializers.CharField()
    country = serializers.CharField()


class LineupPlayerSerializer(BaseSerializer):
    """Simplified player information for lineups"""
    name = serializers.CharField(source='player.name')

    class Meta:
        model = MatchPlayer
        fields = ['name', 'shirt_no', 'position']


class TeamLineupSerializer(serializers.Serializer):
    """Serializer for single team lineup data"""
    team = TeamBasicSerializer()
    starting_formation = serializers.CharField(allow_null=True)
    formation_changes = serializers.ListField(
        child=serializers.DictField()
    )
    starting_lineup = LineupPlayerSerializer(many=True)
    substitutions = serializers.ListField(
        child=serializers.DictField()
    )


class LineupResponseSerializer(serializers.Serializer):
    """Serializer for complete lineup response data"""
    status = serializers.CharField(default='success')
    message = serializers.CharField(allow_null=True, default=None)
    data = serializers.SerializerMethodField()

    def get_data(self, obj):
        return {
            'home_team': TeamLineupSerializer(obj['home_team']).data,
            'away_team': TeamLineupSerializer(obj['away_team']).data
        }


class MatchListSerializer(HalModelSerializer):
    """Simplified match list serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'start_datetime',
            'home_team',
            'away_team',
            'score',
            'venue',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/sbapi/v1/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events'
        }


class MatchDetailSerializer(HalModelSerializer):
    """Detailed match information serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    competition_name = serializers.CharField(source='season.competition.name')
    season_name = serializers.CharField(source='season.name')
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'competition_name',
            'season_name',
            'start_datetime',
            'venue',
            'attendance',
            'referee_name',
            'home_team',
            'away_team',
            'home_manager_name',
            'away_manager_name',
            'home_team_average_age',
            'away_team_average_age',
            'home_score_ft',
            'away_score_ft',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events',
            'stats': f'/sbapi/v1/matches/{obj.match_id}/stats'
        }

================
File: backend/sbapi/v1/serializers/player_analytics/match_events/base.py
================
from rest_framework import serializers
from ...base.base import BaseSerializer

class BaseEventSerializer(BaseSerializer):
    """Base serializer for common event fields"""
    team_name = serializers.CharField(source='team.name')
    player_name = serializers.CharField(source='player.name', allow_null=True)

    class Meta:
        model = None  # Set by child classes
        fields = [
            'event_id',
            'type',
            'minute',
            'second',
            'period',
            'team_name',
            'player_name',
            'x',
            'y',
            'end_x',
            'end_y',
            'outcome_type',
            'situation'
        ]

================
File: backend/sbapi/v1/serializers/player_analytics/match_events/passing.py
================
from rest_framework import serializers
from .base import BaseEventSerializer
from sbapi.models.events import PassEvent


class PassEventSerializer(BaseEventSerializer):
    """Basic serializer for pass events - used for listings"""
    pass_type = serializers.SerializerMethodField()
    pass_accuracy = serializers.BooleanField()

    class Meta(BaseEventSerializer.Meta):
        model = PassEvent
        fields = BaseEventSerializer.Meta.fields + [
            'pass_type',
            'pass_accuracy',
            'assist',
            'pass_key',
            'big_chance_created'
        ]
    
    def get_pass_type(self, obj):
        """Simple pass type for listings"""
        if obj.pass_corner:
            return 'corner'
        elif obj.pass_cross_accurate or obj.pass_cross_inaccurate:
            return 'cross'
        elif obj.pass_freekick:
            return 'freekick'
        elif obj.pass_through_ball_accurate or obj.pass_through_ball_inaccurate:
            return 'through_ball'
        return 'regular'

class DetailedPassEventSerializer(PassEventSerializer):
    """Detailed serializer with all pass attributes"""
    assist_details = serializers.SerializerMethodField()
    key_pass_details = serializers.SerializerMethodField()
    pass_details = serializers.SerializerMethodField()
    location_stats = serializers.SerializerMethodField()

    class Meta(PassEventSerializer.Meta):
        fields = PassEventSerializer.Meta.fields + [
            'assist_details',
            'key_pass_details',
            'pass_details',
            'location_stats'
        ]

    def get_assist_details(self, obj):
        """Group assist-related attributes"""
        return {
            'is_assist': obj.assist,
            'types': {
                'corner': obj.assist_corner,
                'cross': obj.assist_cross,
                'freekick': obj.assist_freekick,
                'throughball': obj.assist_throughball,
                'throwin': obj.assist_throwin,
                'other': obj.assist_other
            },
            'intentional': obj.intentional_assist
        }

    def get_key_pass_details(self, obj):
        """Group key pass attributes"""
        return {
            'is_key_pass': obj.pass_key,
            'types': {
                'corner': obj.key_pass_corner,
                'cross': obj.key_pass_cross,
                'freekick': obj.key_pass_freekick,
                'long': obj.key_pass_long,
                'short': obj.key_pass_short,
                'throughball': obj.key_pass_throughball,
                'throwin': obj.key_pass_throwin,
                'other': obj.key_pass_other
            }
        }

    def get_pass_details(self, obj):
        """Group pass attributes"""
        return {
            'accuracy': {
                'accurate': obj.pass_accurate,
                'inaccurate': obj.pass_inaccurate
            },
            'types': {
                'corner': {
                    'attempted': obj.pass_corner,
                    'accurate': obj.pass_corner_accurate,
                    'inaccurate': obj.pass_corner_inaccurate
                },
                'cross': {
                    'accurate': obj.pass_cross_accurate,
                    'inaccurate': obj.pass_cross_inaccurate,
                    'blocked': obj.pass_cross_blocked_defensive
                },
                'freekick': {
                    'attempted': obj.pass_freekick,
                    'accurate': obj.pass_freekick_accurate,
                    'inaccurate': obj.pass_freekick_inaccurate
                },
                'long_ball': {
                    'accurate': obj.pass_long_ball_accurate,
                    'inaccurate': obj.pass_long_ball_inaccurate
                },
                'short': {
                    'accurate': obj.short_pass_accurate,
                    'inaccurate': obj.short_pass_inaccurate
                },
                'through_ball': {
                    'accurate': obj.pass_through_ball_accurate,
                    'inaccurate': obj.pass_through_ball_inaccurate
                }
            },
            'direction': {
                'forward': obj.pass_forward,
                'back': obj.pass_back,
                'left': obj.pass_left,
                'right': obj.pass_right
            },
            'body_part': {
                'head': obj.pass_head,
                'left_foot': obj.pass_left_foot,
                'right_foot': obj.pass_right_foot
            }
        }

    def get_location_stats(self, obj):
        """Location-based statistics"""
        return {
            'final_third': obj.successful_final_third_passes,
            'big_chance_created': obj.big_chance_created,
            'coordinates': {
                'start': {'x': obj.x, 'y': obj.y},
                'end': {'x': obj.end_x, 'y': obj.end_y}
            }
        }

================
File: backend/sbapi/v1/serializers/stats/__init__.py
================
from .player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from .team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer

__all__ = [
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: backend/sbapi/v1/serializers/stats/player_stats.py
================
from rest_framework import serializers
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer


class PlayerMatchStatsSerializer(
        BaseMatchStatsSerializer, BasePlayerStatsSerializer):
    """Detailed stats for a player in a specific match"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    # Changed from DateField to DateTimeField to match match.start_datetime
    match_date = serializers.DateTimeField()
    position = serializers.CharField()
    shirt_no = serializers.IntegerField()
    is_first_eleven = serializers.BooleanField()

    # Shooting stats
    shots = serializers.IntegerField(default=0)
    shots_on_target = serializers.IntegerField(default=0)
    goals = serializers.IntegerField(default=0)
    big_chances = serializers.IntegerField(default=0)

    # Passing stats
    passes_attempted = serializers.IntegerField(default=0)
    passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    key_passes = serializers.IntegerField(default=0)
    assists = serializers.IntegerField(default=0)

    # Defending stats
    tackles = serializers.IntegerField(default=0)
    interceptions = serializers.IntegerField(default=0)
    ball_recoveries = serializers.IntegerField(default=0)
    duels_won = serializers.IntegerField(default=0)


class PlayerSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BasePlayerStatsSerializer):
    """Season stats serializer"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()
    games_played = serializers.IntegerField()
    games_started = serializers.IntegerField()

    # Aggregated shooting stats
    total_shots = serializers.IntegerField(default=0)
    total_shots_on_target = serializers.IntegerField(default=0)
    total_goals = serializers.IntegerField(default=0)
    total_big_chances = serializers.IntegerField(default=0)

    # Aggregated passing stats
    total_passes = serializers.IntegerField(default=0)
    total_passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    total_key_passes = serializers.IntegerField(default=0)
    total_assists = serializers.IntegerField(default=0)

    # Aggregated defending stats
    total_tackles = serializers.IntegerField(default=0)
    total_interceptions = serializers.IntegerField(default=0)
    total_ball_recoveries = serializers.IntegerField(default=0)
    total_duels_won = serializers.IntegerField(default=0)

    # Per game averages
    avg_shots = serializers.FloatField(default=0.0)
    avg_passes = serializers.FloatField(default=0.0)
    avg_tackles = serializers.FloatField(default=0.0)

================
File: backend/sbapi/v1/serializers/stats/team_stats.py
================
from rest_framework import serializers
from ..base.match import TeamBasicSerializer
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BaseTeamStatsSerializer


class TeamMatchStatsSerializer(
        BaseMatchStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics for a specific match"""
    team = TeamBasicSerializer()
    manager_name = serializers.CharField()
    average_age = serializers.FloatField()

    # Event stats from 'possession' category
    possession = serializers.FloatField(
        source='event_stats.possession.possession_pct', default=0)
    touches = serializers.IntegerField(
        source='event_stats.possession.touches', default=0)
    possession_lost = serializers.IntegerField(
        source='event_stats.possession.possession_lost', default=0)

    # Event stats from 'shooting' category
    total_shots = serializers.IntegerField(
        source='event_stats.shooting.total_shots', default=0)
    shots_on_target = serializers.IntegerField(
        source='event_stats.shooting.shots_on_target', default=0)
    goals = serializers.IntegerField(
        source='event_stats.shooting.goals', default=0)
    big_chances = serializers.IntegerField(
        source='event_stats.shooting.big_chances', default=0)

    # Event stats from 'passing' category
    total_passes = serializers.IntegerField(
        source='event_stats.passing.total_passes', default=0)
    accurate_passes = serializers.IntegerField(
        source='event_stats.passing.accurate_passes', default=0)
    key_passes = serializers.IntegerField(
        source='event_stats.passing.key_passes', default=0)
    assists = serializers.IntegerField(
        source='event_stats.passing.assists', default=0)

    # Event stats from 'defending' category
    tackles_won = serializers.IntegerField(
        source='event_stats.defending.tackles_won', default=0)
    interceptions = serializers.IntegerField(
        source='event_stats.defending.interceptions', default=0)
    clearances = serializers.IntegerField(
        source='event_stats.defending.clearances', default=0)
    blocks = serializers.IntegerField(
        source='event_stats.defending.blocks', default=0)


class TeamSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics aggregated over a season"""
    team = TeamBasicSerializer()
    matches_played = serializers.IntegerField()
    goals_for = serializers.IntegerField()
    avg_possession = serializers.FloatField()
    avg_age = serializers.FloatField(allow_null=True)
    home_matches = serializers.IntegerField()
    away_matches = serializers.IntegerField()
    manager = serializers.CharField()
    formation = serializers.CharField()

================
File: backend/sbapi/v1/serializers/__init__.py
================
from .base.common import (
    BaseStatsSerializer,
    BaseMatchStatsSerializer,
    BaseSeasonStatsSerializer,
    BasePlayerStatsSerializer,
    BaseTeamStatsSerializer,
)
from .base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)
from .base.events import (
    BaseEventSerializer,
    get_event_serializer
)
from .base.match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)
from .stats.player_stats import (
    PlayerMatchStatsSerializer,
    PlayerSeasonStatsSerializer
)
from .stats.team_stats import (
    TeamMatchStatsSerializer,
    TeamSeasonStatsSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer',
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: backend/sbapi/v1/serializers/base.py
================
from rest_framework import serializers


class BaseSerializer(serializers.ModelSerializer):
    """Base serializer adding success wrapper"""

    def to_representation(self, instance):
        data = super().to_representation(instance)
        if isinstance(data, list):
            return {
                'status': 'success',
                'data': data,
                'message': None
            }
        return data


class HalModelSerializer(BaseSerializer):
    """Base serializer that adds HAL-style _links"""
    _links = serializers.SerializerMethodField('get__links')

    def get__links(self, obj):
        """Default empty implementation"""
        return {}

    def to_representation(self, instance):
        data = super().to_representation(instance)
        links = self.get__links(instance)
        if links:
            data['_links'] = links
        return data

================
File: backend/sbapi/v1/services/events/__init__.py
================
from .event_aggregator import EventAggregator

__all__ = ['EventAggregator']

================
File: backend/sbapi/v1/services/events/event_aggregator.py
================
from django.db.models import Count, Q, Sum, F
from sbapi.models.events import (
    ShootingEvent,
    PassEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent
)


class EventAggregator:
    """Service for aggregating and calculating event statistics"""

    def get_match_events(self, match_id, event_type=None):
        """Get events for a match with optional type filtering"""
        try:
            event_mapping = {
                'shooting': ShootingEvent,
                'passing': PassEvent,
                'defending': DefendingEvent,
                'goalkeeper': GoalkeeperEvent,
                'possession': PossessionEvent
            }

            if event_type:
                if event_type not in event_mapping:
                    return {'status': 'error', 'message': 'Invalid event type'}

                events = event_mapping[event_type].objects.filter(
                    match_id=match_id
                ).select_related('team', 'player')

                return {
                    'events': events,
                    'count': events.count(),
                    'status': 'success'
                }

            # If no type specified, return counts for each type
            return {
                'counts': {
                    event_type: model.objects.filter(
                        match_id=match_id
                    ).count()
                    for event_type, model in event_mapping.items()
                },
                'status': 'success'
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_team_match_events(self, match_id, team_id):
        """Aggregate all events for a team in a match"""
        try:
            event_stats = {
                'possession': self._get_possession_stats(match_id, team_id),
                'shooting': self._get_shooting_stats(match_id, team_id),
                'passing': self._get_passing_stats(match_id, team_id),
                'defending': self._get_defending_stats(match_id, team_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_player_match_events(self, match_id, player_id):
        """Aggregate all events for a player in a match"""
        try:
            event_stats = {
                'shooting': self._get_player_shooting_stats(match_id, player_id),
                'passing': self._get_player_passing_stats(match_id, player_id),
                'defending': self._get_player_defending_stats(match_id, player_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def _get_possession_stats(self, match_id, team_id):
        """Calculate possession-related stats"""
        return PossessionEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            touches=Count('touches', filter=Q(touches=True)),
            possession_lost=Count('dispossessed', filter=Q(dispossessed=True)),
            dribbles_won=Count('dribble_won', filter=Q(dribble_won=True)),
            dribbles_lost=Count('dribble_lost', filter=Q(dribble_lost=True))
        )

    def _get_shooting_stats(self, match_id, team_id):
        """Calculate shooting-related stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_passing_stats(self, match_id, team_id):
        """Calculate passing-related stats"""
        return PassEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_passes=Count('id'),
            accurate_passes=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True)),
            big_chances_created=Count(
                'big_chance_created', filter=Q(
                    big_chance_created=True))
        )

    def _get_defending_stats(self, match_id, team_id):
        """Calculate defending-related stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            tackles_won=Count('tackle_won', filter=Q(tackle_won=True)),
            interceptions=Count(
                'interception_won', filter=Q(
                    interception_won=True)),
            clearances=Count('is_clearance', filter=Q(is_clearance=True)),
            blocks=Count('outfielder_block', filter=Q(outfielder_block=True))
        )

    def _get_player_shooting_stats(self, match_id, player_id):
        """Calculate player shooting stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_player_passing_stats(self, match_id, player_id):
        """Calculate player passing stats"""
        stats = PassEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            passes_attempted=Count('id'),
            passes_completed=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True))
        )

        # Calculate pass accuracy if there were attempts
        if stats['passes_attempted'] > 0:
            stats['pass_accuracy'] = (
                stats['passes_completed'] / stats['passes_attempted']) * 100
        else:
            stats['pass_accuracy'] = 0

        return stats

    def _get_player_defending_stats(self, match_id, player_id):
        """Calculate player defending stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            tackles=Count('is_tackle', filter=Q(is_tackle=True)),
            interceptions=Count(
                'is_interception', filter=Q(
                    is_interception=True)),
            ball_recoveries=Count(
                'is_ball_recovery', filter=Q(
                    is_ball_recovery=True)),
            duels_won=Count('defensive_duel', filter=Q(defensive_duel=True))
        )

================
File: backend/sbapi/v1/services/player_analytics/__init__.py
================
from .base import BaseStatsService
from .passing import PassingStatsService
# Add other services as you create them:
# from .shooting import ShootingStatsService

__all__ = [
    'BaseStatsService',
    'PassingStatsService'
]

================
File: backend/sbapi/v1/services/player_analytics/base.py
================
from django.db.models import Count, Q


class BaseStatsService:
    """Base class for all stats services"""
    
    def get_match_events(self, match_id, player_id):
        """Get raw events for a player in a match"""
        queryset = self.get_base_queryset(match_id, player_id)
        return self.get_events_serializer()(queryset, many=True).data

    def get_base_queryset(self, match_id, player_id):
        """Get base queryset for events"""
        raise NotImplementedError
    
    def get_events_serializer(self):
        """Get serializer for events"""
        raise NotImplementedError

================
File: backend/sbapi/v1/services/player_analytics/passing.py
================
# services/stats.py
from django.db.models import Count, Q
from sbapi.models.events import PassEvent
from ...serializers.match_events.passing import DetailedPassEventSerializer
from .base import BaseStatsService

class PassingStatsService(BaseStatsService):
    """Service for calculating passing statistics"""
    
    def get_base_queryset(self, match_id, player_id):
        return PassEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).select_related('team', 'player')
    
    def get_events_serializer(self):
        return DetailedPassEventSerializer
    
    def get_player_match_stats(self, match_id, player_id):
        """Get aggregated pass stats for a match"""
        try:
            queryset = self.get_base_queryset(match_id, player_id)
            
            if not queryset.exists():
                return {
                    'status': 'error',
                    'message': f'No passing events found for player {player_id} in match {match_id}'
                }
            
            # Calculate basic stats
            basic_stats = queryset.aggregate(
                total_passes=Count('id'),
                accurate_passes=Count('id', filter=Q(pass_accurate=True)),
                assists=Count('id', filter=Q(assist=True)),
                key_passes=Count('id', filter=Q(pass_key=True)),
                big_chances=Count('id', filter=Q(big_chance_created=True))
            )
            
            # Pass types
            pass_types = queryset.aggregate(
                corners=Count('id', filter=Q(pass_corner=True)),
                crosses_accurate=Count('id', filter=Q(pass_cross_accurate=True)),
                crosses_inaccurate=Count('id', filter=Q(pass_cross_inaccurate=True)),
                through_balls_accurate=Count('id', filter=Q(pass_through_ball_accurate=True)),
                through_balls_inaccurate=Count('id', filter=Q(pass_through_ball_inaccurate=True))
            )
            
            # Calculate percentages
            total_passes = basic_stats['total_passes']
            
            return {
                'status': 'success',
                'stats': {
                    'basic': {
                        'total_passes': total_passes,
                        'accurate_passes': basic_stats['accurate_passes'],
                        'pass_accuracy': self._calculate_percentage(
                            basic_stats['accurate_passes'], 
                            total_passes
                        ),
                        'assists': basic_stats['assists'],
                        'key_passes': basic_stats['key_passes'],
                        'big_chances_created': basic_stats['big_chances']
                    },
                    'types': {
                        'corners': pass_types['corners'],
                        'crosses': {
                            'total': pass_types['crosses_accurate'] + pass_types['crosses_inaccurate'],
                            'accurate': pass_types['crosses_accurate'],
                            'accuracy': self._calculate_percentage(
                                pass_types['crosses_accurate'],
                                pass_types['crosses_accurate'] + pass_types['crosses_inaccurate']
                            )
                        },
                        'through_balls': {
                            'total': pass_types['through_balls_accurate'] + pass_types['through_balls_inaccurate'],
                            'accurate': pass_types['through_balls_accurate'],
                            'accuracy': self._calculate_percentage(
                                pass_types['through_balls_accurate'],
                                pass_types['through_balls_accurate'] + pass_types['through_balls_inaccurate']
                            )
                        }
                    }
                }
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def get_player_season_stats(self, competition_id, season_id, player_id):
        """Get season aggregated stats"""
        try:
            from sbapi.models import Match
            
            # Get all matches for the player in this season
            matches = Match.objects.filter(
                season__competition_id=competition_id,
                season_id=season_id,
                matchplayer__player_id=player_id
            ).values_list('id', flat=True)
            
            if not matches:
                return {
                    'status': 'error',
                    'message': f'No matches found for player {player_id} in season {season_id}'
                }
            
            # Get all passing events for these matches
            events = PassEvent.objects.filter(
                match_id__in=matches,
                player_id=player_id
            )
            
            # Calculate totals
            totals = events.aggregate(
                total_passes=Count('id'),
                accurate_passes=Count('id', filter=Q(pass_accurate=True)),
                assists=Count('id', filter=Q(assist=True)),
                key_passes=Count('id', filter=Q(pass_key=True)),
                big_chances=Count('id', filter=Q(big_chance_created=True))
            )
            
            matches_played = len(matches)
            
            return {
                'status': 'success',
                'stats': {
                    'matches_played': matches_played,
                    'totals': {
                        'passes': totals['total_passes'],
                        'accurate_passes': totals['accurate_passes'],
                        'pass_accuracy': self._calculate_percentage(
                            totals['accurate_passes'],
                            totals['total_passes']
                        ),
                        'assists': totals['assists'],
                        'key_passes': totals['key_passes'],
                        'big_chances_created': totals['big_chances']
                    },
                    'per_90': {
                        'passes': self._calculate_per_90(
                            totals['total_passes'], 
                            matches_played
                        ),
                        'key_passes': self._calculate_per_90(
                            totals['key_passes'],
                            matches_played
                        ),
                        'assists': self._calculate_per_90(
                            totals['assists'],
                            matches_played
                        )
                    }
                }
            }
            
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }
    
    def _calculate_percentage(self, part, total):
        """Calculate percentage with zero handling"""
        return round((part / total * 100) if total > 0 else 0, 2)
    
    def _calculate_per_90(self, value, matches):
        """Calculate per 90 minutes value"""
        return round((value / matches) * 90, 2)

================
File: backend/sbapi/v1/services/stats/__init__.py
================
from .player_stats import PlayerStatsService
from .team_stats import TeamStatsService

__all__ = [
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: backend/sbapi/v1/services/stats/player_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from sbapi.models import (
    ShootingEvent,
    PassEvent,
    DefendingEvent
)
from ..events.event_aggregator import EventAggregator

from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from ..events.event_aggregator import EventAggregator


class PlayerStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, player_id):
        """Calculate detailed player stats for a specific match"""
        try:
            # Get basic match player info
            match_player = MatchPlayer.objects.get(
                match_id=match_id,
                player_id=player_id
            )

            # Get event-based stats
            event_stats = self.event_aggregator.get_player_match_events(
                match_id,
                player_id
            )

            if event_stats['status'] == 'error':
                return event_stats

            return {
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except MatchPlayer.DoesNotExist:
            return {
                'status': 'error',
                'message': f'No stats found for player {player_id} in match {match_id}'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, player_id):
        """Calculate player stats for entire season"""
        try:
            # Get all matches for player in season
            matches = MatchPlayer.objects.filter(
                match__season__competition_id=competition_id,
                match__season_id=season_id,
                player_id=player_id
            ).select_related(
                'match',
                'player',
                'team'
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No stats found for player {player_id} in season {season_id}'
                }

            # Get latest match for player info
            latest_match = matches.order_by('-match__start_datetime').first()
            games_played = matches.count()

            # Get event stats for all matches
            match_ids = list(matches.values_list('match_id', flat=True))

            # Initialize totals
            totals = {
                'total_shots': 0,
                'total_shots_on_target': 0,
                'total_goals': 0,
                'total_big_chances': 0,
                'total_passes': 0,
                'total_passes_completed': 0,
                'total_key_passes': 0,
                'total_assists': 0,
                'total_tackles': 0,
                'total_interceptions': 0,
                'total_ball_recoveries': 0,
                'total_duels_won': 0
            }

            # Calculate totals across all matches
            for match_id in match_ids:
                match_stats = self.event_aggregator.get_player_match_events(
                    match_id, player_id)
                if match_stats['status'] == 'success':
                    # Add shooting stats
                    shooting = match_stats['stats']['shooting']
                    totals['total_shots'] += shooting.get('shots', 0)
                    totals['total_shots_on_target'] += shooting.get(
                        'shots_on_target', 0)
                    totals['total_goals'] += shooting.get('goals', 0)
                    totals['total_big_chances'] += shooting.get(
                        'big_chances', 0)

                    # Add passing stats
                    passing = match_stats['stats']['passing']
                    totals['total_passes'] += passing.get(
                        'passes_attempted', 0)
                    totals['total_passes_completed'] += passing.get(
                        'passes_completed', 0)
                    totals['total_key_passes'] += passing.get('key_passes', 0)
                    totals['total_assists'] += passing.get('assists', 0)

                    # Add defending stats
                    defending = match_stats['stats']['defending']
                    totals['total_tackles'] += defending.get('tackles', 0)
                    totals['total_interceptions'] += defending.get(
                        'interceptions', 0)
                    totals['total_ball_recoveries'] += defending.get(
                        'ball_recoveries', 0)
                    totals['total_duels_won'] += defending.get('duels_won', 0)

            # Calculate averages
            stats = {
                # Basic info
                'player_name': latest_match.player.name,
                'team_name': latest_match.team.name,
                'position': latest_match.position,
                'games_played': games_played,
                'games_started': matches.filter(is_first_eleven=True).count(),

                # Add all totals
                **totals,

                # Calculate overall pass accuracy
                'pass_accuracy': (
                    (totals['total_passes_completed'] /
                     totals['total_passes'] * 100)
                    if totals['total_passes'] > 0 else 0
                ),

                # Calculate per game averages
                'avg_shots': totals['total_shots'] / games_played if games_played > 0 else 0,
                'avg_passes': totals['total_passes'] / games_played if games_played > 0 else 0,
                'avg_tackles': totals['total_tackles'] / games_played if games_played > 0 else 0
            }

            return {
                'status': 'success',
                'stats': stats
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: backend/sbapi/v1/services/stats/team_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q, Case, When, FloatField
from django.db.models.functions import Cast
from sbapi.models import Team, Match
from ..events.event_aggregator import EventAggregator


class TeamStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, team_id):
        """Calculate detailed team stats for a match"""
        try:
            # Get base match info
            match = Match.objects.select_related(
                'home_team',
                'away_team'
            ).get(match_id=match_id)

            # Verify team participated in match
            if team_id not in [match.home_team_id, match.away_team_id]:
                return {
                    'status': 'error',
                    'message': f'Team {team_id} did not participate in match {match_id}'
                }

            # Add team context for serializer
            match.team = match.home_team if match.home_team_id == team_id else match.away_team

            # Get event-based stats
            event_stats = self.event_aggregator.get_team_match_events(
                match_id, team_id)

            if event_stats['status'] == 'error':
                return event_stats

            # Calculate possession percentage if not already included
            if 'possession' not in event_stats['stats']:
                total_touches = event_stats['stats']['possession'].get(
                    'touches', 0)
                opponent_id = match.away_team_id if team_id == match.home_team_id else match.home_team_id
                opponent_stats = self.event_aggregator.get_team_match_events(
                    match_id, opponent_id)
                if opponent_stats['status'] == 'success':
                    opponent_touches = opponent_stats['stats']['possession'].get(
                        'touches', 0)
                    if total_touches + opponent_touches > 0:
                        possession_pct = (
                            total_touches / (total_touches + opponent_touches)) * 100
                        event_stats['stats']['possession']['possession_pct'] = round(
                            possession_pct, 1)
                    else:
                        event_stats['stats']['possession']['possession_pct'] = 0

            # Calculate pass accuracy if not already included
            if 'pass_accuracy' not in event_stats['stats'].get('passing', {}):
                total_passes = event_stats['stats']['passing'].get(
                    'total_passes', 0)
                accurate_passes = event_stats['stats']['passing'].get(
                    'accurate_passes', 0)
                if total_passes > 0:
                    pass_accuracy = (accurate_passes / total_passes) * 100
                    event_stats['stats']['passing']['pass_accuracy'] = round(
                        pass_accuracy, 1)
                else:
                    event_stats['stats']['passing']['pass_accuracy'] = 0

            return {
                'match': match,
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except Match.DoesNotExist:
            return {
                'status': 'error',
                'message': f'Match {match_id} not found'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, team_id):
        """Calculate season aggregated stats for a team"""
        try:
            # Get all matches for the team in this season
            matches = (
                Match.objects
                .filter(
                    Q(home_team_id=team_id) | Q(away_team_id=team_id),
                    season__competition_id=competition_id,
                    season_id=season_id
                )
                .select_related('home_team', 'away_team', 'season')
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No matches found for team {team_id} in season {season_id}'
                }

            # Get team info from first match
            first_match = matches.first()
            team = first_match.home_team if first_match.home_team_id == team_id else first_match.away_team
            match_count = matches.count()

            # Initialize aggregated stats with properly formatted team dict
            stats = {
                'team': {
                    'team_id': team.team_id,  # Changed from id to team_id
                    'name': team.name,
                    'country': team.country
                },
                'matches_played': match_count,
                'home_matches': matches.filter(home_team_id=team_id).count(),
                'away_matches': matches.filter(away_team_id=team_id).count(),
                'avg_possession': 0,
                'total_shots': 0,
                'shots_on_target': 0,
                'goals_for': 0,
                'total_passes': 0,
                'accurate_passes': 0,
                'key_passes': 0,
                'assists': 0,
                'tackles_won': 0,
                'interceptions': 0,
                'clearances': 0
            }

        # Rest of the method remains the same...

            # Calculate goals
            goals = matches.aggregate(
                goals_for=Sum(Case(
                    When(home_team_id=team_id, then='home_score_ft'),
                    When(away_team_id=team_id, then='away_score_ft'),
                    default=0,
                    output_field=FloatField()
                ))
            )
            stats['goals_for'] = goals['goals_for'] or 0

            # Calculate average age
            ages = matches.aggregate(
                avg_age=Avg(Case(
                    When(home_team_id=team_id, then='home_team_average_age'),
                    When(away_team_id=team_id, then='away_team_average_age'),
                    default=None,
                    output_field=FloatField()
                ))
            )
            stats['avg_age'] = round(
                ages['avg_age'], 1) if ages['avg_age'] else None

            # Get latest match info
            latest_match = matches.order_by('-start_datetime').first()
            if latest_match:
                stats['manager'] = (
                    latest_match.home_manager_name
                    if latest_match.home_team_id == team_id
                    else latest_match.away_manager_name
                )

                latest_formation = latest_match.formation_set.filter(
                    team_id=team_id
                ).order_by('-start_minute').first()

                stats['formation'] = latest_formation.formation_name if latest_formation else 'Unknown'

                # Aggregate event stats from all matches
                total_possession = 0
                for match in matches:
                    event_stats = self.event_aggregator.get_team_match_events(
                        match.match_id,
                        team_id
                    )
                    if event_stats['status'] == 'success':
                        # Add up possession %
                        possession = event_stats['stats']['possession'].get(
                            'possession_pct', 0)
                        total_possession += possession

                        # Add up other stats
                        shooting = event_stats['stats']['shooting']
                        stats['total_shots'] += shooting.get('total_shots', 0)
                        stats['shots_on_target'] += shooting.get(
                            'shots_on_target', 0)

                        passing = event_stats['stats']['passing']
                        stats['total_passes'] += passing.get('total_passes', 0)
                        stats['accurate_passes'] += passing.get(
                            'accurate_passes', 0)
                        stats['key_passes'] += passing.get('key_passes', 0)
                        stats['assists'] += passing.get('assists', 0)

                        defending = event_stats['stats']['defending']
                        stats['tackles_won'] += defending.get('tackles_won', 0)
                        stats['interceptions'] += defending.get(
                            'interceptions', 0)
                        stats['clearances'] += defending.get('clearances', 0)

                # Calculate averages
                if match_count > 0:
                    stats['avg_possession'] = round(
                        total_possession / match_count, 1)
                    stats['avg_shots'] = round(
                        stats['total_shots'] / match_count, 1)
                    stats['avg_passes'] = round(
                        stats['total_passes'] / match_count, 1)

                # Calculate pass accuracy
                if stats['total_passes'] > 0:
                    stats['pass_accuracy'] = round(
                        (stats['accurate_passes'] /
                         stats['total_passes']) * 100,
                        1
                    )
                else:
                    stats['pass_accuracy'] = 0

            return {
                'stats': stats,
                'status': 'success'
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: backend/sbapi/v1/services/__init__.py
================
from .events.event_aggregator import EventAggregator
from .stats.player_stats import PlayerStatsService
from .stats.team_stats import TeamStatsService

__all__ = [
    'EventAggregator',
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: backend/sbapi/v1/views/base/__init__.py
================
from .base import BaseViewSet
from .competition import CompetitionViewSet, CompetitionSeasonsView
from .events import MatchEventsViewSet, EventTypeView
from .match import MatchViewSet

__all__ = [
    'BaseViewSet',
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet'
]

================
File: backend/sbapi/v1/views/base/base.py
================
from rest_framework import viewsets
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound


class BaseViewSet(viewsets.ReadOnlyModelViewSet):
    """Base ViewSet adding success wrapper and lookup field configuration"""

    # Use match_id/competition_id instead of pk where appropriate
    lookup_field = 'pk'  # Override in child classes if needed

    def get_object(self):
        try:
            queryset = self.filter_queryset(self.get_queryset())

            lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
            lookup_value = self.kwargs.get(
                lookup_url_kwarg) or self.kwargs.get('pk')

            if not lookup_value:
                return None

            filter_kwargs = {self.lookup_field: lookup_value}
            obj = queryset.get(**filter_kwargs)

            self.check_object_permissions(self.request, obj)
            return obj
        except (self.queryset.model.DoesNotExist, ValidationError):
            raise NotFound(f"{self.queryset.model.__name__} not found")
        except Exception as e:
            raise ValidationError(f"Error retrieving object: {str(e)}")

    def get_response(self, data):
        """Wrap response in success format"""
        if isinstance(data, list) or (
                isinstance(data, dict) and 'results' in data):
            return Response({
                'status': 'success',
                'data': data,
                'message': None
            })
        # Individual objects already wrapped by serializer
        return Response(data)

    def list(self, request, *args, **kwargs):
        response = super().list(request, *args, **kwargs)
        return self.get_response(response.data)

    def retrieve(self, request, *args, **kwargs):
        response = super().retrieve(request, *args, **kwargs)
        return self.get_response(response.data)

================
File: backend/sbapi/v1/views/base/competition.py
================
from rest_framework import viewsets, generics
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .base import BaseViewSet
from ....models import Competition, Season
from ...serializers.base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)


class CompetitionViewSet(BaseViewSet):
    """API endpoint for viewing competitions"""
    queryset = Competition.objects.all()
    lookup_field = 'competition_id'
    lookup_url_kwarg = 'competition_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return CompetitionListSerializer
        return CompetitionDetailSerializer


class CompetitionSeasonsView(generics.ListAPIView):
    """API endpoint for viewing seasons of a competition"""
    serializer_class = SeasonSerializer

    def get_queryset(self):
        competition_id = self.kwargs['competition_id']
        return Season.objects.filter(competition_id=competition_id)

================
File: backend/sbapi/v1/views/base/events.py
================
from rest_framework import viewsets, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from django.db.models import Count, Q
from itertools import chain

from ..base.base import BaseViewSet

from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)

from ...serializers.base.events import (
    BaseEventSerializer,
    get_event_serializer,
    EVENT_TYPE_SERIALIZERS
)

EVENT_TYPE_MODELS = {
    'defending': DefendingEvent,
    'goalkeeper': GoalkeeperEvent,
    'passing': PassEvent,
    'possession': PossessionEvent,
    'shooting': ShootingEvent,
    'summary': SummaryEvent,
}


class MatchEventsViewSet(BaseViewSet):
    """ViewSet for handling all match events"""
    serializer_class = BaseEventSerializer

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.request.query_params.get('type', None)

        if not match_id:
            raise ValidationError("Match ID is required")

        # If specific event type requested
        if event_type and event_type.lower() in EVENT_TYPE_MODELS:
            model = EVENT_TYPE_MODELS[event_type.lower()]
            return model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            ).order_by('minute', 'second')

        # If no specific type, combine all event types
        all_events = []
        for model in EVENT_TYPE_MODELS.values():
            events = model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            )
            all_events.append(events)

        # Handle None values by defaulting to 0 during sorting
        def sort_key(x):
            return (x.minute, x.second if x.second is not None else 0)

        combined_events = sorted(chain(*all_events), key=sort_key)

        return combined_events

    def get_serializer_class(self):
        event_type = self.request.query_params.get('type')
        if event_type and event_type.lower() in EVENT_TYPE_SERIALIZERS:
            return EVENT_TYPE_SERIALIZERS[event_type.lower()]
        return BaseEventSerializer

    @action(detail=False, methods=['get'])
    def stats(self, request, match_id=None):
        """Get aggregated stats for match events"""
        stats = {
            'total_events': 0,
            'by_type': {},
            'by_team': {},
            'by_period': {
                'FirstHalf': 0,
                'SecondHalf': 0
            }
        }

        # Aggregate stats across all event types
        for event_type, model in EVENT_TYPE_MODELS.items():
            events = model.objects.filter(match_id=match_id)
            event_count = events.count()
            stats['total_events'] += event_count

            # Stats by event type
            stats['by_type'][event_type] = event_count

            # Stats by period
            first_half = events.filter(period='FirstHalf').count()
            second_half = events.filter(period='SecondHalf').count()
            stats['by_period']['FirstHalf'] += first_half
            stats['by_period']['SecondHalf'] += second_half

            # Stats by team
            team_counts = events.values(
                'team__name'
            ).annotate(
                count=Count('id')
            )

            for team in team_counts:
                team_name = team['team__name']
                if team_name not in stats['by_team']:
                    stats['by_team'][team_name] = 0
                stats['by_team'][team_name] += team['count']

        return Response({
            'status': 'success',
            'data': stats,
            'message': None
        })


class EventTypeView(generics.ListAPIView):
    """View for handling specific event types for a match"""

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.kwargs.get('event_type', '').lower()

        if event_type not in EVENT_TYPE_MODELS:
            raise ValidationError(f"Invalid event type: {event_type}")

        model = EVENT_TYPE_MODELS[event_type]
        return model.objects.filter(
            match_id=match_id
        ).select_related(
            'team',
            'player'
        ).order_by('minute', 'second')

    def get_serializer_class(self):
        event_type = self.kwargs.get('event_type', '').lower()
        return get_event_serializer(event_type)

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: backend/sbapi/v1/views/base/match.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Q, Prefetch
from django.shortcuts import get_object_or_404
from sbapi.models import Match, MatchPlayer, Formation, SummaryEvent
from ...serializers.base.match import (
    MatchListSerializer,
    MatchDetailSerializer,
    LineupResponseSerializer
)
from .base import BaseViewSet


class MatchViewSet(BaseViewSet):
    """ViewSet for managing match data."""
    lookup_field = 'match_id'
    lookup_url_kwarg = 'match_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return MatchListSerializer
        return MatchDetailSerializer

    def get_queryset(self):
        """Retrieve matches with relevant data."""
        queryset = Match.objects.select_related(
            'home_team',
            'away_team',
            'season',
            'season__competition'
        )

        if self.action == 'lineups':
            queryset = queryset.prefetch_related(
                Prefetch(
                    'formation_set',
                    queryset=Formation.objects.select_related(
                        'team').order_by('start_minute')
                ),
                Prefetch(
                    'matchplayer_set',
                    queryset=MatchPlayer.objects.select_related(
                        'player', 'team')
                )
            )

        # Get query parameters
        competition_id = self.request.query_params.get('competition_id')
        season_id = self.request.query_params.get('season_id')

        if competition_id and season_id:
            queryset = queryset.filter(
                season__competition_id=competition_id,
                season_id=season_id
            )

        return queryset.order_by('-start_datetime')

    @action(detail=True, methods=['get'], url_path='lineups')
    def lineups(self, request, **kwargs):
        """Retrieve detailed lineup information."""
        match = self.get_object()

        # Retrieve formations
        home_formations = Formation.objects.filter(
            match=match,
            team=match.home_team
        ).order_by('start_minute')

        away_formations = Formation.objects.filter(
            match=match,
            team=match.away_team
        ).order_by('start_minute')

        # Retrieve starting lineups
        home_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.home_team,
            is_first_eleven=True
        ).select_related('player')

        away_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.away_team,
            is_first_eleven=True
        ).select_related('player')

        # Retrieve substitutions
        substitutions = (
            SummaryEvent.objects.filter(
                Q(sub_on=True) | Q(sub_off=True),
                match=match
            )
            .select_related('team')
            .order_by('minute')
        )

        # Organize substitutions by team
        home_subs = []
        away_subs = []
        for sub in substitutions:
            sub_data = {
                'minute': sub.minute,
                'player': sub.player_name,
                'type': 'on' if sub.sub_on else 'off'
            }
            if sub.team_id == match.home_team_id:
                home_subs.append(sub_data)
            else:
                away_subs.append(sub_data)

        # Prepare response data
        response_data = {
            'home_team': {
                'team': match.home_team,
                'starting_formation': home_formations.first().formation_name if home_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in home_formations[1:]
                ],
                'starting_lineup': home_starters,
                'substitutions': home_subs
            },
            'away_team': {
                'team': match.away_team,
                'starting_formation': away_formations.first().formation_name if away_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in away_formations[1:]
                ],
                'starting_lineup': away_starters,
                'substitutions': away_subs
            }
        }

        serializer = LineupResponseSerializer(response_data)
        return Response({
            'status': 'success',
            'data': serializer.data,
            'message': None
        })

================
File: backend/sbapi/v1/views/player_analytics/match_events.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base import BaseViewSet
from ...services.player_analytics.passing import PassingStatsService

class EventsViewSet(BaseViewSet):
    """ViewSet for raw event data"""

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.passing_service = PassingStatsService()
        # Will add other services as needed:
        # self.shooting_service = ShootingStatsService()

    @action(detail=True, methods=['get'])
    def player_events(self, request, match_id, player_id):
        """Get all events for a player in a match"""
        try:
            events = self.passing_service.get_match_events(match_id, player_id)
            if events['status'] == 'error':
                raise NotFound(events['message'])
            
            return self.get_response(events['data'])
            
        except Exception as e:
            raise ValidationError(str(e))

================
File: backend/sbapi/v1/views/player_analytics/match.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import MatchPlayer, Season
from ...services.player_analytics.passing import PassingStatsService

class PlayerStatsViewSet(BaseViewSet):
    """ViewSet for player statistics"""
    passing_stats_service = PassingStatsService()
    # Add other services as needed:
    # shooting_stats_service = ShootingStatsService()
    
    @action(detail=True, methods=['get'])
    def match_stats(self, request, *args, **kwargs):
        """Get player stats for a specific match"""
        match_id = kwargs.get('match_id')
        player_id = kwargs.get('player_id')

        # Get event stats first
        stats_result = self.passing_stats_service.get_player_match_stats(
            match_id, player_id)

        if stats_result['status'] == 'error':
            raise NotFound(stats_result['message'])

        # Get match player info
        match_player = get_object_or_404(
            MatchPlayer.objects.select_related('player', 'team', 'match'),
            match_id=match_id,
            player_id=player_id
        )

        # Create data dictionary combining match player info and event stats
        all_stats = {
            'player_name': match_player.player.name,
            'team_name': match_player.team.name,
            'match_date': match_player.match.start_datetime,
            'position': match_player.position,
            'shirt_no': match_player.shirt_no,
            'is_first_eleven': match_player.is_first_eleven,
            'passing': stats_result['stats']
            # Add other event types as you create them:
            # 'shooting': shooting_result['stats']
        }

        return self.get_response(all_stats)

    @action(detail=True, methods=['get'])
    def season_stats(self, request, *args, **kwargs):
        """Get player stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        player_id = kwargs.get('player_id')

        result = self.passing_stats_service.get_player_season_stats(
            competition_id,
            season_id,
            player_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        stats_data = {
            'competition_name': season.competition.name,
            'season_name': season.name,
            'passing': result['stats']
            # Add other event types as you create them:
            # 'shooting': shooting_result['stats']
        }

        return self.get_response(stats_data)

================
File: backend/sbapi/v1/views/stats/__init__.py
================
from .player_stats import PlayerStatsViewSet
from .team_stats import TeamStatsViewSet

__all__ = [
    'PlayerStatsViewSet',
    'TeamStatsViewSet'
]

================
File: backend/sbapi/v1/views/stats/player_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import MatchPlayer, Season
from ...serializers.stats.player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from ...services.stats.player_stats import PlayerStatsService


class PlayerStatsViewSet(BaseViewSet):
    """ViewSet for player statistics"""
    player_stats_service = PlayerStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get player stats for a specific match"""
        match_id = kwargs.get('match_id')
        player_id = kwargs.get('player_id')

        # Get event stats first
        stats_result = self.player_stats_service.calculate_match_stats(
            match_id, player_id)

        if stats_result['status'] == 'error':
            raise NotFound(stats_result['message'])

        # Get match player info
        match_player = get_object_or_404(
            MatchPlayer.objects.select_related('player', 'team', 'match'),
            match_id=match_id,
            player_id=player_id
        )

        # Create data dictionary combining match player info and event stats
        all_stats = {
            'player_name': match_player.player.name,
            'team_name': match_player.team.name,
            'match_date': match_player.match.start_datetime,
            'position': match_player.position,
            'shirt_no': match_player.shirt_no,
            'is_first_eleven': match_player.is_first_eleven,
            **stats_result['event_stats']['shooting'],
            **stats_result['event_stats']['passing'],
            **stats_result['event_stats']['defending']
        }

        serializer = PlayerMatchStatsSerializer(all_stats)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get player stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        player_id = kwargs.get('player_id')

        result = self.player_stats_service.calculate_season_stats(
            competition_id,
            season_id,
            player_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = PlayerSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)
        return Response(serializer.data)

================
File: backend/sbapi/v1/views/stats/team_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import Season
from ...serializers.stats.team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer
from ...services.stats.team_stats import TeamStatsService


class TeamStatsViewSet(BaseViewSet):
    """ViewSet for team statistics"""
    team_stats_service = TeamStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get team stats for a specific match"""
        match_id = kwargs.get('match_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_match_stats(
            match_id, team_id)

        if result['status'] == 'error':
            raise NotFound(result['message'])

        match = result['match']
        # Determine if team is home or away
        is_home = match.home_team_id == team_id

        match_data = {
            'team': match.home_team if is_home else match.away_team,
            'manager_name': match.home_manager_name if is_home else match.away_manager_name,
            'average_age': match.home_team_average_age if is_home else match.away_team_average_age,
            'event_stats': result['event_stats']
        }

        serializer = TeamMatchStatsSerializer(match_data)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get team stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_season_stats(
            competition_id=competition_id,
            season_id=season_id,
            team_id=team_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = TeamSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)

        return Response(serializer.data)

================
File: backend/sbapi/v1/views/__init__.py
================
from .base.competition import CompetitionViewSet, CompetitionSeasonsView
from .base.events import MatchEventsViewSet, EventTypeView
from .base.match import MatchViewSet
from .stats.player_stats import PlayerStatsViewSet
from .stats.team_stats import TeamStatsViewSet

__all__ = [
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet',
    'PlayerStatsViewSet',
    'TeamStatsViewSet',
]

================
File: backend/sbapi/v1/urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views.base.competition import CompetitionViewSet, CompetitionSeasonsView
from .views.base.match import MatchViewSet
from .views.base.events import MatchEventsViewSet, EventTypeView
from .views.stats.player_stats import PlayerStatsViewSet
from .views.stats.team_stats import TeamStatsViewSet

# Create router for viewsets
router = DefaultRouter()
router.register(r'competitions', CompetitionViewSet, basename='competition')
router.register(r'matches', MatchViewSet, basename='match')

urlpatterns = [
    # Include router URLs
    path('', include(router.urls)),

    # Competition and season routes
    path('competitions/<int:competition_id>/seasons/',
         CompetitionSeasonsView.as_view()),  # ALL COMPS
    path('competitions/<int:competition_id>/seasons/<int:season_id>/', include([  # ALL SEASONS OF A COMP
        path('stats/players/<int:player_id>/',
             PlayerStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A PLAYER
        path('stats/teams/<int:team_id>/',
             TeamStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A TEAM
    ])),

    # Match routes
    path('matches/<int:match_id>/', include([
        # Match events
        path('events/', MatchEventsViewSet.as_view({'get': 'list'})),
        path('events/stats/', MatchEventsViewSet.as_view({'get': 'stats'})),
        path('events/<str:event_type>/', EventTypeView.as_view()),

        # Match stats
        path('stats/', include([
            path('players/<int:player_id>/',
                 PlayerStatsViewSet.as_view({'get': 'get_match_stats'})),
            path('teams/<int:team_id>/',
                 TeamStatsViewSet.as_view({'get': 'get_match_stats'})),
        ])),

        # Match lineups
        path('lineups/', MatchViewSet.as_view({'get': 'lineups'})),
    ])),
]

================
File: backend/sbapi/v1/utils.py
================
from rest_framework.views import exception_handler
from rest_framework.response import Response


def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)

    if response is not None:
        response.data = {
            'status': 'error',
            'message': str(exc),
            'data': response.data
        }

    return response

================
File: backend/sbapi/admin.py
================
from django.contrib import admin
from django.db.models import Count, Q
from .models import (
    Competition,
    Season,
    Team,
    Player,
    Match,
    Formation,
    MatchPlayer,
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)


@admin.register(Competition)
class CompetitionAdmin(admin.ModelAdmin):
    list_display = ('competition_id', 'name', 'country', 'get_seasons',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('country',)
    search_fields = ('name', 'country')

    def get_seasons(self, obj):
        return ", ".join([season.name for season in obj.season_set.all()])
    get_seasons.short_description = 'Seasons'

    def get_match_count(self, obj):
        return obj.season_set.aggregate(
            match_count=Count('match')
        )['match_count']
    get_match_count.short_description = 'Matches'


@admin.register(Season)
class SeasonAdmin(admin.ModelAdmin):
    list_display = ('season_id', 'name', 'competition', 'is_current',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('competition', 'is_current')
    search_fields = ('name', 'competition__name')

    def get_match_count(self, obj):
        return obj.match_set.count()
    get_match_count.short_description = 'Matches'


@admin.register(Team)
class TeamAdmin(admin.ModelAdmin):
    list_display = ('team_id', 'name', 'country')
    list_filter = ('country',)
    search_fields = ('name', 'country')
    list_per_page = 50


@admin.register(Player)
class PlayerAdmin(admin.ModelAdmin):
    list_display = ('player_id', 'name', 'get_matches_played')
    search_fields = ('name',)
    list_filter = ('matchplayer__team',)
    list_per_page = 50

    def get_matches_played(self, obj):
        return obj.matchplayer_set.count()
    get_matches_played.short_description = 'Matches Played'


@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('match_id', 'season', 'competition', 'start_datetime', 'home_team',
                    'score', 'away_team', 'venue', 'attendance', 'referee_name')
    list_filter = ('season__competition', 'season', 'start_datetime')
    search_fields = ('home_team__name', 'away_team__name', 'venue',
                     'season__competition__name', 'season__name')
    date_hierarchy = 'start_datetime'
    raw_id_fields = ('home_team', 'away_team', 'season')
    list_per_page = 50


@admin.register(Formation)
class FormationAdmin(admin.ModelAdmin):
    list_display = (
        'match',
        'team',
        'formation_name',
        'start_minute',
        'end_minute')
    list_filter = ('formation_name',)
    search_fields = (
        'match__home_team__name',
        'match__away_team__name',
        'team__name',
        'formation_name')
    list_per_page = 50


@admin.register(MatchPlayer)
class MatchPlayerAdmin(admin.ModelAdmin):
    list_display = ('match', 'player', 'team', 'position', 'is_first_eleven',
                    'is_man_of_match')
    list_filter = ('position', 'is_first_eleven', 'is_man_of_match')
    search_fields = ('player__name', 'team__name')
    raw_id_fields = ('match', 'player', 'team')
    list_per_page = 50

# Base Event Admin


class BaseEventAdmin(admin.ModelAdmin):
    list_display = ('id', 'match', 'team', 'player_name', 'minute', 'x', 'y', 'type',
                    'outcome_type', 'situation')
    list_filter = ('type', 'period', 'outcome_type', 'situation')
    search_fields = ('player_name', 'team__name')
    date_hierarchy = 'match__start_datetime'
    raw_id_fields = ('match', 'team', 'player')
    ordering = ('-match__start_datetime', 'minute')
    list_per_page = 50


@admin.register(PassEvent)
class PassEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('pass_accurate', 'assist', 'pass_key')
    list_filter = BaseEventAdmin.list_filter + (
        'pass_accurate', 'assist', 'pass_key', 'big_chance_created'
    )


@admin.register(ShootingEvent)
class ShootingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('is_goal', 'shot_on_target',
                                                  'big_chance_missed')
    list_filter = BaseEventAdmin.list_filter + (
        'is_goal', 'shot_on_target', 'big_chance_missed', 'penalty_scored'
    )


@admin.register(DefendingEvent)
class DefendingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('duel_aerial_won', 'tackle_won', 'interception_won', 'aerial_success',
                                                  'offensive_duel', 'defensive_duel')
    list_filter = BaseEventAdmin.list_filter + (
        'tackle_won', 'interception_won', 'duel_aerial_won', 'offensive_duel', 'defensive_duel', 'goal_own',
    )


@admin.register(GoalkeeperEvent)
class GoalkeeperEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )
    list_filter = BaseEventAdmin.list_filter + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )

    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'match',
            'team',
            'player'  # Changed from player__matchplayer
        ).prefetch_related(
            'player__matchplayer_set'  # Added prefetch_related for MatchPlayer
        )


@admin.register(PossessionEvent)
class PossessionEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('dispossessed', 'dribble_won',
                                                  'turnover')
    list_filter = BaseEventAdmin.list_filter + (
        'dispossessed', 'dribble_won', 'turnover'
    )


@admin.register(SummaryEvent)
class SummaryEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('card_type', 'sub_on', 'sub_off', 'foul_committed')
    list_filter = BaseEventAdmin.list_filter + \
        ('card_type',
         'sub_on',
         'sub_off',
         'foul_committed',
         'penalty_conceded',
         'penalty_won')

================
File: backend/sbapi/apps.py
================
from django.apps import AppConfig


class SbapiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sbapi'

================
File: backend/sbapi/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-12-08T04:00:51.086Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
management/
  commands/
    sm.py
migrations/
  0001_initial.py
models/
  events/
    __init__.py
    base.py
    defending.py
    goalkeeper.py
    passing.py
    possession.py
    shooting.py
    summary.py
  __init__.py
  competition.py
  formation.py
  match.py
  player.py
  team.py
services/
  loaders/
    event_loader.py
    match_loader.py
  main/
    main.py
    test.py
    utils.py
  scripts/
    match_scraper.py
v1/
  serializers/
    base/
      __init__.py
      base.py
      common.py
      competition.py
      events.py
      match.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
  services/
    events/
      __init__.py
      event_aggregator.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
  views/
    base/
      __init__.py
      base.py
      competition.py
      events.py
      match.py
    stats/
      __init__.py
      player_stats.py
      team_stats.py
    __init__.py
  urls.py
  utils.py
admin.py
apps.py
tests.py

================================================================
Repository Files
================================================================

================
File: management/commands/sm.py
================
from django.core.management.base import BaseCommand
from sbapi.services.scripts.match_scraper import MatchScraper
from sbapi.services.main.main import getMatchUrls
import json
from pathlib import Path
import time
from datetime import datetime, timedelta
from selenium import webdriver


class Command(BaseCommand):
    help = 'Get match data and stores it in the database'
    BASE_URL = "https://1xbet.whoscored.com"

    def add_arguments(self, parser):
        # Original arguments remain the same
        parser.add_argument('-u', '--urls', nargs='+', type=str,
                            help='List of match URLs to scrape')
        parser.add_argument('-f', '--file', type=str,
                            help='JSON file with URLs')
        parser.add_argument('-d', '--delay', type=float, default=2,
                            help='Delay between scrapes in seconds (default: 2)')

        parser.add_argument('-l', '--league', type=str,
                            help='League to scrape (e.g., England-Premier-League)')
        parser.add_argument('-s', '--season', type=str,
                            help='Season to scrape (format: 2024/2025)')
        parser.add_argument('--preview', action='store_true',
                            help='Preview URLs without scraping')

    def format_time(self, seconds):
        return str(timedelta(seconds=int(seconds)))

    def get_league_urls(self, league: str, season: str):
        """Get URLs for all matches in a league season"""
        league_url = f"{self.BASE_URL}/Regions/252/Tournaments/2/{league}"

        driver = webdriver.Chrome()
        try:
            match_urls = getMatchUrls(
                comp_urls={league: league_url},
                competition=league,
                season=season
            )
            driver.quit()
            return match_urls
        except Exception as e:
            driver.quit()
            raise e

    def format_url(self, url_or_data):
        """Convert relative URLs to absolute URLs or extract URL from match data"""
        if isinstance(url_or_data, dict):
            relative_url = url_or_data.get('url', '')
        else:
            relative_url = url_or_data

        if relative_url.startswith('http'):
            return relative_url
        return f"{self.BASE_URL}{relative_url}"

    def save_urls(self, urls, filename):
        """Save URLs to a JSON file"""
        with open(filename, 'w') as f:
            json.dump(urls, f, indent=2)
        return filename

    def handle(self, *args, **options):
        start_time = time.time()
        urls = []

        # Handle league option
        if options.get('league'):
            if not options.get('season'):
                self.stderr.write(
                    "Season (-s) required when using league option")
                return

            try:
                self.stdout.write(
                    f"Getting matches for {options['league']} {options['season']}...")
                match_data = self.get_league_urls(
                    options['league'], options['season'])

                # Save league URLs for reference
                league_file = f"league_matches_{options['league']}_{options['season'].replace('/', '_')}.json"
                self.save_urls(match_data, league_file)
                self.stdout.write(f"\nFound {len(match_data)} matches")
                self.stdout.write(f"URLs saved to {league_file}")

                if options.get('preview'):
                    self.stdout.write("\nPreview mode - not scraping")
                    self.stdout.write(
                        "Review the JSON file and run again with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                confirm = input("\nProceed with scraping? [y/N]: ").lower()
                if confirm != 'y':
                    self.stdout.write("Aborted. You can run later with:")
                    self.stdout.write(f"python manage.py sm -f {league_file}")
                    return

                # Store full URLs from match data
                urls.extend(self.format_url(match) for match in match_data)

            except Exception as e:
                self.stderr.write(f"Error getting league matches: {str(e)}")
                return

        # Handle direct URLs
        if options.get('urls'):
            urls.extend(self.format_url(url) for url in options['urls'])

        # Handle file input
        if options.get('file'):
            try:
                with open(Path(options['file'])) as f:
                    file_data = json.load(f)
                    # Handle both URL lists and match data lists
                    if isinstance(file_data, list):
                        urls.extend(self.format_url(item)
                                    for item in file_data)
            except Exception as e:
                self.stderr.write(f"Error reading URLs file: {e}")
                return

        if not urls:
            self.stderr.write(
                "No URLs provided. Use -u/--urls, -f/--file, or -l/--league")
            return

        # Initialize counters
        total = len(urls)
        successful = failed = 0
        failed_urls = []

        # Progress header
        self.stdout.write(
            f"\nStarting scrape of {total} matches at {datetime.now().strftime('%H:%M:%S')}")
        self.stdout.write("-" * 50)

        # Process URLs
        for i, url in enumerate(urls, 1):
            loop_start = time.time()
            try:
                self.stdout.write(f"\nMatch {i}/{total}: {url}")
                scraper = MatchScraper()
                match_data = scraper.scrape_match(url)
                processed_data = scraper.process_match_data(match_data)

                successful += 1
                elapsed = time.time() - loop_start
                self.stdout.write(self.style.SUCCESS(
                    f"✓ Success - {len(processed_data['events'])} events "
                    f"({elapsed:.1f}s)"
                ))

            except Exception as e:
                failed += 1
                failed_urls.append(url)
                self.stdout.write(self.style.ERROR(f"✗ Failed: {str(e)}"))

            if i < total:  # Don't sleep after last URL
                time.sleep(options['delay'])

        # Final summary
        total_time = time.time() - start_time
        self.stdout.write("\n" + "=" * 50)
        self.stdout.write(self.style.SUCCESS(
            f"\nScraping completed in {self.format_time(total_time)}\n"
            f"✓ Successful: {successful}/{total}\n"
            f"✗ Failed: {failed}/{total}"
        ))

        # Save failed URLs if any
        if failed_urls:
            failed_file = f"failed_urls_{int(time.time())}.json"
            self.save_urls(failed_urls, failed_file)
            self.stdout.write(f"\nFailed URLs saved to {failed_file}")


"""
USAGE EXAMPLES:

# Get league matches with preview
python manage.py sm -l England-Premier-League -s 2024/2025 --preview

# Get and scrape league matches (with confirmation prompt)
python manage.py sm -l England-Premier-League -s 2024/2025

# Use previously saved league file
python manage.py sm -f league_matches_England-Premier-League_2024_2025.json

# Direct URLs and file still work as before
python manage.py sm -u http://url1 http://url2
python manage.py sm -f urls.json
python manage.py sm -u http://url1 -d 1.5
"""

================
File: migrations/0001_initial.py
================
# Generated by Django 5.1.2 on 2024-12-06 18:17

import django.db.models.deletion
from django.db import migrations, models


class Migration(migrations.Migration):

    initial = True

    dependencies = [
    ]

    operations = [
        migrations.CreateModel(
            name='Competition',
            fields=[
                ('competition_id', models.AutoField(
                    primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('country', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'indexes': [models.Index(fields=['name'], name='sbapi_compe_name_080072_idx'), models.Index(fields=['country'], name='sbapi_compe_country_2b45dd_idx')],
                'unique_together': {('name', 'country')},
            },
        ),
        migrations.CreateModel(
            name='Player',
            fields=[
                ('player_id', models.IntegerField(
                    primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('height', models.IntegerField(null=True)),
                ('weight', models.IntegerField(null=True)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'indexes': [models.Index(fields=['name'], name='sbapi_playe_name_2f622a_idx')],
            },
        ),
        migrations.CreateModel(
            name='Season',
            fields=[
                ('season_id', models.AutoField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=20)),
                ('is_current', models.BooleanField(default=False)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('competition', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.competition')),
            ],
        ),
        migrations.CreateModel(
            name='Match',
            fields=[
                ('match_id', models.IntegerField(
                    primary_key=True, serialize=False)),
                ('start_datetime', models.DateTimeField()),
                ('venue', models.CharField(max_length=200)),
                ('attendance', models.IntegerField(null=True)),
                ('referee_id', models.IntegerField(null=True)),
                ('referee_name', models.CharField(max_length=100, null=True)),
                ('home_manager_name', models.CharField(max_length=100, null=True)),
                ('away_manager_name', models.CharField(max_length=100, null=True)),
                ('home_team_average_age', models.FloatField(null=True)),
                ('away_team_average_age', models.FloatField(null=True)),
                ('home_score_ht', models.IntegerField()),
                ('away_score_ht', models.IntegerField()),
                ('home_score_ft', models.IntegerField()),
                ('away_score_ft', models.IntegerField()),
                ('home_score_et', models.IntegerField(null=True)),
                ('away_score_et', models.IntegerField(null=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('season', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.season')),
            ],
            options={
                'verbose_name': 'Match',
                'verbose_name_plural': 'Matches',
            },
        ),
        migrations.CreateModel(
            name='Team',
            fields=[
                ('team_id', models.IntegerField(primary_key=True, serialize=False)),
                ('name', models.CharField(max_length=100)),
                ('country', models.CharField(max_length=100)),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
            ],
            options={
                'verbose_name': 'Team',
                'verbose_name_plural': 'Teams',
                'indexes': [models.Index(fields=['name'], name='sbapi_team_name_4b83cb_idx'), models.Index(fields=['country'], name='sbapi_team_country_075517_idx')],
            },
        ),
        migrations.CreateModel(
            name='SummaryEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('card_type', models.CharField(max_length=20, null=True)),
                ('yellow_card', models.BooleanField(default=False)),
                ('red_card', models.BooleanField(default=False)),
                ('second_yellow', models.BooleanField(default=False)),
                ('void_yellow_card', models.BooleanField(default=False)),
                ('foul_committed', models.BooleanField(default=False)),
                ('foul_given', models.BooleanField(default=False)),
                ('penalty_conceded', models.BooleanField(default=False)),
                ('penalty_won', models.BooleanField(default=False)),
                ('offside_given', models.BooleanField(default=False)),
                ('offside_provoked', models.BooleanField(default=False)),
                ('sub_on', models.BooleanField(default=False)),
                ('sub_off', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Summary',
                'verbose_name_plural': 'Events - Summary',
                'db_table': 'sbapi_event_summary',
            },
        ),
        migrations.CreateModel(
            name='ShootingEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('big_chance_missed', models.BooleanField(default=False)),
                ('big_chance_scored', models.BooleanField(default=False)),
                ('close_miss_high', models.BooleanField(default=False)),
                ('close_miss_high_left', models.BooleanField(default=False)),
                ('close_miss_high_right', models.BooleanField(default=False)),
                ('close_miss_left', models.BooleanField(default=False)),
                ('close_miss_right', models.BooleanField(default=False)),
                ('is_goal', models.BooleanField(default=False)),
                ('goal_counter', models.BooleanField(default=False)),
                ('goal_head', models.BooleanField(default=False)),
                ('goal_left_foot', models.BooleanField(default=False)),
                ('goal_right_foot', models.BooleanField(default=False)),
                ('goal_normal', models.BooleanField(default=False)),
                ('goal_open_play', models.BooleanField(default=False)),
                ('goal_set_piece', models.BooleanField(default=False)),
                ('goal_obox', models.BooleanField(default=False)),
                ('goal_obp', models.BooleanField(default=False)),
                ('goal_penalty_area', models.BooleanField(default=False)),
                ('goal_six_yard_box', models.BooleanField(default=False)),
                ('goal_mouth_y', models.FloatField(null=True)),
                ('goal_mouth_z', models.FloatField(null=True)),
                ('is_shot', models.BooleanField(default=False)),
                ('shot_blocked', models.BooleanField(default=False)),
                ('shot_counter', models.BooleanField(default=False)),
                ('shot_direct_corner', models.BooleanField(default=False)),
                ('shot_on_post', models.BooleanField(default=False)),
                ('shot_on_target', models.BooleanField(default=False)),
                ('shot_off_target', models.BooleanField(default=False)),
                ('shot_off_target_inside_box', models.BooleanField(default=False)),
                ('shots_total', models.BooleanField(default=False)),
                ('shot_body_type', models.CharField(max_length=20, null=True)),
                ('shot_head', models.BooleanField(default=False)),
                ('shot_left_foot', models.BooleanField(default=False)),
                ('shot_right_foot', models.BooleanField(default=False)),
                ('shot_obox_total', models.BooleanField(default=False)),
                ('shot_obp', models.BooleanField(default=False)),
                ('shot_penalty_area', models.BooleanField(default=False)),
                ('shot_six_yard_box', models.BooleanField(default=False)),
                ('shot_open_play', models.BooleanField(default=False)),
                ('shot_set_piece', models.BooleanField(default=False)),
                ('penalty_missed', models.BooleanField(default=False)),
                ('penalty_scored', models.BooleanField(default=False)),
                ('penalty_shootout_missed_off_target',
                 models.BooleanField(default=False)),
                ('penalty_shootout_scored', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Shooting',
                'verbose_name_plural': 'Events - Shooting ',
                'db_table': 'sbapi_event_shooting',
            },
        ),
        migrations.CreateModel(
            name='PossessionEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('corner_awarded', models.BooleanField(default=False)),
                ('dispossessed', models.BooleanField(default=False)),
                ('turnover', models.BooleanField(default=False)),
                ('overrun', models.BooleanField(default=False)),
                ('dribble_lastman', models.BooleanField(default=False)),
                ('dribble_lost', models.BooleanField(default=False)),
                ('dribble_won', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Possession',
                'verbose_name_plural': 'Events - Possession',
                'db_table': 'sbapi_event_possession',
            },
        ),
        migrations.CreateModel(
            name='PassEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('pass_accurate', models.BooleanField(default=False)),
                ('pass_inaccurate', models.BooleanField(default=False)),
                ('pass_accuracy', models.BooleanField(default=False)),
                ('assist', models.BooleanField(default=False)),
                ('assist_corner', models.BooleanField(default=False)),
                ('assist_cross', models.BooleanField(default=False)),
                ('assist_freekick', models.BooleanField(default=False)),
                ('assist_other', models.BooleanField(default=False)),
                ('assist_throughball', models.BooleanField(default=False)),
                ('assist_throwin', models.BooleanField(default=False)),
                ('intentional_assist', models.BooleanField(default=False)),
                ('key_pass_corner', models.BooleanField(default=False)),
                ('key_pass_cross', models.BooleanField(default=False)),
                ('key_pass_freekick', models.BooleanField(default=False)),
                ('key_pass_long', models.BooleanField(default=False)),
                ('key_pass_other', models.BooleanField(default=False)),
                ('key_pass_short', models.BooleanField(default=False)),
                ('key_pass_throughball', models.BooleanField(default=False)),
                ('key_pass_throwin', models.BooleanField(default=False)),
                ('pass_key', models.BooleanField(default=False)),
                ('pass_corner', models.BooleanField(default=False)),
                ('pass_corner_accurate', models.BooleanField(default=False)),
                ('pass_corner_inaccurate', models.BooleanField(default=False)),
                ('pass_cross_accurate', models.BooleanField(default=False)),
                ('pass_cross_blocked_defensive',
                 models.BooleanField(default=False)),
                ('pass_cross_inaccurate', models.BooleanField(default=False)),
                ('pass_freekick', models.BooleanField(default=False)),
                ('pass_freekick_accurate', models.BooleanField(default=False)),
                ('pass_freekick_inaccurate', models.BooleanField(default=False)),
                ('pass_back', models.BooleanField(default=False)),
                ('pass_back_zone_inaccurate', models.BooleanField(default=False)),
                ('pass_forward', models.BooleanField(default=False)),
                ('pass_forward_zone_accurate', models.BooleanField(default=False)),
                ('pass_left', models.BooleanField(default=False)),
                ('pass_right', models.BooleanField(default=False)),
                ('pass_chipped', models.BooleanField(default=False)),
                ('pass_head', models.BooleanField(default=False)),
                ('pass_left_foot', models.BooleanField(default=False)),
                ('pass_right_foot', models.BooleanField(default=False)),
                ('pass_long_ball_accurate', models.BooleanField(default=False)),
                ('pass_long_ball_inaccurate', models.BooleanField(default=False)),
                ('short_pass_accurate', models.BooleanField(default=False)),
                ('short_pass_inaccurate', models.BooleanField(default=False)),
                ('pass_through_ball_accurate', models.BooleanField(default=False)),
                ('pass_through_ball_inaccurate',
                 models.BooleanField(default=False)),
                ('big_chance_created', models.BooleanField(default=False)),
                ('successful_final_third_passes',
                 models.BooleanField(default=False)),
                ('throw_in', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Passing',
                'verbose_name_plural': 'Events - Passing',
                'db_table': 'sbapi_event_passing',
            },
        ),
        migrations.CreateModel(
            name='MatchPlayer',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('shirt_no', models.IntegerField()),
                ('position', models.CharField(max_length=20)),
                ('is_first_eleven', models.BooleanField()),
                ('is_man_of_match', models.BooleanField(default=False)),
                ('age', models.IntegerField()),
                ('height', models.IntegerField(null=True)),
                ('weight', models.IntegerField(null=True)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Match - Player Information',
                'verbose_name_plural': 'Matches - Player Information',
            },
        ),
        migrations.AddField(
            model_name='match',
            name='away_team',
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name='away_matches',
                to='sbapi.team'),
        ),
        migrations.AddField(
            model_name='match',
            name='home_team',
            field=models.ForeignKey(
                on_delete=django.db.models.deletion.CASCADE,
                related_name='home_matches',
                to='sbapi.team'),
        ),
        migrations.CreateModel(
            name='GoalkeeperEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('is_collected', models.BooleanField(default=False)),
                ('keeper_claim_high_lost', models.BooleanField(default=False)),
                ('keeper_claim_high_won', models.BooleanField(default=False)),
                ('keeper_claim_lost', models.BooleanField(default=False)),
                ('keeper_claim_won', models.BooleanField(default=False)),
                ('keeper_diving_save', models.BooleanField(default=False)),
                ('keeper_missed', models.BooleanField(default=False)),
                ('keeper_one_to_one_won', models.BooleanField(default=False)),
                ('standing_save', models.BooleanField(default=False)),
                ('save_feet', models.BooleanField(default=False)),
                ('save_hands', models.BooleanField(default=False)),
                ('save_high_centre', models.BooleanField(default=False)),
                ('save_high_left', models.BooleanField(default=False)),
                ('save_high_right', models.BooleanField(default=False)),
                ('save_low_centre', models.BooleanField(default=False)),
                ('save_low_left', models.BooleanField(default=False)),
                ('save_low_right', models.BooleanField(default=False)),
                ('save_obox', models.BooleanField(default=False)),
                ('save_obp', models.BooleanField(default=False)),
                ('save_penalty_area', models.BooleanField(default=False)),
                ('save_six_yard_box', models.BooleanField(default=False)),
                ('keeper_save_in_the_box', models.BooleanField(default=False)),
                ('keeper_save_total', models.BooleanField(default=False)),
                ('keeper_penalty_saved', models.BooleanField(default=False)),
                ('penalty_shootout_saved', models.BooleanField(default=False)),
                ('penalty_shootout_saved_gk', models.BooleanField(default=False)),
                ('penalty_shootout_conceded_gk',
                 models.BooleanField(default=False)),
                ('keeper_smother', models.BooleanField(default=False)),
                ('keeper_sweeper_lost', models.BooleanField(default=False)),
                ('parried_danger', models.BooleanField(default=False)),
                ('parried_safe', models.BooleanField(default=False)),
                ('punches', models.BooleanField(default=False)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Goalkeeper',
                'verbose_name_plural': 'Events - Goalkeeper',
                'db_table': 'sbapi_event_goalkeeping',
            },
        ),
        migrations.CreateModel(
            name='Formation',
            fields=[
                ('id', models.BigAutoField(auto_created=True,
                 primary_key=True, serialize=False, verbose_name='ID')),
                ('formation_name', models.CharField(max_length=10)),
                ('captain_player_id', models.IntegerField()),
                ('start_minute', models.IntegerField()),
                ('end_minute', models.IntegerField()),
                ('player_ids', models.JSONField(default=list)),
                ('jersey_numbers', models.JSONField(default=list)),
                ('last_updated', models.DateTimeField(auto_now=True)),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Match Formation',
                'verbose_name_plural': 'Match Formations',
            },
        ),
        migrations.CreateModel(
            name='DefendingEvent',
            fields=[
                ('id', models.AutoField(primary_key=True, serialize=False)),
                ('source_id', models.BigIntegerField()),
                ('event_id', models.IntegerField()),
                ('player_name', models.CharField(max_length=100, null=True)),
                ('minute', models.IntegerField()),
                ('second', models.FloatField(null=True)),
                ('expanded_minute', models.IntegerField()),
                ('period', models.CharField(max_length=20)),
                ('max_minute', models.IntegerField()),
                ('x', models.FloatField()),
                ('y', models.FloatField()),
                ('end_x', models.FloatField(null=True)),
                ('end_y', models.FloatField(null=True)),
                ('is_touch', models.BooleanField(default=False)),
                ('touches', models.BooleanField(default=False)),
                ('defensive_third', models.BooleanField(default=False)),
                ('mid_third', models.BooleanField(default=False)),
                ('final_third', models.BooleanField(default=False)),
                ('type', models.CharField(max_length=50)),
                ('outcome_type', models.CharField(max_length=20, null=True)),
                ('related_event_id', models.FloatField(null=True)),
                ('related_player_id', models.FloatField(null=True)),
                ('h_a', models.CharField(max_length=1)),
                ('situation', models.CharField(max_length=50, null=True)),
                ('qualifiers', models.JSONField(default=list)),
                ('satisfied_events_types', models.JSONField(default=list)),
                ('is_tackle', models.BooleanField(default=False,
                 help_text='Quick identifier for tackle events')),
                ('is_interception', models.BooleanField(default=False,
                 help_text="Quick identifier for interception events. Occurs when a player reads and intercepts an opponent's pass by moving into the line of the intended pass")),
                ('is_clearance', models.BooleanField(default=False,
                 help_text='Quick identifier for clearance events. Represents an action where a player attempts to get the ball away from a dangerous zone')),
                ('is_ball_recovery', models.BooleanField(default=False,
                 help_text='Quick identifier for ball recovery events. Occurs when a player recovers the ball in a situation where neither team has possession')),
                ('aerial_success', models.BooleanField(default=False,
                 help_text='Indicates successful aerial duel')),
                ('duel_aerial_lost', models.BooleanField(
                    default=False, help_text='Indicates lost aerial duel')),
                ('duel_aerial_won', models.BooleanField(
                    default=False, help_text='Indicates won aerial duel')),
                ('blocked_x', models.FloatField(
                    help_text='X-coordinate of block location', null=True)),
                ('blocked_y', models.FloatField(
                    help_text='Y-coordinate of block location', null=True)),
                ('clearance_effective', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was effective')),
                ('clearance_head', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was made with the head')),
                ('clearance_off_the_line', models.BooleanField(default=False,
                 help_text='Indicates if the clearance was made off the goal line')),
                ('clearance_total', models.BooleanField(default=False,
                 help_text='Total clearance indicator (purpose needs clarification)')),
                ('challenge_lost', models.BooleanField(default=False,
                 help_text='Indicates when a player is dribbled past and fails to win the ball')),
                ('defensive_duel', models.BooleanField(default=False,
                 help_text='Indicates involvement in a defensive duel')),
                ('offensive_duel', models.BooleanField(default=False,
                 help_text='Indicates involvement in an offensive duel')),
                ('error_leads_to_goal', models.BooleanField(default=False,
                 help_text='Indicates if a defensive error led to a goal')),
                ('error_leads_to_shot', models.BooleanField(default=False,
                 help_text='Indicates if a defensive error led to a shot')),
                ('goal_own', models.BooleanField(default=False,
                 help_text='Indicates if an own goal was scored')),
                ('interception_all', models.BooleanField(default=False,
                 help_text='Indicates any type of interception')),
                ('interception_in_the_box', models.BooleanField(default=False,
                 help_text='Indicates interception made inside the penalty box')),
                ('interception_won', models.BooleanField(
                    default=False, help_text='Indicates successful interception')),
                ('outfielder_block', models.BooleanField(default=False,
                 help_text='Indicates block made by an outfield player')),
                ('outfielder_blocked_pass', models.BooleanField(default=False,
                 help_text='Indicates blocked pass by an outfield player. Similar to interception but with less reading of the pass')),
                ('six_yard_block', models.BooleanField(default=False,
                 help_text='Indicates block made in the six-yard box')),
                ('tackle_last_man', models.BooleanField(default=False,
                 help_text='Indicates tackle made as the last defending player')),
                ('tackle_lost', models.BooleanField(default=False,
                 help_text='Indicates tackle where the ball goes to an opposition player')),
                ('tackle_won', models.BooleanField(default=False,
                 help_text='Indicates tackle where the tackler or teammate regains possession, or the ball goes safely out of play')),
                ('match', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.match')),
                ('player',
                 models.ForeignKey(null=True,
                                   on_delete=django.db.models.deletion.CASCADE,
                                   to='sbapi.player')),
                ('team', models.ForeignKey(
                    on_delete=django.db.models.deletion.CASCADE, to='sbapi.team')),
            ],
            options={
                'verbose_name': 'Events - Defending',
                'verbose_name_plural': 'Events - Defending',
                'db_table': 'sbapi_event_defending',
            },
        ),
        migrations.AddIndex(
            model_name='season',
            index=models.Index(
                fields=['is_current'],
                name='sbapi_seaso_is_curr_bc5403_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='season',
            unique_together={('competition', 'name')},
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_787265_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__b52555_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_ef028a_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_376715_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__aceb7a_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['card_type'],
                name='sbapi_event_card_ty_01bd0b_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=['foul_committed'],
                name='sbapi_event_foul_co_270625_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'penalty_conceded',
                    'penalty_won'],
                name='sbapi_event_penalty_c50ee7_idx'),
        ),
        migrations.AddIndex(
            model_name='summaryevent',
            index=models.Index(
                fields=[
                    'sub_on',
                    'sub_off'],
                name='sbapi_event_sub_on_919522_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_600bbe_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__4d3a71_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_3a6f6a_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_678115_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__ca4bb8_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['is_goal'],
                name='sbapi_event_is_goal_c0daab_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['is_shot'],
                name='sbapi_event_is_shot_d8c23b_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['shot_on_target'],
                name='sbapi_event_shot_on_496be4_idx'),
        ),
        migrations.AddIndex(
            model_name='shootingevent',
            index=models.Index(
                fields=['big_chance_scored'],
                name='sbapi_event_big_cha_d3b014_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_0de657_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__08d47c_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_082591_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_0506ad_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__8649c9_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['dribble_won'],
                name='sbapi_event_dribble_336758_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['dispossessed'],
                name='sbapi_event_disposs_3e2477_idx'),
        ),
        migrations.AddIndex(
            model_name='possessionevent',
            index=models.Index(
                fields=['touches'],
                name='sbapi_event_touches_689c94_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_aefb3b_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__6abd5a_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_054a1e_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_14931d_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__c67f83_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['pass_accurate'],
                name='sbapi_event_pass_ac_ba36de_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['assist'],
                name='sbapi_event_assist_d8fa64_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['pass_key'],
                name='sbapi_event_pass_ke_26ed2a_idx'),
        ),
        migrations.AddIndex(
            model_name='passevent',
            index=models.Index(
                fields=['big_chance_created'],
                name='sbapi_event_big_cha_ff1221_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=['position'],
                name='sbapi_match_positio_d56e17_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=[
                    'match',
                    'team'],
                name='sbapi_match_match_i_d49a36_idx'),
        ),
        migrations.AddIndex(
            model_name='matchplayer',
            index=models.Index(
                fields=['is_first_eleven'],
                name='sbapi_match_is_firs_ad26eb_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='matchplayer',
            unique_together={('match', 'player', 'team')},
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['start_datetime'],
                name='sbapi_match_start_d_b479c2_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['home_team'],
                name='sbapi_match_home_te_17af12_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['away_team'],
                name='sbapi_match_away_te_c1e3d5_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['referee_id'],
                name='sbapi_match_referee_20666a_idx'),
        ),
        migrations.AddIndex(
            model_name='match',
            index=models.Index(
                fields=['season'],
                name='sbapi_match_season__d292ef_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_13e256_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__c1b44b_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_08b887_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_dcaa0e_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__6e974b_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_diving_save'],
                name='sbapi_event_keeper__21d8d4_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_save_total'],
                name='sbapi_event_keeper__a677af_idx'),
        ),
        migrations.AddIndex(
            model_name='goalkeeperevent',
            index=models.Index(
                fields=['keeper_penalty_saved'],
                name='sbapi_event_keeper__16ced3_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=['formation_name'],
                name='sbapi_forma_formati_ab138a_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=['captain_player_id'],
                name='sbapi_forma_captain_756fc3_idx'),
        ),
        migrations.AddIndex(
            model_name='formation',
            index=models.Index(
                fields=[
                    'match',
                    'team'],
                name='sbapi_forma_match_i_982726_idx'),
        ),
        migrations.AlterUniqueTogether(
            name='formation',
            unique_together={('match', 'team', 'start_minute', 'end_minute')},
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'match',
                    'minute'],
                name='sbapi_event_match_i_6313f6_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'player',
                    'type'],
                name='sbapi_event_player__083cd7_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=[
                    'team',
                    'type'],
                name='sbapi_event_team_id_27df09_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['event_id'],
                name='sbapi_event_event_i_e9ff91_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['source_id'],
                name='sbapi_event_source__cb714d_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_tackle'],
                name='sbapi_event_is_tack_00e724_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_interception'],
                name='sbapi_event_is_inte_428499_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['is_clearance'],
                name='sbapi_event_is_clea_e456d8_idx'),
        ),
        migrations.AddIndex(
            model_name='defendingevent',
            index=models.Index(
                fields=['aerial_success'],
                name='sbapi_event_aerial__dc1179_idx'),
        ),
    ]

================
File: models/events/__init__.py
================
from .base import Event
from .passing import PassEvent
from .shooting import ShootingEvent
from .defending import DefendingEvent
from .goalkeeper import GoalkeeperEvent
from .possession import PossessionEvent
from .summary import SummaryEvent

__all__ = [
    'Event',
    'PassEvent',
    'ShootingEvent',
    'DefendingEvent',
    'GoalkeeperEvent',
    'PossessionEvent',
    'SummaryEvent'
]

================
File: models/events/base.py
================
from django.db import models


class Event(models.Model):
    """Base model for all match events, these fields are informative"""
    # Core identification
    # Django's auto-incrementing primary key
    id = models.AutoField(primary_key=True)
    # The original DataFrame id (2.755319e+09)
    source_id = models.BigIntegerField()
    # The original eventId that groups related actions (21, 22, etc)
    event_id = models.IntegerField()
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    player = models.ForeignKey(
        'sbapi.Player', null=True, on_delete=models.CASCADE)
    player_name = models.CharField(max_length=100, null=True)

    # Timing
    minute = models.IntegerField()  # Range: [0 to 102]
    second = models.FloatField(null=True)  # Range: [0.0 to 59.0]
    expanded_minute = models.IntegerField()  # Range: [0 to 108]
    # FirstHalf, SecondHalf, PenaltyShootout, FirstPeriodOfExtraTime, SecondPeriodOfExtraTime
    period = models.CharField(max_length=20)
    max_minute = models.IntegerField()  # [102]

    # Location
    x = models.FloatField()  # Range: [0.0 to 100]
    y = models.FloatField()  # Range: [0.0 to 100.0]
    end_x = models.FloatField(null=True)  # Range: [0.0 to 100.0]
    end_y = models.FloatField(null=True)  # Range: [0.0 to 100.0]

    # Did this event involve a touch?
    is_touch = models.BooleanField(default=False)
    touches = models.BooleanField(default=False)

    # Field position
    defensive_third = models.BooleanField(default=False)
    mid_third = models.BooleanField(default=False)
    final_third = models.BooleanField(default=False)

    # Type and outcome
    # Pass, Shot, etc. (see type in docs/)
    type = models.CharField(max_length=50)
    outcome_type = models.CharField(
        max_length=20, null=True)  # Successful, Unsuccessful

    # Related events/players
    # Changed to FloatField, Range: [63.0 to 924.0]
    related_event_id = models.FloatField(null=True)
    # Changed to FloatField, Range: [22079.0 to 494120.0]
    related_player_id = models.FloatField(null=True)

    # Match context
    h_a = models.CharField(max_length=1)  # 'h' or 'a'

    # OpenPlay, SetPiece, etc.
    situation = models.CharField(max_length=50, null=True)
    """Regular an attempt created from an open-play attack.
Set-piece  an attempt created where the ball starts from an indirect free-kick dead-ball situation.
Throw-in  an attempt created from a throw-in.
Direct free-kick  an attempt at goal directly from free-kick situation.
Direct corner  a goal scored directly from a corner by the corner-taker, or an attempt created from a corner situation.
Fast break  an attempt created after a team quickly turn defence into attack, winning the ball in their own half (counter-attack).
Penalty  The penalty attempt itself, any follow-up shot would be classed as a set-piece attempt. Passed penalties are also counted as penalty pattern of play"""

    # Additional data
    qualifiers = models.JSONField(default=list)
    satisfied_events_types = models.JSONField(default=list)

    class Meta:
        abstract = True
        indexes = [
            models.Index(fields=['match', 'minute']),
            models.Index(fields=['player', 'type']),
            models.Index(fields=['team', 'type']),
            models.Index(fields=['event_id']),
            # Meaningful for finding related actions
            # Index for the original DataFrame id
            models.Index(fields=['source_id']),
        ]
        constraints = [
            models.UniqueConstraint(
                fields=['match', 'source_id'],
                name='%(app_label)s_%(class)s_unique_match_source'
            )
        ]

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: models/events/defending.py
================
from django.db import models
from .base import Event


class DefendingEvent(Event):
    """
    Model representing defensive actions in football/soccer matches.
    Inherits from base Event model.

    This model tracks various defensive actions including tackles, interceptions,
    clearances, aerial duels, and defensive errors.
    """

    # Core defensive actions
    is_tackle = models.BooleanField(
        default=False,
        help_text="Quick identifier for tackle events"
    )
    is_interception = models.BooleanField(
        default=False,
        help_text="Quick identifier for interception events. Occurs when a player reads and "
        "intercepts an opponent's pass by moving into the line of the intended pass"
    )
    is_clearance = models.BooleanField(
        default=False,
        help_text="Quick identifier for clearance events. Represents an action where "
        "a player attempts to get the ball away from a dangerous zone"
    )
    is_ball_recovery = models.BooleanField(
        default=False,
        help_text="Quick identifier for ball recovery events. Occurs when a player recovers "
        "the ball in a situation where neither team has possession"
    )

    # Aerial duels
    aerial_success = models.BooleanField(
        default=False,
        help_text="Indicates successful aerial duel"
    )
    duel_aerial_lost = models.BooleanField(
        default=False,
        help_text="Indicates lost aerial duel"
    )
    duel_aerial_won = models.BooleanField(
        default=False,
        help_text="Indicates won aerial duel"
    )

    # Block coordinates
    blocked_x = models.FloatField(
        null=True,
        help_text="X-coordinate of block location"
    )
    blocked_y = models.FloatField(
        null=True,
        help_text="Y-coordinate of block location"
    )

    # Clearance types
    clearance_effective = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was effective"
    )
    clearance_head = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made with the head"
    )
    clearance_off_the_line = models.BooleanField(
        default=False,
        help_text="Indicates if the clearance was made off the goal line"
    )
    clearance_total = models.BooleanField(
        default=False,
        help_text="Total clearance indicator (purpose needs clarification)"
    )

    # Duels and challenges
    challenge_lost = models.BooleanField(
        default=False,
        help_text="Indicates when a player is dribbled past and fails to win the ball"
    )
    defensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in a defensive duel"
    )
    offensive_duel = models.BooleanField(
        default=False,
        help_text="Indicates involvement in an offensive duel"
    )

    # Defensive errors
    error_leads_to_goal = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a goal"
    )
    error_leads_to_shot = models.BooleanField(
        default=False,
        help_text="Indicates if a defensive error led to a shot"
    )
    goal_own = models.BooleanField(
        default=False,
        help_text="Indicates if an own goal was scored"
    )

    # Interception details
    interception_all = models.BooleanField(
        default=False,
        help_text="Indicates any type of interception"
    )
    interception_in_the_box = models.BooleanField(
        default=False,
        help_text="Indicates interception made inside the penalty box"
    )
    interception_won = models.BooleanField(
        default=False,
        help_text="Indicates successful interception"
    )

    # Block types
    outfielder_block = models.BooleanField(
        default=False,
        help_text="Indicates block made by an outfield player (for shots?)"
    )
    outfielder_blocked_pass = models.BooleanField(
        default=False,
        help_text="Indicates blocked pass by an outfield player. Similar to interception "
        "but with less reading of the pass"
    )
    six_yard_block = models.BooleanField(
        default=False,
        help_text="Indicates block made in the six-yard box"
    )

    # Tackle outcomes
    tackle_last_man = models.BooleanField(
        default=False,
        help_text="Indicates tackle made as the last defending player"
    )
    tackle_lost = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the ball goes to an opposition player"
    )
    tackle_won = models.BooleanField(
        default=False,
        help_text="Indicates tackle where the tackler or teammate regains possession, "
        "or the ball goes safely out of play"
    )

    class Meta:
        db_table = 'sbapi_event_defending'
        verbose_name = 'Events - Defending'
        verbose_name_plural = 'Events - Defending'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['is_tackle']),
            models.Index(fields=['is_interception']),
            models.Index(fields=['is_clearance']),
            models.Index(fields=['aerial_success']),
        ]

================
File: models/events/goalkeeper.py
================
from django.db import models
from .base import Event


class GoalkeeperEvent(Event):
    """Goalkeeper-specific event details"""
    # Core actions
    is_collected = models.BooleanField(default=False)

    # Claims
    keeper_claim_high_lost = models.BooleanField(default=False)
    keeper_claim_high_won = models.BooleanField(default=False)
    keeper_claim_lost = models.BooleanField(default=False)
    keeper_claim_won = models.BooleanField(default=False)

    # Save types
    keeper_diving_save = models.BooleanField(default=False)
    keeper_missed = models.BooleanField(default=False)
    keeper_one_to_one_won = models.BooleanField(default=False)
    standing_save = models.BooleanField(default=False)
    save_feet = models.BooleanField(default=False)
    save_hands = models.BooleanField(default=False)

    # Save locations
    save_high_centre = models.BooleanField(default=False)
    save_high_left = models.BooleanField(default=False)
    save_high_right = models.BooleanField(default=False)
    save_low_centre = models.BooleanField(default=False)
    save_low_left = models.BooleanField(default=False)
    save_low_right = models.BooleanField(default=False)

    # Save zones
    save_obox = models.BooleanField(default=False)  # Outside box
    save_obp = models.BooleanField(default=False)   # Outside box proper
    save_penalty_area = models.BooleanField(default=False)
    save_six_yard_box = models.BooleanField(default=False)
    keeper_save_in_the_box = models.BooleanField(default=False)
    keeper_save_total = models.BooleanField(default=False)

    # Penalties
    keeper_penalty_saved = models.BooleanField(default=False)
    penalty_shootout_saved = models.BooleanField(default=False)
    penalty_shootout_saved_gk = models.BooleanField(default=False)
    penalty_shootout_conceded_gk = models.BooleanField(default=False)

    # Other actions
    keeper_smother = models.BooleanField(default=False)
    keeper_sweeper_lost = models.BooleanField(default=False)
    parried_danger = models.BooleanField(default=False)
    parried_safe = models.BooleanField(default=False)
    punches = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_goalkeeping'  # Specific table name
        verbose_name = 'Events - Goalkeeper'
        verbose_name_plural = 'Events - Goalkeeper'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['keeper_diving_save']),
            models.Index(fields=['keeper_save_total']),
            models.Index(fields=['keeper_penalty_saved']),
        ]

================
File: models/events/passing.py
================
from django.db import models
from .base import Event


class PassEvent(Event):
    """Pass-specific event details"""
    # Core pass attributes
    pass_accurate = models.BooleanField(default=False)
    pass_inaccurate = models.BooleanField(default=False)
    pass_accuracy = models.BooleanField(default=False)

    # Assist types
    assist = models.BooleanField(default=False)
    assist_corner = models.BooleanField(default=False)
    assist_cross = models.BooleanField(default=False)
    assist_freekick = models.BooleanField(default=False)
    assist_other = models.BooleanField(default=False)
    assist_throughball = models.BooleanField(default=False)
    assist_throwin = models.BooleanField(default=False)
    intentional_assist = models.BooleanField(default=False)

    # Key pass types
    key_pass_corner = models.BooleanField(default=False)
    key_pass_cross = models.BooleanField(default=False)
    key_pass_freekick = models.BooleanField(default=False)
    key_pass_long = models.BooleanField(default=False)
    key_pass_other = models.BooleanField(default=False)
    key_pass_short = models.BooleanField(default=False)
    key_pass_throughball = models.BooleanField(default=False)
    key_pass_throwin = models.BooleanField(default=False)
    pass_key = models.BooleanField(default=False)

    # Corner passes
    pass_corner = models.BooleanField(default=False)
    pass_corner_accurate = models.BooleanField(default=False)
    pass_corner_inaccurate = models.BooleanField(default=False)

    # Cross passes
    pass_cross_accurate = models.BooleanField(default=False)
    pass_cross_blocked_defensive = models.BooleanField(default=False)
    pass_cross_inaccurate = models.BooleanField(default=False)

    # Freekick passes
    pass_freekick = models.BooleanField(default=False)
    pass_freekick_accurate = models.BooleanField(default=False)
    pass_freekick_inaccurate = models.BooleanField(default=False)

    # Pass direction/zone
    pass_back = models.BooleanField(default=False)
    pass_back_zone_inaccurate = models.BooleanField(default=False)
    pass_forward = models.BooleanField(default=False)
    pass_forward_zone_accurate = models.BooleanField(default=False)
    pass_left = models.BooleanField(default=False)
    pass_right = models.BooleanField(default=False)

    # Pass types
    pass_chipped = models.BooleanField(default=False)
    pass_head = models.BooleanField(default=False)
    pass_left_foot = models.BooleanField(default=False)
    pass_right_foot = models.BooleanField(default=False)

    # Long/short passes
    pass_long_ball_accurate = models.BooleanField(default=False)
    pass_long_ball_inaccurate = models.BooleanField(default=False)
    short_pass_accurate = models.BooleanField(default=False)
    short_pass_inaccurate = models.BooleanField(default=False)

    # Through balls
    pass_through_ball_accurate = models.BooleanField(default=False)
    pass_through_ball_inaccurate = models.BooleanField(default=False)

    # Additional characteristics
    big_chance_created = models.BooleanField(default=False)
    successful_final_third_passes = models.BooleanField(default=False)
    throw_in = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_passing'  # Specific table name
        verbose_name = 'Events - Passing'
        verbose_name_plural = 'Events - Passing'
        indexes = [
            *Event.Meta.indexes,  # Include parent's indexes
            models.Index(fields=['pass_accurate']),
            models.Index(fields=['assist']),
            models.Index(fields=['pass_key']),
            models.Index(fields=['big_chance_created']),
        ]

================
File: models/events/possession.py
================
# sbapi/models/events/possession.py
from django.db import models
from .base import Event


class PossessionEvent(Event):
    """Possession-related event details"""
    # Set pieces
    corner_awarded = models.BooleanField(
        default=False)  # recorded as h/a for conceded/won

    # Ball control
    dispossessed = models.BooleanField(default=False)
    turnover = models.BooleanField(default=False)
    overrun = models.BooleanField(default=False)

    # Dribbling
    dribble_lastman = models.BooleanField(default=False)
    dribble_lost = models.BooleanField(default=False)
    dribble_won = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_possession'  # Specific table name
        verbose_name = 'Events - Possession'
        verbose_name_plural = 'Events - Possession'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['dribble_won']),
            models.Index(fields=['dispossessed']),
            models.Index(fields=['touches']),
        ]


# 
# Location of each pass
# End location of each pass
# Pass accuracy so all passes, (for this we need to use pass accurate and pass innac)then use accuract erand innacruate

# Type of pass, so this too:

# was it an assist
# was it a corner?
# was it a cross? most times when its a corner its a cross but not always lol
# what about:
# Assist freekick
# Assist other
# Assist throughball
# Assist throwin
# was it Intentional assist

# then for a # Passkey key pass was it a ?

# Key pass corner

# Key pass cross

# Key pass freekick

# Key pass long

# Key pass other

# Key pass short

# Key pass throughball

# Key pass throwin

# then chances created too (this mean key passes + assists), so for alter when trying to find the cahcne created find ti from events
# Note theres also BCC BUT THIS ALREADY CO MES TWITH THE DAT SO WE ODNT NEED TO FIND




# doing  it this way will help me aggregate it for a season, so aggreagte for amcth foir a player i wil show u this too

# then use this too i want to kmow every detaila but my passes
# Pass corner

# Pass corner accurate

# Pass corner inaccurate

# Pass cross accurate

# Pass cross blocked defensive

# Pass cross inaccurate

# Pass freekick

# Pass freekick accurate

# Pass freekick inaccurate

# Pass back

# Pass back zone inaccurate

# Pass forward

# Pass forward zone accurate

# Pass left

# Pass right

# Pass chipped

# Pass head

# Pass left foot

# Pass right foot

# Pass long ball accurate

# Pass long ball inaccurate

# Short pass accurate

# Short pass inaccurate

# Pass through ball accurate

# Pass through ball inaccurate

# Big chance created

# Successful final third passes

# Throw in

# i wanna be clear what im trying to do so you know,
# basically i havce api routes fior diffrent stats i ie match events, im staring with passing that needs upgradingf and pottnetially changing idk yuoull help
# the route return all passing events from a amtchn adn com, eptiotn good, firstly i want to be able to from ym front end (so perhaps i need an api rotue backend oidk0, see
# passinmg events for a speicifc player form trhat macth you get me
# alsoo,i currently have a playere macth stats rotue showingg stats from a specifi cmathc thats no problem but then, i feel liek its goo ig ic a=could get mor edtail fo the stuff 
# i aggregate, for example asists in match a playe rmay have 3, but then i want to see what was true, ie was he asis tyf rom a corner or fk or sdomehting
# or even a regualr passes a paleyr had 90 passes, i want to get the detail of each pass as well or know i mean we have all the dat in one palc eits kind of jus tfil;t
# fi;lteroig it in the righ wya or somethign , liek a players passes all them then the type and then aggregated (and then knowing what those aggregate stuff are clealryl)
# liek i dont jsu wnan aknow he had 3 chances cretaed or 5 bgi chnces created wold be ncie to know if it was a coner ans stuff idk if i m vlear o hwo this woulkd work
# caus e i ahevb an matches/1282309/events/passing and matches/stats/players/1282309 showing detail too 

#  i wil lalso calculate further stats based on ther attribuyte s latesr, the reason i want match level agrgegation and with detial is so that my
# player season is easy to sdo ie cna use match possibley but for all amcthes idk, liek perhaps isot sjust getting the ful row of passing event btu perhas theres abter way, hope ive been clear and lmk
# if u have any qs, i am goonn share my code


# on my endx and start x coroidnates, like i want to do stuff liek finding out progressive passes, later tho

================
File: models/events/shooting.py
================
from django.db import models
from .base import Event


class ShootingEvent(Event):
    """Shot-specific event details"""
    # Big chances
    big_chance_missed = models.BooleanField(default=False)
    big_chance_scored = models.BooleanField(default=False)

    # Close misses
    close_miss_high = models.BooleanField(default=False)
    close_miss_high_left = models.BooleanField(default=False)
    close_miss_high_right = models.BooleanField(default=False)
    close_miss_left = models.BooleanField(default=False)
    close_miss_right = models.BooleanField(default=False)

    # Goals
    is_goal = models.BooleanField(default=False)
    goal_counter = models.BooleanField(default=False)
    goal_head = models.BooleanField(default=False)
    goal_left_foot = models.BooleanField(default=False)
    goal_right_foot = models.BooleanField(default=False)
    goal_normal = models.BooleanField(default=False)
    goal_open_play = models.BooleanField(default=False)
    goal_set_piece = models.BooleanField(default=False)

    # Goal location
    goal_obox = models.BooleanField(default=False)
    goal_obp = models.BooleanField(default=False)
    goal_penalty_area = models.BooleanField(default=False)
    goal_six_yard_box = models.BooleanField(default=False)
    goal_mouth_y = models.FloatField(null=True)  # Range: 7.1 to 93.4
    goal_mouth_z = models.FloatField(null=True)  # Range: 1.3 to 86.1

    # Shot flags
    is_shot = models.BooleanField(default=False)
    shot_blocked = models.BooleanField(default=False)
    shot_counter = models.BooleanField(default=False)
    shot_direct_corner = models.BooleanField(default=False)
    shot_on_post = models.BooleanField(default=False)
    shot_on_target = models.BooleanField(default=False)
    shot_off_target = models.BooleanField(default=False)
    shot_off_target_inside_box = models.BooleanField(default=False)
    shots_total = models.BooleanField(default=False)

    # Shot body part
    shot_body_type = models.CharField(max_length=20, null=True)
    shot_head = models.BooleanField(default=False)
    shot_left_foot = models.BooleanField(default=False)
    shot_right_foot = models.BooleanField(default=False)

    # Shot location
    shot_obox_total = models.BooleanField(default=False)
    shot_obp = models.BooleanField(default=False)
    shot_penalty_area = models.BooleanField(default=False)
    shot_six_yard_box = models.BooleanField(default=False)

    # Shot type
    shot_open_play = models.BooleanField(default=False)
    shot_set_piece = models.BooleanField(default=False)

    # Penalties (note diff in open play vs shootouts)
    penalty_missed = models.BooleanField(default=False)
    penalty_scored = models.BooleanField(default=False)
    penalty_shootout_missed_off_target = models.BooleanField(default=False)
    penalty_shootout_scored = models.BooleanField(default=False)

    class Meta:
        db_table = 'sbapi_event_shooting'  # Specific table name
        verbose_name = 'Events - Shooting'
        verbose_name_plural = 'Events - Shooting '
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['is_goal']),
            models.Index(fields=['is_shot']),
            models.Index(fields=['shot_on_target']),
            models.Index(fields=['big_chance_scored']),
        ]

================
File: models/events/summary.py
================
from django.db import models
from .base import Event


class SummaryEvent(Event):
    """Summary events such as fouls, cards and substitutions"""
    # Cards
    # Yellow, Red, SecondYellow
    card_type = models.CharField(max_length=20, null=True)
    yellow_card = models.BooleanField(default=False)
    red_card = models.BooleanField(default=False)
    second_yellow = models.BooleanField(default=False)
    void_yellow_card = models.BooleanField(default=False)

    # Fouls
    foul_committed = models.BooleanField(
        default=False)  # player that gave foul away
    foul_given = models.BooleanField(
        default=False)  # player/team foul was given to

    # Penalty
    penalty_conceded = models.BooleanField(default=False)
    penalty_won = models.BooleanField(default=False)

    # Offsides
    # An event attributed to the player deemed to be in an offside position
    # when a free kick is awarded
    offside_given = models.BooleanField(default=False)
    # The deepest player in the defensive line when an offside has been given
    offside_provoked = models.BooleanField(default=False)

    # Substitutions
    sub_on = models.BooleanField(default=False)  # Renamed from is_sub_on
    sub_off = models.BooleanField(default=False)  # Renamed from is_sub_off

    class Meta:
        db_table = 'sbapi_event_summary'  # Specific table name
        verbose_name = 'Events - Summary'
        verbose_name_plural = 'Events - Summary'
        indexes = [
            *Event.Meta.indexes,
            models.Index(fields=['card_type']),
            models.Index(fields=['foul_committed']),
            models.Index(fields=['penalty_conceded', 'penalty_won']),
            models.Index(fields=['sub_on', 'sub_off']),
        ]

================
File: models/__init__.py
================
from .competition import Competition, Season
from .team import Team
from .match import Match
from .formation import Formation
from .player import Player, MatchPlayer
from .events import (
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)

__all__ = [
    'Competition',
    'Season',
    'Team',
    'Match',
    'Formation',
    'Player',
    'MatchPlayer',
    'PassEvent',
    'ShootingEvent',
    'DefendingEvent',
    'GoalkeeperEvent',
    'PossessionEvent',
    'SummaryEvent'
]

================
File: models/competition.py
================
from django.db import models


class Competition(models.Model):
    """Core competition/league information"""
    competition_id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('name', 'country')
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]

    def __str__(self):
        return f"{self.name} ({self.country})"


class Season(models.Model):
    """Season information for a competition"""
    season_id = models.AutoField(primary_key=True)
    competition = models.ForeignKey(Competition, on_delete=models.CASCADE)
    name = models.CharField(max_length=20)  # e.g., "2023/24"
    # start_date = models.DateField()
    # end_date = models.DateField()
    is_current = models.BooleanField(default=False)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('competition', 'name')
        indexes = [
            models.Index(fields=['is_current']),
        ]

    def __str__(self):
        return f"{self.competition.name} {self.name}"

================
File: models/formation.py
================
from django.db import models


class Formation(models.Model):
    """Store formation information for a team in a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)
    formation_name = models.CharField(max_length=10)  # e.g. "4231"
    captain_player_id = models.IntegerField()
    start_minute = models.IntegerField()
    end_minute = models.IntegerField()

    # Store player information
    player_ids = models.JSONField(default=list)
    jersey_numbers = models.JSONField(default=list)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['formation_name']),
            models.Index(fields=['captain_player_id']),
            models.Index(fields=['match', 'team']),
        ]
        # Add uniqueness constraint for formations
        unique_together = ('match', 'team', 'start_minute', 'end_minute')
        verbose_name = 'Match Formation'
        verbose_name_plural = 'Match Formations'

    def __str__(self):
        """
        Provides a detailed string representation of the Formation instance.
        """
        match_date = self.match.start_datetime.date()

        # Show the formation team first, then vs their opponent
        if self.team == self.match.home_team:
            opponent = self.match.away_team.name
        else:
            opponent = self.match.home_team.name

        return f"{self.team.name} formation ({self.formation_name}) vs {opponent} ({match_date})"

================
File: models/match.py
================
from django.db import models
from django.utils import timezone


class Match(models.Model):
    match_id = models.IntegerField(primary_key=True)
    season = models.ForeignKey('sbapi.Season', on_delete=models.CASCADE)

    # Date/Time fields
    start_datetime = models.DateTimeField()
    venue = models.CharField(max_length=200)
    attendance = models.IntegerField(null=True)

    # Referee information
    referee_id = models.IntegerField(null=True)
    referee_name = models.CharField(max_length=100, null=True)

    # Team relationships
    home_team = models.ForeignKey(
        'sbapi.Team', related_name='home_matches', on_delete=models.CASCADE)
    away_team = models.ForeignKey(
        'sbapi.Team', related_name='away_matches', on_delete=models.CASCADE)

    # Manager information (moved from MatchTeamStats)
    home_manager_name = models.CharField(max_length=100, null=True)
    away_manager_name = models.CharField(max_length=100, null=True)

    # Team average age (moved from MatchTeamStats)
    home_team_average_age = models.FloatField(null=True)
    away_team_average_age = models.FloatField(null=True)

    # Scores
    # score = models.CharField(max_length=10)
    home_score_ht = models.IntegerField()
    away_score_ht = models.IntegerField()
    home_score_ft = models.IntegerField()
    away_score_ft = models.IntegerField()
    home_score_et = models.IntegerField(null=True)
    away_score_et = models.IntegerField(null=True)

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['start_datetime']),
            models.Index(fields=['home_team']),
            models.Index(fields=['away_team']),
            models.Index(fields=['referee_id']),
            models.Index(fields=['season']),
        ]
        verbose_name = 'Match'
        verbose_name_plural = 'Matches'

    @property
    def competition(self):
        return self.season.competition

    @property
    def score(self):
        return f"{self.home_score_ft} : {self.away_score_ft}"

    def __str__(self):
        return f"{self.home_team} vs {self.away_team} ({self.start_datetime.date()})"

================
File: models/player.py
================
from django.db import models


class Player(models.Model):
    """Store player information"""
    player_id = models.IntegerField(primary_key=True)  # Changed to primary_key
    name = models.CharField(max_length=100)
    height = models.IntegerField(null=True)
    weight = models.IntegerField(null=True)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
        ]

    def __str__(self):
        return self.name


class MatchPlayer(models.Model):
    """Store player information specific to a match"""
    match = models.ForeignKey('sbapi.Match', on_delete=models.CASCADE)
    player = models.ForeignKey('sbapi.Player', on_delete=models.CASCADE)
    team = models.ForeignKey('sbapi.Team', on_delete=models.CASCADE)

    # Match-specific info
    shirt_no = models.IntegerField()
    position = models.CharField(max_length=20)  # e.g. 'GK'
    is_first_eleven = models.BooleanField()
    is_man_of_match = models.BooleanField(default=False)
    age = models.IntegerField()
    height = models.IntegerField(null=True)  # in cm
    weight = models.IntegerField(null=True)  # in kg

    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        unique_together = ('match', 'player', 'team')
        indexes = [
            models.Index(fields=['position']),
            models.Index(fields=['match', 'team']),
            models.Index(fields=['is_first_eleven']),
        ]
        verbose_name = 'Match - Player Information'
        verbose_name_plural = 'Matches - Player Information'

    def __str__(self):
        return f"{self.player.name} ({self.team.name}) - Match {self.match.match_id}"

    @property
    def match_date(self):
        return self.match.start_datetime.date()

================
File: models/team.py
================
from django.db import models


class Team(models.Model):
    """Team model representing a football team"""
    team_id = models.IntegerField(primary_key=True)
    name = models.CharField(max_length=100)
    country = models.CharField(max_length=100)
    created_at = models.DateTimeField(auto_now_add=True)
    last_updated = models.DateTimeField(auto_now=True)

    class Meta:
        indexes = [
            models.Index(fields=['name']),
            models.Index(fields=['country']),
        ]
        verbose_name = 'Team'
        verbose_name_plural = 'Teams'

    def __str__(self):
        return f"{self.name} ({self.country})"

================
File: services/loaders/event_loader.py
================
from django.db import transaction
import pandas as pd
import logging

from ...models.events import (
    PassEvent, ShootingEvent, DefendingEvent,
    GoalkeeperEvent, PossessionEvent, SummaryEvent
)
from ...models import Player

logger = logging.getLogger(__name__)


def load_match_events(match, events_df):
    """Loads all events for a match"""
    with transaction.atomic():
        for _, event in events_df.iterrows():
            try:
                # Skip 'Start' events
                event_type = str(event.get('type', '')).strip()
                if event_type == 'Start':
                    logger.info("Skipping 'Start' event")
                    continue

                # Get player if exists - safer conversion
                player = None
                if not pd.isna(event.get('playerId')):
                    try:
                        player = Player.objects.get(
                            player_id=int(float(event['playerId'])))
                    except (ValueError, Player.DoesNotExist):
                        logger.warning(
                            f"Player not found or invalid ID: {event['playerId']}")

                # Get team - with safety check
                team = match.home_team if str(
                    event.get('h_a', '')).lower() == 'h' else match.away_team

                # Base event data with safer gets
                base_event_data = {
                    'source_id': int(float(event.get('id', 0))),
                    'event_id': int(float(event.get('eventId', 0))),
                    'match': match,
                    'team': team,
                    'player': player,
                    'player_name': event.get('playerName') if not pd.isna(event.get('playerName')) else None,
                    'minute': event.get('minute'),
                    'second': float(event.get('second', 0.0)),
                    'expanded_minute': event.get('expandedMinute'),
                    'period': event.get('period'),
                    'max_minute': event.get('maxMinute'),
                    'x': event.get('x'),
                    'y': event.get('y'),
                    'touches': event.get('touches', False),
                    'is_touch': event.get('isTouch', False),
                    'end_x': event.get('endX') if not pd.isna(event.get('endX')) else None,
                    'end_y': event.get('endY') if not pd.isna(event.get('endY')) else None,
                    'defensive_third': bool(event.get('defensiveThird', False)),
                    'mid_third': bool(event.get('midThird', False)),
                    'final_third': bool(event.get('finalThird', False)),
                    'type': str(event.get('type', '')),
                    'outcome_type': event.get('outcomeType') if not pd.isna(event.get('outcomeType')) else None,
                    'related_event_id': event.get('relatedEventId') if not pd.isna(event.get('relatedEventId')) else None,
                    'related_player_id': event.get('relatedPlayerId') if not pd.isna(event.get('relatedPlayerId')) else None,
                    'h_a': str(event.get('h_a', '')),
                    'situation': str(event.get('situation')).strip() if pd.notna(event.get('situation')) else None,
                    'qualifiers': event.get('qualifiers').tolist() if hasattr(event.get('qualifiers'), 'tolist') else event.get('qualifiers', []),
                    'satisfied_events_types': event.get('satisfiedEventsTypes').tolist() if hasattr(event.get('satisfiedEventsTypes'), 'tolist') else event.get('satisfiedEventsTypes', [])
                }

                # Route to appropriate event handler
                try:
                    event_type = event.get('type', '')

                    # Pass events
                    if event_type == 'Pass':
                        _update_or_create_pass_event(event, base_event_data)

                    # Defending events
                    elif event_type in ['Tackle', 'Interception', 'Clearance', 'BallRecovery',
                                        'Aerial', 'Challenge', 'Error', 'BlockedPass'] or \
                            event.get('goalOwn', False) or \
                            event.get('sixYardBlock', False) or \
                            event.get('outfielderBlock', False):
                        _update_or_create_defending_event(
                            event, base_event_data)

                    # Goalkeeper events
                    elif event_type in ['Save', 'Smother', 'Punch', 'PenaltyFaced', 'CrossNotClaimed',
                                        'KeeperSweeper', 'KeeperPickup', 'Claim'] or \
                            any(event.get(f'keeper_{x}', False) for x in ['save', 'claim', 'punch']):
                        _update_or_create_goalkeeper_event(
                            event, base_event_data)

                    # Shooting events
                    elif event_type in ['Goal', 'Shot', 'SavedShot', 'ChanceMissed'] or event.get('isShot', False):
                        _update_or_create_shooting_event(
                            event, base_event_data)

                    # Possession events
                    elif event_type in ['BallTouch', 'TakeOn', 'Dispossessed', 'ShieldBallOpp']:
                        _update_or_create_possession_event(
                            event, base_event_data)

                    # Summary/other events
                    elif event_type in ['Card', 'SubstitutionOn', 'SubstitutionOff', 'Start', 'Foul', 'GoodSkill',
                                        'OffsideProvoked', 'OffsideGiven', 'OffsidePass', 'FormationSet',
                                        'FormationChange', 'CornerAwarded', 'End']:
                        _update_or_create_summary_event(event, base_event_data)

                    else:
                        logger.warning(f"Unhandled event type: {event_type}")

                except Exception as e:
                    logger.error(
                        f"Error processing event type {event_type}: {str(e)}")
                    continue

            except Exception as e:
                logger.error(
                    f"Error processing event {event.get('id')}: {str(e)}")
                continue


def _update_or_create_pass_event(event, base_data):
    """Updates or creates a passing event"""
    try:
        pass_data = {
            # Core pass attributes
            'pass_accurate': event.get('passAccurate', False),
            'pass_inaccurate': event.get('passInaccurate', False),
            'pass_accuracy': event.get('passAccuracy', False),

            # Assist types
            'assist': event.get('assist', False),
            'assist_corner': event.get('assistCorner', False),
            'assist_cross': event.get('assistCross', False),
            'assist_freekick': event.get('assistFreekick', False),
            'assist_other': event.get('assistOther', False),
            'assist_throughball': event.get('assistThroughball', False),
            'assist_throwin': event.get('assistThrowin', False),
            'intentional_assist': event.get('intentionalAssist', False),

            # Key pass types
            'key_pass_corner': event.get('keyPassCorner', False),
            'key_pass_cross': event.get('keyPassCross', False),
            'key_pass_freekick': event.get('keyPassFreekick', False),
            'key_pass_long': event.get('keyPassLong', False),
            'key_pass_other': event.get('keyPassOther', False),
            'key_pass_short': event.get('keyPassShort', False),
            'key_pass_throughball': event.get('keyPassThroughball', False),
            'key_pass_throwin': event.get('keyPassThrowin', False),
            'pass_key': event.get('passKey', False),

            # Corner passes
            'pass_corner': event.get('passCorner', False),
            'pass_corner_accurate': event.get('passCornerAccurate', False),
            'pass_corner_inaccurate': event.get('passCornerInaccurate', False),

            # Cross passes
            'pass_cross_accurate': event.get('passCrossAccurate', False),
            'pass_cross_blocked_defensive': event.get('passCrossBlockedDefensive', False),
            'pass_cross_inaccurate': event.get('passCrossInaccurate', False),

            # Freekick passes
            'pass_freekick': event.get('passFreekick', False),
            'pass_freekick_accurate': event.get('passFreekickAccurate', False),
            'pass_freekick_inaccurate': event.get('passFreekickInaccurate', False),

            # Direction/zone
            'pass_back': event.get('passBack', False),
            'pass_back_zone_inaccurate': event.get('passBackZoneInaccurate', False),
            'pass_forward': event.get('passForward', False),
            'pass_forward_zone_accurate': event.get('passForwardZoneAccurate', False),
            'pass_left': event.get('passLeft', False),
            'pass_right': event.get('passRight', False),

            # Pass types
            'pass_chipped': event.get('passChipped', False),
            'pass_head': event.get('passHead', False),
            'pass_left_foot': event.get('passLeftFoot', False),
            'pass_right_foot': event.get('passRightFoot', False),

            # Long/short passes
            'pass_long_ball_accurate': event.get('passLongBallAccurate', False),
            'pass_long_ball_inaccurate': event.get('passLongBallInaccurate', False),
            'short_pass_accurate': event.get('shortPassAccurate', False),
            'short_pass_inaccurate': event.get('shortPassInaccurate', False),

            # Through balls
            'pass_through_ball_accurate': event.get('passThroughBallAccurate', False),
            'pass_through_ball_inaccurate': event.get('passThroughBallInaccurate', False),

            # Additional characteristics
            'big_chance_created': event.get('bigChanceCreated', False),
            'successful_final_third_passes': event.get('successfulFinalThirdPasses', False),
            'throw_in': event.get('throwIn', False),
        }

        PassEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **pass_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating pass event: {str(e)}")
        raise


def _update_or_create_defending_event(event, base_data):
    """Updates or creates a defending event"""
    try:
        defending_data = {
            # Core defensive actions - determined by event type
            'is_tackle': event['type'] == 'Tackle',
            'is_interception': event['type'] == 'Interception',
            'is_clearance': event['type'] == 'Clearance',
            'is_ball_recovery': event['type'] == 'BallRecovery',

            # Aerial duels
            'aerial_success': event.get('aerialSuccess', False),
            'duel_aerial_lost': event.get('duelAerialLost', False),
            'duel_aerial_won': event.get('duelAerialWon', False),

            # Block details
            'blocked_x': event['blockedX'] if not pd.isna(event.get('blockedX')) else None,
            'blocked_y': event['blockedY'] if not pd.isna(event.get('blockedY')) else None,

            # Clearances
            'clearance_effective': event.get('clearanceEffective', False),
            'clearance_head': event.get('clearanceHead', False),
            'clearance_off_the_line': event.get('clearanceOffTheLine', False),
            'clearance_total': event.get('clearanceTotal', False),

            # Different types of duels
            'challenge_lost': event.get('challengeLost', False),
            'defensive_duel': event.get('defensiveDuel', False),
            'offensive_duel': event.get('offensiveDuel', False),

            # Defensive errors
            'error_leads_to_goal': event.get('errorLeadsToGoal', False),
            'error_leads_to_shot': event.get('errorLeadsToShot', False),
            'goal_own': event.get('goalOwn', False),

            # Interceptions
            'interception_all': event.get('interceptionAll', False),
            'interception_in_the_box': event.get('interceptionIntheBox', False),
            'interception_won': event.get('interceptionWon', False),

            # Blocks
            'outfielder_block': event.get('outfielderBlock', False),
            'outfielder_blocked_pass': event.get('outfielderBlockedPass', False),
            'six_yard_block': event.get('sixYardBlock', False),

            # Tackles
            'tackle_last_man': event.get('tackleLastMan', False),
            'tackle_lost': event.get('tackleLost', False),
            'tackle_won': event.get('tackleWon', False),

        }

        DefendingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **defending_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating defending event: {str(e)}")
        raise


def _update_or_create_shooting_event(event, base_data):
    try:
        shooting_data = {
            # Big chances
            'big_chance_missed': event.get('bigChanceMissed', False),
            'big_chance_scored': event.get('bigChanceScored', False),

            # Close misses
            'close_miss_high': event.get('closeMissHigh', False),
            'close_miss_high_left': event.get('closeMissHighLeft', False),
            'close_miss_high_right': event.get('closeMissHighRight', False),
            'close_miss_left': event.get('closeMissLeft', False),
            'close_miss_right': event.get('closeMissRight', False),

            # Goals
            'is_goal': event.get('isGoal', False),
            'goal_counter': event.get('goalCounter', False),
            'goal_head': event.get('goalHead', False),
            'goal_left_foot': event.get('goalLeftFoot', False),
            'goal_right_foot': event.get('goalRightFoot', False),
            'goal_normal': event.get('goalNormal', False),
            'goal_open_play': event.get('goalOpenPlay', False),
            'goal_set_piece': event.get('goalSetPiece', False),

            # Goal location
            'goal_obox': event.get('goalObox', False),
            'goal_obp': event.get('goalObp', False),
            'goal_penalty_area': event.get('goalPenaltyArea', False),
            'goal_six_yard_box': event.get('goalSixYardBox', False),
            'goal_mouth_y': event['goalMouthY'] if not pd.isna(event.get('goalMouthY')) else None,
            'goal_mouth_z': event['goalMouthZ'] if not pd.isna(event.get('goalMouthZ')) else None,

            # Shot flags
            'is_shot': event.get('isShot', False),
            'shot_blocked': event.get('shotBlocked', False),
            'shot_counter': event.get('shotCounter', False),
            'shot_direct_corner': event.get('shotDirectCorner', False),
            'shot_on_post': event.get('shotOnPost', False),
            'shot_on_target': event.get('shotOnTarget', False),
            'shot_off_target': event.get('shotOffTarget', False),
            'shot_off_target_inside_box': event.get('shotOffTargetInsideBox', False),
            'shots_total': event.get('shotsTotal', False),

            # Shot body part
            'shot_body_type': event['shotBodyType'] if not pd.isna(event.get('shotBodyType')) else None,
            'shot_head': event.get('shotHead', False),
            'shot_left_foot': event.get('shotLeftFoot', False),
            'shot_right_foot': event.get('shotRightFoot', False),

            # Shot location
            'shot_obox_total': event.get('shotOboxTotal', False),
            'shot_obp': event.get('shotObp', False),
            'shot_penalty_area': event.get('shotPenaltyArea', False),
            'shot_six_yard_box': event.get('shotSixYardBox', False),

            # Shot type
            'shot_open_play': event.get('shotOpenPlay', False),
            'shot_set_piece': event.get('shotSetPiece', False),

            # Penalties
            'penalty_missed': event.get('penaltyMissed', False),
            'penalty_scored': event.get('penaltyScored', False),
            'penalty_shootout_missed_off_target': event.get('penaltyShootoutMissedOffTarget', False),
            'penalty_shootout_scored': event.get('penaltyShootoutScored', False),
        }

        ShootingEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **shooting_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating shooting event: {str(e)}")
        raise


def _update_or_create_goalkeeper_event(event, base_data):
    try:
        """Creates a goalkeeper event with all keeper-specific fields"""
        goalkeeper_data = {
            # Core actions
            'is_collected': event.get('collected', False),

            # Claims
            'keeper_claim_high_lost': event.get('keeperClaimHighLost', False),
            'keeper_claim_high_won': event.get('keeperClaimHighWon', False),
            'keeper_claim_lost': event.get('keeperClaimLost', False),
            'keeper_claim_won': event.get('keeperClaimWon', False),

            # Save types
            'keeper_diving_save': event.get('keeperDivingSave', False),
            # failed to make a save on a penalty
            'keeper_missed': event.get('keeperMissed', False),
            'keeper_one_to_one_won': event.get('keeperOneToOneWon', False),
            'standing_save': event.get('standingSave', False),
            'save_feet': event.get('saveFeet', False),
            'save_hands': event.get('saveHands', False),

            # Save locations
            'save_high_centre': event.get('saveHighCentre', False),
            'save_high_left': event.get('saveHighLeft', False),
            'save_high_right': event.get('saveHighRight', False),
            'save_low_centre': event.get('saveLowCentre', False),
            'save_low_left': event.get('saveLowLeft', False),
            'save_low_right': event.get('saveLowRight', False),

            # Save zones
            'save_obox': event.get('saveObox', False),
            'save_obp': event.get('saveObp', False),  # save outside the box?
            'save_penalty_area': event.get('savePenaltyArea', False),
            'save_six_yard_box': event.get('saveSixYardBox', False),
            'keeper_save_in_the_box': event.get('keeperSaveInTheBox', False),
            'keeper_save_total': event.get('keeperSaveTotal', False),

            # Penalties
            'keeper_penalty_saved': event.get('keeperPenaltySaved', False),
            'penalty_shootout_saved': event.get('penaltyShootoutSaved', False),
            'penalty_shootout_saved_gk': event.get('penaltyShootoutSavedGK', False),
            'penalty_shootout_conceded_gk': event.get('penaltyShootoutConcededGK', False),

            # Other actions
            'keeper_smother': event.get('keeperSmother', False),
            'keeper_sweeper_lost': event.get('keeperSweeperLost', False),
            'parried_danger': event.get('parriedDanger', False),
            'parried_safe': event.get('parriedSafe', False),
            'punches': event.get('punches', False),
        }

        GoalkeeperEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **goalkeeper_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating goalkeeper event: {str(e)}")
        raise


def _update_or_create_possession_event(event, base_data):

    try:
        """Creates a possession event with all possession-specific fields"""
        possession_data = {
            # Set pieces
            'corner_awarded': event.get('cornerAwarded', False),

            # Ball control
            'dispossessed': event.get('dispossessed', False),
            'turnover': event.get('turnover', False),
            'overrun': event.get('overrun', False),

            # Dribbling
            'dribble_lastman': event.get('dribbleLastman', False),
            'dribble_lost': event.get('dribbleLost', False),
            'dribble_won': event.get('dribbleWon', False),
        }

        PossessionEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **possession_data}
        )

    except Exception as e:
        logger.error(f"Error creating/updating possession event: {str(e)}")
        raise


def _update_or_create_summary_event(event, base_data):

    try:

        """Creates a summary event with all summary-specific fields"""
        summary_data = {
            # Cards
            'card_type': event['cardType'] if not pd.isna(event.get('cardType')) and event['cardType'] != 'False' else None,
            'yellow_card': event.get('yellowCard', False),
            'red_card': event.get('redCard', False),
            'second_yellow': event.get('secondYellow', False),
            'void_yellow_card': event.get('voidYellowCard', False),

            # Substitutions
            'sub_on': event.get('subOn', False),
            'sub_off': event.get('subOff', False),

            # Fouls
            'foul_committed': event.get('foulCommitted', False),
            'foul_given': event.get('foulGiven', False),
            'penalty_conceded': event.get('penaltyConceded', False),
            'penalty_won': event.get('penaltyWon', False),

            # Offsides
            'offside_given': event.get('offsideGiven', False),
            'offside_provoked': event.get('offsideProvoked', False),
        }

        SummaryEvent.objects.update_or_create(
            match=base_data['match'],
            source_id=base_data['source_id'],
            defaults={**base_data, **summary_data}
        )
    except Exception as e:
        logger.error(f"Error creating/updating summary event: {str(e)}")
        raise

================
File: services/loaders/match_loader.py
================
from typing import Dict, Any, Tuple, Optional
import logging
from datetime import datetime
from dataclasses import dataclass
from django.db import transaction
from django.core.exceptions import ValidationError
from django.db.models import Model
from django.utils import timezone
import pytz

from ...models import (
    Competition,
    Season,
    Team,
    Match,
    Formation,
    Player,
    MatchPlayer
)

# Initialise
uk_tz = pytz.timezone('Europe/London')
logger = logging.getLogger(__name__)


@dataclass
class ScoreData:
    """Structured container for match score data"""
    home: int
    away: int

    @classmethod
    def from_string(cls, score_str: str) -> 'ScoreData':
        """Parse score string in format '0:0' into ScoreData object"""
        try:
            home, away = map(int, score_str.split(':'))
            return cls(home=home, away=away)
        except (ValueError, AttributeError) as e:
            raise ValidationError(f"Invalid score format: {score_str}") from e


class MatchDataValidator:
    """Handles validation of match data"""

    REQUIRED_MATCH_FIELDS = {
        'matchId', 'league', 'region', 'season', 'home', 'away',
        'startDate', 'startTime', 'venueName', 'score', 'htScore', 'ftScore'
    }

    REQUIRED_TEAM_FIELDS = {
        'teamId', 'name', 'averageAge', 'managerName',
        'countryName', 'scores', 'stats', 'formations', 'players'
    }

    @classmethod
    def validate(cls, data: Dict[str, Any]) -> None:
        """Validate all match data"""
        cls._validate_required_fields(data, cls.REQUIRED_MATCH_FIELDS, "match")
        cls._validate_scores(data)
        cls._validate_teams(data)

    @staticmethod
    def _validate_required_fields(
            data: Dict[str, Any], required_fields: set, context: str) -> None:
        """Check for presence of required fields"""
        missing = required_fields - data.keys()
        if missing:
            raise ValidationError(
                f"Missing required {context} fields: {', '.join(sorted(missing))}")

    @classmethod
    def _validate_teams(cls, data: Dict[str, Any]) -> None:
        """Validate both teams' data"""
        for venue in ['home', 'away']:
            team_data = data.get(venue, {})
            if not isinstance(team_data, dict):
                raise ValidationError(f"Invalid {venue} team data format")
            cls._validate_required_fields(
                team_data, cls.REQUIRED_TEAM_FIELDS, f"{venue} team")

    @staticmethod
    def _validate_scores(data: Dict[str, Any]) -> None:
        """Validate all score fields"""
        for field in ['score', 'htScore', 'ftScore']:
            # Will raise ValidationError if invalid
            ScoreData.from_string(data[field])


class MatchLoader:
    """Handles loading match data into the database"""

    def __init__(self):
        self.validator = MatchDataValidator()

    @transaction.atomic
    def load_match(self, match_data: Dict[str, Any]) -> Model:
        """
        Load match data into database with transaction handling

        Args:
            match_data: Dictionary containing match data

        Returns:
            Match: Created Match instance

        Raises:
            ValidationError: If data validation fails
            Exception: For other errors during loading
        """
        try:
            # Validate all input data
            self.validator.validate(match_data)

            # Load core match data
            competition, season = self._get_or_create_competition_and_season(
                match_data)
            teams = self._create_teams(match_data)
            match = self._create_match(match_data, competition, season, teams)

            # Load related data
            self._create_formations(match, match_data, teams)
            self._create_players(match, match_data, teams)

            logger.info(f"Successfully loaded match {match_data['matchId']}")
            return match

        except ValidationError as e:
            logger.error(
                f"Validation error for match {match_data.get('matchId')}: {str(e)}")
            raise
        except Exception as e:
            logger.error(
                f"Error loading match {match_data.get('matchId')}: {str(e)}")
            raise

    def _get_or_create_competition_and_season(
            self, data: Dict[str, Any]) -> Tuple[Model, Model]:
        """Create or retrieve competition and season"""
        try:
            # First get or create the competition
            competition, _ = Competition.objects.get_or_create(
                name=data['league'],
                country=data['region']
            )

            # Parse the season name from the data
            season_name = data['season']  # e.g., "2023/24"

            # Get or create the season
            season, created = Season.objects.get_or_create(
                competition=competition,
                name=season_name,
                defaults={
                    'is_current': False  # This should be managed separately
                }
            )

            if created:
                logger.info(f"Created new season: {season}")

            return competition, season
        except Exception as e:
            logger.error(f"Error creating competition and season: {str(e)}")
            raise

    def _create_teams(self, data: Dict[str, Any]) -> Dict[str, Model]:
        """Create or retrieve both teams"""
        teams = {}
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team, created = Team.objects.get_or_create(
                    team_id=team_data['teamId'],
                    defaults={
                        'name': team_data['name'],
                        'country': data['region']
                    }
                )
                if created:
                    logger.info(f"Created new team: {team}")
                else:
                    logger.info(f"Updated team: {team}")
                teams[venue] = team
            return teams
        except Exception as e:
            logger.error(f"Error creating or updating teams: {str(e)}")
            raise

    def _create_match(self, data: Dict[str, Any], competition: Model,
                      season: Model, teams: Dict[str, Model]) -> Model:
        """Create or update the main match record"""

        start_datetime = None

        try:
            # Parse all scores
            ht_score = ScoreData.from_string(data['htScore'])
            ft_score = ScoreData.from_string(data['ftScore'])
            et_score = None
            if data.get('etScore'):
                et_score = ScoreData.from_string(data['etScore'])

            # Parse the datetime
            start_datetime = None
            try:
                if 'T' in data['startDate']:
                    # New format: "2023-11-06T00:00:00"
                    start_date = datetime.strptime(
                        data['startDate'].split('T')[0], "%Y-%m-%d")
                    # New format: "2023-11-06T20:00:00"
                    start_time = datetime.strptime(
                        data['startTime'].split('T')[1], "%H:%M:%S")
                    start_datetime = datetime.combine(
                        start_date.date(), start_time.time())
                    # Add timezone info
                    start_datetime = uk_tz.localize(start_datetime)
                else:
                    # Old format handling
                    start_datetime = datetime.strptime(
                        f"{data['startDate']} {data['startTime']}",
                        "%Y-%m-%d %H:%M:%S"
                    )
                    # Add timezone info here too
                    start_datetime = uk_tz.localize(start_datetime)

            except (ValueError, TypeError) as e:
                logger.error(f"Error parsing datetime: {e}")
                raise ValidationError(
                    f"Invalid datetime format: {data['startDate']} {data['startTime']}")

            defaults = {
                'season': season,  # Add season reference
                'start_datetime': start_datetime,
                'venue': data['venueName'],
                'attendance': data.get('attendance'),
                'referee_id': data.get('referee', {}).get('officialId'),
                'referee_name': data.get('referee', {}).get('name'),
                # 'score': data['score'],
                'home_team': teams['home'],
                'away_team': teams['away'],
                'home_score_ht': ht_score.home,
                'away_score_ht': ht_score.away,
                'home_score_ft': ft_score.home,
                'away_score_ft': ft_score.away,
                'home_score_et': et_score.home if et_score else None,
                'away_score_et': et_score.away if et_score else None,
                'home_manager_name': data['home']['managerName'],
                'away_manager_name': data['away']['managerName'],
                'home_team_average_age': data['home']['averageAge'],
                'away_team_average_age': data['away']['averageAge']
            }

            match, created = Match.objects.update_or_create(
                match_id=data['matchId'],
                defaults=defaults
            )

            action = "Created new" if created else "Updated existing"
            logger.info(f"{action} match: {match}")

            return match

        except Exception as e:
            logger.error(
                f"Error creating or updating match {data.get('matchId')}: {str(e)}")
            raise

    def _create_formations(
            self, match: Model, data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update formation records for both teams"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                for formation_data in team_data['formations']:
                    # Extract formation details
                    formation_name = formation_data['formationName']
                    captain_id = formation_data['captainPlayerId']

                    # Get the full minute range
                    start_minute = formation_data.get(
                        'startMinuteExpanded', 0)  # Default to 0 if not specified
                    end_minute = formation_data.get(
                        'endMinuteExpanded', 90)  # Default to 90 if not specified

                    # Create or update formation record
                    Formation.objects.update_or_create(
                        match=match,
                        team=teams[venue],
                        start_minute=start_minute,
                        end_minute=end_minute,  # Add this to uniqueness constraint
                        defaults={
                            'formation_name': formation_name,
                            'captain_player_id': captain_id,
                            'player_ids': formation_data.get('playerIds', []),
                            'jersey_numbers': formation_data.get('jerseyNumbers', [])
                        }
                    )

                    logger.info(
                        f"Created/updated formation for {teams[venue].name}: "
                        f"{formation_name} ({start_minute}-{end_minute})"
                    )

        except Exception as e:
            logger.error(f"Error creating/updating formations: {str(e)}")
            logger.error(f"Formation data: {formation_data}")
            raise

    def _create_players(self, match: Model,
                        data: Dict[str, Any], teams: Dict[str, Model]) -> None:
        """Create or update player records and match-player relationships"""
        try:
            for venue in ['home', 'away']:
                team_data = data[venue]
                team = teams[venue]

                for player_data in team_data['players']:
                    # First update or create the base player record
                    try:
                        player, player_created = Player.objects.update_or_create(
                            player_id=player_data['playerId'],
                            defaults={
                                'name': player_data['name'],
                                'height': player_data.get('height'),
                                'weight': player_data.get('weight'),
                            }
                        )

                        # Then update or create the match-specific player
                        # record
                        MatchPlayer.objects.update_or_create(
                            match=match,
                            player=player,
                            team=team,
                            defaults={
                                'shirt_no': player_data['shirtNo'],
                                'position': player_data['position'],
                                # 'field': player_data['field'],
                                'is_first_eleven': player_data.get('isFirstEleven', False),
                                'is_man_of_match': player_data.get('isManOfTheMatch', False),
                                'age': player_data.get('age', 0),
                                'height': player_data.get('height', 0),
                                'weight': player_data.get('weight', 0),
                                # 'stats': player_data.get('stats', {})
                            }
                        )

                    except Exception as e:
                        logger.error(
                            f"Error processing player {player_data.get('playerId')}: {str(e)}")
                        raise

        except Exception as e:
            logger.error(f"Error creating/updating players: {str(e)}")
            raise

================
File: services/main/main.py
================
# -*- coding: utf-8 -*-
"""
Created on Wed Oct 14 14:20:02 2020

@author: aliha
@twitter: rockingAli5
"""

import re
from selenium.webdriver.common.by import By
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import NoSuchElementException, WebDriverException
from selenium import webdriver
import numpy as np
import itertools
from datetime import datetime as dt
import datetime
from collections import OrderedDict
from bs4 import BeautifulSoup as soup
import json
import warnings
import time
import pandas as pd
pd.options.mode.chained_assignment = None
try:
    from tqdm import trange
except ModuleNotFoundError:
    pass


options = webdriver.ChromeOptions()

options.add_experimental_option('excludeSwitches', ['enable-logging'])


TRANSLATE_DICT = {'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mac': 'Mar',
                  'Apr': 'Apr',
                  'Mei': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Ago': 'Aug',
                  'Sep': 'Sep',
                  'Okt': 'Oct',
                  'Nov': 'Nov',
                  'Des': 'Dec',
                  'Jan': 'Jan',
                  'Feb': 'Feb',
                  'Mar': 'Mar',
                  'Apr': 'Apr',
                  'May': 'May',
                  'Jun': 'Jun',
                  'Jul': 'Jul',
                  'Aug': 'Aug',
                  'Sep': 'Sep',
                  'Oct': 'Oct',
                  'Nov': 'Nov',
                  'Dec': 'Dec'}

main_url = 'https://1xbet.whoscored.com/'


def getLeagueUrls(minimize_window=True):

    driver = webdriver.Chrome()

    if minimize_window:
        driver.minimize_window()

    driver.get(main_url)
    league_names = []
    league_urls = []
    try:
        cookie_button = driver.find_element(
            By.XPATH, '//*[@class=" css-gweyaj"]').click()
    except NoSuchElementException:
        pass
    tournaments_btn = driver.find_element(
        By.XPATH, '//*[@id="All-Tournaments-btn"]').click()
    n_button = soup(driver.find_element(
        By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[1]/div/div').get_attribute('innerHTML')).find_all('button')
    n_tournaments = []
    for button in n_button:
        id_button = button.get('id')
        driver.find_element(By.ID, id_button).click()
        n_country = soup(driver.find_element(By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute(
            'innerHTML')).find_all('div', {'class': 'TournamentsDropdownMenu-module_countryDropdownContainer__I9P6n'})

        for country in n_country:
            country_id = country.find(
                'div', {'class': 'TournamentsDropdownMenu-module_countryDropdown__8rtD-'}).get('id')

            # Trouver l'élément avec Selenium et cliquer dessus
            country_element = driver.find_element(By.ID, country_id)
            country_element.click()

            html_tournaments_list = driver.find_element(
                By.XPATH, '//*[@id="header-wrapper"]/div/div/div/div[4]/div[2]/div/div/div/div[2]').get_attribute('innerHTML')

            # Parse le HTML avec BeautifulSoup pour trouver les liens des
            # tournois
            soup_tournaments = soup(html_tournaments_list, 'html.parser')
            tournaments = soup_tournaments.find_all('a')

            # Ajouter les tournois à la liste n_tournaments
            n_tournaments.extend(tournaments)

            driver.execute_script("arguments[0].click();", country_element)

    for tournament in n_tournaments:
        league_name = tournament.get('href').split('/')[-1]
        league_link = main_url[:-1] + tournament.get('href')
        league_names.append(league_name)
        league_urls.append(league_link)

    leagues = {}
    for name, link in zip(league_names, league_urls):
        leagues[name] = link

    driver.close()
    return leagues


def getMatchUrls(comp_urls, competition, season, maximize_window=True):

    driver = webdriver.Chrome()

    if maximize_window:
        driver.maximize_window()

    comp_url = comp_urls[competition]
    driver.get(comp_url)
    time.sleep(5)

    seasons = driver.find_element(
        By.XPATH, '//*[@id="seasons"]').get_attribute('innerHTML').split(sep='\n')
    seasons = [i for i in seasons if i]

    for i in range(1, len(seasons) + 1):
        if driver.find_element(
            By.XPATH, '//*[@id="seasons"]/option[' + str(i) + ']').text == season:
            driver.find_element(
                By.XPATH, '//*[@id="seasons"]/option[' + str(i) + ']').click()

            time.sleep(5)
            try:
                stages = driver.find_element(
                    By.XPATH, '//*[@id="stages"]').get_attribute('innerHTML').split(sep='\n')
                stages = [i for i in stages if i]

                all_urls = []

                for i in range(1, len(stages) + 1):
                    print(driver.find_element(
                        By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').text)
                    if competition == 'Champions League' or competition == 'Europa League':
                        if 'Grp' in driver.find_element(By.XPATH, '//*[@id="stages"]/option[' + str(
                            i) + ']').text or 'Final Stage' in driver.find_element(By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    elif competition == 'Major League Soccer':
                        if 'Grp. ' not in driver.find_element(
                            By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').text:
                            driver.find_element(
                                By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').click()
                            time.sleep(5)

                            driver.execute_script("window.scrollTo(0, 400)")

                            match_urls = getFixtureData(driver)

                            match_urls = getSortedData(match_urls)

                            match_urls2 = [
                                url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                            all_urls += match_urls2
                        else:
                            continue

                    else:
                        driver.find_element(
                            By.XPATH, '//*[@id="stages"]/option[' + str(i) + ']').click()
                        time.sleep(5)

                        driver.execute_script("window.scrollTo(0, 400)")

                        match_urls = getFixtureData(driver)

                        match_urls = getSortedData(match_urls)

                        match_urls2 = [
                            url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                        all_urls += match_urls2

            except NoSuchElementException:
                all_urls = []

                driver.execute_script("window.scrollTo(0, 400)")

                match_urls = getFixtureData(driver)

                match_urls = getSortedData(match_urls)

                match_urls2 = [
                    url for url in match_urls if '?' not in url['date'] and '\n' not in url['date']]

                all_urls += match_urls2

            remove_dup = [dict(t) for t in {tuple(
                sorted(d.items())) for d in all_urls}]
            all_urls = getSortedData(remove_dup)

            driver.close()

            return all_urls

    season_names = [re.search(r'\>(.*?)\<', season).group(1)
                    for season in seasons]
    driver.close()
    print('Seasons available: {}'.format(season_names))
    raise ('Season Not Found.')


def getTeamUrls(team, match_urls):

    team_data = []
    for fixture in match_urls:
        if fixture['home'] == team or fixture['away'] == team:
            team_data.append(fixture)
    team_data = [a[0] for a in itertools.groupby(team_data)]

    return team_data


def getMatchesData(match_urls, minimize_window=True):

    matches = []

    driver = webdriver.Chrome()
    if minimize_window:
        driver.minimize_window()

    try:
        for i in trange(len(match_urls), desc='Getting Match Data'):
            # recommended to avoid getting blocked by incapsula/imperva bots
            time.sleep(7)
            match_data = getMatchData(
                driver, main_url + match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)
    except NameError:
        print('Recommended: \'pip install tqdm\' for a progress bar while the data gets scraped....')
        time.sleep(7)
        for i in range(len(match_urls)):
            match_data = getMatchData(
                driver, main_url + match_urls[i]['url'], display=False, close_window=False)
            matches.append(match_data)

    driver.close()

    return matches


def getFixtureData(driver):
    matches_ls = []
    while True:
        initial = driver.page_source
        all_fixtures = driver.find_elements(
            By.CLASS_NAME, 'Accordion-module_accordion__UuHD0')
        for dates in all_fixtures:
            fixtures = dates.find_elements(
                By.CLASS_NAME, 'Match-module_row__zwBOn')
            date_row = dates.find_element(
                By.CLASS_NAME, 'Accordion-module_header__HqzWD')
            for row in fixtures:
                url = row.find_element(By.TAG_NAME, 'a')
                if 'Live' in url.get_attribute('href'):
                    match_dict = {}
                    element = soup(row.get_attribute(
                        'innerHTML'), features='lxml')
                    teams_tag = element.find(
                        "div", {"class": "Match-module_teams__sGVeq"})
                    link_tag = element.find("a")
                    match_dict['date'] = date_row.text
                    match_dict['home'] = teams_tag.find_all('a')[0].text
                    match_dict['away'] = teams_tag.find_all('a')[1].text
                    match_dict['score'] = ':'.join(
                        [t.text for t in link_tag.find_all('span')])
                    match_dict['url'] = link_tag['href']
                    matches_ls.append(match_dict)
        prev_btn = driver.find_element(By.ID, 'dayChangeBtn-prev')
        prev_btn.click()
        time.sleep(1)
        final = driver.page_source
        if initial == final:
            break

    return matches_ls


def translateDate(data):

    unwanted = []
    for match in data:
        date = match['date'].split()
        if '?' not in date[0]:
            try:
                match['date'] = ' '.join(
                    [TRANSLATE_DICT[date[0]], date[1], date[2]])
            except KeyError:
                print(date)
        else:
            unwanted.append(data.index(match))

    # remove matches that got suspended/postponed
    for i in sorted(unwanted, reverse=True):
        del data[i]

    return data


def getSortedData(data):
    data = sorted(data, key=lambda i: dt.strptime(i['date'], '%A, %b %d %Y'))
    return data


def getMatchData(driver, url, display=True, close_window=True):
    try:
        driver.get(url)
    except WebDriverException:
        driver.get(url)

    time.sleep(5)
    # get script data from page source
    script_content = driver.find_element(
        By.XPATH, '//*[@id="layout-wrapper"]/script[1]').get_attribute('innerHTML')

    # clean script content
    script_content = re.sub(r"[\n\t]*", "", script_content)
    script_content = script_content[script_content.index(
        "matchId"):script_content.rindex("}")]

    # this will give script content in list form
    script_content_list = list(
        filter(None, script_content.strip().split(',            ')))
    metadata = script_content_list.pop(1)

    # string format to json format
    match_data = json.loads(metadata[metadata.index('{'):])
    keys = [item[:item.index(':')].strip() for item in script_content_list]
    values = [item[item.index(':') + 1:].strip()
                              for item in script_content_list]
    for key, val in zip(keys, values):
        match_data[key] = json.loads(val)

    # get other details about the match
    region = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/span[1]').text
    league = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[0]
    season = driver.find_element(
        By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[1]
    if len(driver.find_element(By.XPATH,
           '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 2:
        competition_type = 'League'
        competition_stage = ''
    elif len(driver.find_element(By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')) == 3:
        competition_type = 'Knock Out'
        competition_stage = driver.find_element(
            By.XPATH, '//*[@id="breadcrumb-nav"]/a').text.split(' - ')[-1]
    else:
        print('Getting more than 3 types of information about the competition.')

    match_data['region'] = region
    match_data['league'] = league
    match_data['season'] = season
    match_data['competitionType'] = competition_type
    match_data['competitionStage'] = competition_stage

    # sort match_data dictionary alphabetically
    match_data = OrderedDict(sorted(match_data.items()))
    match_data = dict(match_data)
    if display:
        print('Region: {}, League: {}, Season: {}, Match Id: {}'.format(
            region, league, season, match_data['matchId']))

    if close_window:
        driver.close()

    return match_data


def createEventsDF(data):
    events = data['events']
    for event in events:
        event.update({'matchId': data['matchId'],
                      'startDate': data['startDate'],
                      'startTime': data['startTime'],
                      'score': data['score'],
                      'ftScore': data['ftScore'],
                      'htScore': data['htScore'],
                      'etScore': data['etScore'],
                      'venueName': data['venueName'],
                      'maxMinute': data['maxMinute']})
    events_df = pd.DataFrame(events)

    # clean period column
    events_df['period'] = pd.json_normalize(events_df['period'])['displayName']

    # clean type column
    events_df['type'] = pd.json_normalize(events_df['type'])['displayName']

    # clean outcomeType column
    events_df['outcomeType'] = pd.json_normalize(
        events_df['outcomeType'])['displayName']

    # clean outcomeType column
    try:
        x = events_df['cardType'].fillna({i: {} for i in events_df.index})
        events_df['cardType'] = pd.json_normalize(
            x)['displayName'].fillna(False)
    except KeyError:
        events_df['cardType'] = False

    eventTypeDict = data['matchCentreEventTypeJson']
    events_df['satisfiedEventsTypes'] = events_df['satisfiedEventsTypes'].apply(
        lambda x: [list(eventTypeDict.keys())[list(eventTypeDict.values()).index(event)] for event in x])

    # clean qualifiers column
    try:
        for i in events_df.index:
            row = events_df.loc[i, 'qualifiers'].copy()
            if len(row) != 0:
                for irow in range(len(row)):
                    row[irow]['type'] = row[irow]['type']['displayName']
    except TypeError:
        pass

    # clean isShot column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        if 'isShot' in events_df.columns:
            events_df['isShot'] = events_df['isShot'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isShot'] = False

        # clean isGoal column
        if 'isGoal' in events_df.columns:
            events_df['isGoal'] = events_df['isGoal'].replace(
                np.nan, False).infer_objects(copy=False)
        else:
            events_df['isGoal'] = False

    # add player name column
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        events_df.loc[events_df.playerId.notna(
        ), 'playerId'] = events_df.loc[events_df.playerId.notna(), 'playerId'].astype(int).astype(str)
    player_name_col = events_df.loc[:, 'playerId'].map(
        data['playerIdNameDictionary'])
    events_df.insert(loc=events_df.columns.get_loc("playerId") + 1,
                     column='playerName', value=player_name_col)

    # add home/away column
    h_a_col = events_df['teamId'].map(
        {data['home']['teamId']: 'h', data['away']['teamId']: 'a'})
    events_df.insert(loc=events_df.columns.get_loc(
        "teamId") + 1, column='h_a', value=h_a_col)

    # adding shot body part column
    events_df['shotBodyType'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'RightFoot' or j['type'] == 'LeftFoot' or j['type'] == 'Head' or j['type'] == 'OtherBodyPart':
                    events_df.loc[i, 'shotBodyType'] = j['type']

    # adding shot situation column
    events_df['situation'] = np.nan
    with warnings.catch_warnings():
        warnings.simplefilter("ignore", category=FutureWarning)
        for i in events_df.loc[events_df.isShot == True].index:
            for j in events_df.loc[events_df.isShot == True].qualifiers.loc[i]:
                if j['type'] == 'FromCorner' or j['type'] == 'SetPiece' or j['type'] == 'DirectFreekick':
                    events_df.loc[i, 'situation'] = j['type']
                if j['type'] == 'RegularPlay':
                    events_df.loc[i, 'situation'] = 'OpenPlay'

    event_types = list(data['matchCentreEventTypeJson'].keys())
    event_type_cols = pd.DataFrame({event_type: pd.Series(
        [event_type in row for row in events_df['satisfiedEventsTypes']]) for event_type in event_types})
    events_df = pd.concat([events_df, event_type_cols], axis=1)

    return events_df


def createMatchesDF(data):
    columns_req_ls = ['matchId', 'attendance', 'venueName', 'startTime', 'startDate',
                      'score', 'home', 'away', 'referee']
    matches_df = pd.DataFrame(columns=columns_req_ls)


if isinstance(data,     if )        matches_dict = dict(
            [(key, val) for key, val in data.items() if key in columns_req_ls])
        matches_df = pd.DataFrame(
            matches_dict, columns=columns_req_ls).reset_index(drop=True)
        matches_df[['home', 'away']] = np.nan
        with warnings.catch_warnings():
            warnings.simplefilter("ignore", category=FutureWarning)
            matches_df['home'].iloc[0] = [data['home']]
            matches_df['away'].iloc[0] = [data['away']]
    else:
        for match in data:
            matches_dict = dict(
                [(key, val) for key, val in match.items() if key in columns_req_ls])
            matches_df = pd.DataFrame(
                matches_dict, columns=columns_req_ls).reset_index(drop=True)

    matches_df = matches_df.set_index('matchId')
    return matches_df


def load_EPV_grid(fname='EPV_grid.csv'):
    """ load_EPV_grid(fname='EPV_grid.csv')

    # load pregenerated EPV surface from file.

    Parameters
    -----------
        fname: filename & path of EPV grid (default is 'EPV_grid.csv' in the curernt directory)

    Returns
    -----------
        EPV: The EPV surface (default is a (32,50) grid)

    """
    epv = np.loadtxt(fname, delimiter=',')
    return epv


def get_EPV_at_location(position, EPV, attack_direction,
                        field_dimen=(106., 68.)):
    """ get_EPV_at_location

    Returns the EPV value at a given (x,y) location

    Parameters
    -----------
        position: Tuple containing the (x,y) pitch position
        EPV: tuple Expected Possession value grid (loaded using load_EPV_grid() )
        attack_direction: Sets the attack direction (1: left->right, -1: right->left)
        field_dimen: tuple containing the length and width of the pitch in meters. Default is (106,68)

    Returrns
    -----------
        EPV value at input position

    """

    x, y = position
    if abs(x) > field_dimen[0] /2. or abs(y) > field_dimen[1]/2.:
        return 0.0  # Position is off the field, EPV is zero
    else:
        if attack_direction == -1:
            EPV = np.fliplr(EPV)
        ny, nx = EPV.shape
        dx = field_dimen[0] /float(nx)
        dy = field_dimen[1] /float(ny)
        ix = (x +field_dimen[0] /2. -0.0001) /dx
        iy = (y +field_dimen[1] /2. -0.0001) /dy
        return EPV[int(iy), int(ix)]


def to_metric_coordinates_from_whoscored(data, field_dimen=(106., 68.)):
    '''
    Convert positions from Whoscored units to meters (with origin at centre circle)
    '''
    x_columns = [c for c in data.columns if c[-1].lower() == 'x'][:2]
    y_columns = [c for c in data.columns if c[-1].lower() == 'y'][:2]
    x_columns_mod = [c +'_metrica' for c in x_columns]
    y_columns_mod = [c +'_metrica' for c in y_columns]
    data[x_columns_mod] = (data[x_columns] /100 *106) -53
    data[y_columns_mod] = (data[y_columns] /100 *68) -34
    return data


def addEpvToDataFrame(data):

    # loading EPV data
    EPV = load_EPV_grid('EPV_grid.csv')

    # converting opta coordinates to metric coordinates
    data = to_metric_coordinates_from_whoscored(data)

    # calculating EPV for events
    EPV_difference = []
    for i in data.index:
        if data.loc[i, 'type'] == 'Pass' and data.loc[i,
            'outcomeType'] == 'Successful':
            start_pos = (data.loc[i, 'x_metrica'], data.loc[i, 'y_metrica'])
            start_epv = get_EPV_at_location(start_pos, EPV, attack_direction=1)

            end_pos = (data.loc[i, 'endX_metrica'],
                       data.loc[i, 'endY_metrica'])
            end_epv = get_EPV_at_location(end_pos, EPV, attack_direction=1)

            diff = end_epv - start_epv
            EPV_difference.append(diff)

        else:
            EPV_difference.append(np.nan)

    data = data.assign(EPV_difference=EPV_difference)

    # dump useless columns
    drop_cols = ['x_metrica', 'endX_metrica', 'y_metrica',
                 'endY_metrica']
    data.drop(drop_cols, axis=1, inplace=True)
    data.rename(columns={'EPV_difference': 'EPV'}, inplace=True)

    return data

================
File: services/main/test.py
================
# import relevant functions
from main import getLeagueUrls, getMatchUrls, getTeamUrls, getMatchesData, getMatchData, createEventsDF, createMatchesDF, addEpvToDataFrame

# import relevant variables
from main import main_url

# import relevant packages
import pandas as pd

from selenium import webdriver
options = webdriver.ChromeOptions()
options.add_experimental_option('excludeSwitches', ['enable-logging'])


# write test functions for all functions in file
def test():
    print('Testing getLeagueUrls function...')
    leagues = getLeagueUrls()


assert isinstance(leagues,     assert )    assert len(leagues) == 23
print('getLeagueUrls function passed all tests.')

print('Testing getMatchUrls function...')
comp_urls = getLeagueUrls()
match_urls = getMatchUrls(comp_urls, 'Premier League', '2019/2020')
assert isinstance(match_urls,     assert )    assert len(match_urls) == 380
print('getMatchUrls function passed all tests.')

print('Testing getTeamUrls function...')
team_urls = getTeamUrls('Liverpool', match_urls)
assert isinstance(team_urls,     assert )    assert len(team_urls) == 38
print('getTeamUrls function passed all tests.')

print('Testing getMatchesData function...')
matches = getMatchesData(team_urls)
assert isinstance(matches,     assert )    assert len(matches) == 38
print('getMatchesData function passed all tests.')

print('Testing getMatchData function...')
driver = webdriver.Chrome('drivers/chromedriver.exe', options=options)
match_data = getMatchData(
    driver, main_url + '/Matches/1375927/Live/England-Premier-League-2019-2020-Liverpool-Norwich')
assert isinstance(match_data,     assert )    assert len(match_data) == 36
print('getMatchData function passed all tests.')

print('Testing createEventsDF function...')
events_df = createEventsDF(match_data)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 259
print('createEventsDF function passed all tests.')

print('Testing createMatchesDF function...')
matches_df = createMatchesDF(match_data)
assert isinstance(matches_df,     assert )    assert matches_df.shape[1] == 8
print('createMatchesDF function passed all tests.')

print('Testing addEpvToDataFrame function...')
events_df = addEpvToDataFrame(events_df)
assert isinstance(events_df,     assert )    assert events_df.shape[1] == 260
print('addEpvToDataFrame function passed all tests.')

print('All tests passed.')


if __name__ == '__main__':
    test()

================
File: services/main/utils.py
================
import os
import re
from sys import platform


def extract_version_registry(output):
    try:
        google_version = ''
        for letter in output[output.rindex('DisplayVersion    REG_SZ') + 24:]:
            if letter != '\n':
                google_version += letter
            else:
                break
        return (google_version.strip())
    except TypeError:
        return


def extract_version_folder():
    # Check if the Chrome folder exists in the x32 or x64 Program Files
    # folders.
    for i in range(2):
        path = 'C:\\Program Files' + \
            (' (x86)' if i else '') + '\\Google\\Chrome\\Application'
        if os.path.isdir(path):
            paths = [f.path for f in os.scandir(path) if f.is_dir()]
            for path in paths:
                filename = os.path.basename(path)
                pattern = '\\d+\\.\\d+\\.\\d+\\.\\d+'
                match = re.search(pattern, filename)
                if match and match.group():
                    # Found a Chrome version.
                    return match.group(0)

    return None


def get_chrome_version():
    version = None
    install_path = None

    try:
        if platform == "linux" or platform == "linux2":
            # linux
            install_path = "/usr/bin/google-chrome"
        elif platform == "darwin":
            # OS X
            install_path = "/Applications/Google\\ Chrome.app/Contents/MacOS/Google\\ Chrome"
        elif platform == "win32":
            # Windows...
            try:
                # Try registry key.
                stream = os.popen(
                    'reg query "HKLM\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\Google Chrome"')
                output = stream.read()
                version = extract_version_registry(output)
            except Exception as ex:
                # Try folder path.
                version = extract_version_folder()
    except Exception as ex:
        print(ex)

    version = os.popen(f"{install_path} --version").read().strip(
        'Google Chrome ').strip() if install_path else version

    return version

================
File: services/scripts/match_scraper.py
================
import logging
from typing import Dict, Any, Optional
import pandas as pd
from selenium import webdriver
from django.db import transaction

from sbapi.services.main.main import getMatchData, createMatchesDF, createEventsDF
from sbapi.services.loaders.match_loader import MatchLoader
from sbapi.services.loaders.event_loader import load_match_events

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

# Also add this to make sure handlers are configured
logger.setLevel(logging.DEBUG)


class MatchScraper:
    """Handles scraping and processing of match data"""

    def __init__(self):
        self.match_loader = MatchLoader()

    def scrape_match(self, url: str) -> Dict[str, Any]:
        """
        Get match data from URL
        """
        try:
            driver = webdriver.Chrome()
            match_data = getMatchData(driver, url, close_window=True)
            return match_data
        except Exception as e:
            logger.error(f"Error scraping match data: {str(e)}")
            raise

    def process_match_data(
            self, match_data: Dict[str, Any]) -> Optional[Dict[str, pd.DataFrame]]:
        """
        Process raw match data into DataFrames and load into database
        """
        try:
            # Create DataFrames
            matches_df = createMatchesDF(match_data)
            events_df = createEventsDF(match_data)

            # Load data into database using transaction
            with transaction.atomic():
                # Load match data first
                match = self.match_loader.load_match(match_data)

                # Load events data
                load_match_events(match, events_df)

                logger.info(
                    f"Successfully processed match {match_data['matchId']}")

            return {
                'matches': matches_df,
                'events': events_df
            }

        except Exception as e:
            logger.error(f"Error processing match data: {str(e)}")
            raise

================
File: v1/serializers/base/__init__.py
================
from .common import BaseStatsSerializer, BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer, BaseTeamStatsSerializer
from .competition import CompetitionListSerializer, CompetitionDetailSerializer, SeasonSerializer
from .events import (
    BaseEventSerializer,
    DefendingEventSerializer,
    GoalkeeperEventSerializer,
    PassEventSerializer,
    PossessionEventSerializer,
    ShootingEventSerializer,
    SummaryEventSerializer,
    get_event_serializer
)
from .match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'DefendingEventSerializer',
    'GoalkeeperEventSerializer',
    'PassEventSerializer',
    'PossessionEventSerializer',
    'ShootingEventSerializer',
    'SummaryEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer'
]

================
File: v1/serializers/base/base.py
================
from rest_framework import serializers


class BaseSerializer(serializers.ModelSerializer):
    """Base serializer adding success wrapper"""

    def to_representation(self, instance):
        data = super().to_representation(instance)
        if isinstance(data, list):
            return {
                'status': 'success',
                'data': data,
                'message': None
            }
        return data


class HalModelSerializer(BaseSerializer):
    """Base serializer that adds HAL-style _links"""
    _links = serializers.SerializerMethodField('get__links')

    def get__links(self, obj):
        """Default empty implementation"""
        return {}

    def to_representation(self, instance):
        data = super().to_representation(instance)
        links = self.get__links(instance)
        if links:
            data['_links'] = links
        return data

================
File: v1/serializers/base/common.py
================
from rest_framework import serializers


class BaseStatsSerializer(serializers.Serializer):
    """Base serializer for all stats"""
    competition_name = serializers.CharField(required=False)
    season_name = serializers.CharField(required=False)
    total_events = serializers.IntegerField(required=False)


class BasePlayerStatsSerializer(BaseStatsSerializer):
    """Base serializer for all player stats"""
    games_played = serializers.IntegerField(required=False)
    games_started = serializers.IntegerField(required=False)
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()


class BaseTeamStatsSerializer(BaseStatsSerializer):
    """Base serializer for all team stats"""
    matches_played = serializers.IntegerField(required=False)
    team = serializers.DictField(required=False)  # For team basic info


class BaseMatchStatsSerializer(BaseStatsSerializer):
    """Base serializer for match-specific stats"""
    match_date = serializers.DateTimeField(required=False)


class BaseSeasonStatsSerializer(BaseStatsSerializer):
    """Base serializer for season aggregated stats"""
    pass

================
File: v1/serializers/base/competition.py
================
from rest_framework import serializers
from sbapi.models import Competition, Season
from ..base.base import BaseSerializer, HalModelSerializer


class SeasonSerializer(BaseSerializer):
    class Meta:
        model = Season
        fields = ['season_id', 'name', 'is_current']


class CompetitionListSerializer(BaseSerializer):
    class Meta:
        model = Competition
        fields = ['competition_id', 'name', 'country']


class CompetitionDetailSerializer(HalModelSerializer):
    seasons = SeasonSerializer(source='season_set', many=True, read_only=True)

    class Meta:
        model = Competition
        fields = ['competition_id', 'name', 'country', 'seasons', '_links']

    def get__links(self, obj):
        return {
            'seasons': f'/sbapi/v1/competitions/{obj.competition_id}/seasons'
        }

================
File: v1/serializers/base/events.py
================
from rest_framework import serializers
from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)
from ..base.base import BaseSerializer


class BaseEventSerializer(BaseSerializer):
    """Base serializer for common event fields"""
    team_name = serializers.CharField(source='team.name')
    player_name = serializers.CharField(source='player.name', allow_null=True)

    class Meta:
        model = SummaryEvent
        abstract = True
        fields = [
            'event_id',
            'type',
            'minute',
            'second',
            'period',
            'team_name',
            'player_name',
            'x',
            'y',
            'end_x',
            'end_y',
            'outcome_type',
            'situation'
        ]


class DefendingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = DefendingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_tackle',
            'is_interception',
            'is_clearance',
            'is_ball_recovery',
            'aerial_success',
            'clearance_effective',
            'tackle_won',
            'interception_won',
            'defensive_duel',
            'error_leads_to_goal',
            'error_leads_to_shot',
        ]


class GoalkeeperEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = GoalkeeperEvent
        fields = BaseEventSerializer.Meta.fields + [
            'keeper_save_total',
            'keeper_claim_won',
            'keeper_claim_lost',
            'keeper_diving_save',
            'keeper_save_in_the_box',
            'keeper_penalty_saved',
            'save_high_centre',
            'save_high_left',
            'save_high_right',
            'save_low_centre',
            'save_low_left',
            'save_low_right',
        ]


class PassEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PassEvent
        fields = BaseEventSerializer.Meta.fields + [
            'pass_accurate',
            'pass_inaccurate',
            'assist',
            'key_pass_cross',
            'key_pass_throughball',
            'pass_cross_accurate',
            'pass_through_ball_accurate',
            'big_chance_created',
            'successful_final_third_passes',
        ]


class PossessionEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = PossessionEvent
        fields = BaseEventSerializer.Meta.fields + [
            'dispossessed',
            'touches',
            'dribble_won',
            'dribble_lost',
            'penalty_won',
            'offside_given',
        ]


class ShootingEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = ShootingEvent
        fields = BaseEventSerializer.Meta.fields + [
            'is_goal',
            'is_shot',
            'shot_on_target',
            'big_chance_scored',
            'big_chance_missed',
            'goal_mouth_y',
            'goal_mouth_z',
            'shot_body_type',
            'shot_penalty_area',
            'shot_six_yard_box',
        ]


class SummaryEventSerializer(BaseEventSerializer):
    class Meta(BaseEventSerializer.Meta):
        model = SummaryEvent
        fields = BaseEventSerializer.Meta.fields + [
            'card_type',
            'yellow_card',
            'red_card',
            'second_yellow',
            'foul_committed',
            'sub_on',
            'sub_off',
        ]


# Factory function to get appropriate serializer
EVENT_TYPE_SERIALIZERS = {
    'defending': DefendingEventSerializer,
    'goalkeeper': GoalkeeperEventSerializer,
    'passing': PassEventSerializer,
    'possession': PossessionEventSerializer,
    'shooting': ShootingEventSerializer,
    'summary': SummaryEventSerializer,
}


def get_event_serializer(event_type):
    """Returns appropriate serializer based on event type"""
    return EVENT_TYPE_SERIALIZERS.get(event_type, BaseEventSerializer)

================
File: v1/serializers/base/match.py
================
from rest_framework import serializers
from ....models import Match, Team, MatchPlayer, Formation
from .base import BaseSerializer, HalModelSerializer


class TeamBasicSerializer(serializers.Serializer):
    """Team serializer specifically for stats responses"""
    team_id = serializers.IntegerField()
    name = serializers.CharField()
    country = serializers.CharField()


class LineupPlayerSerializer(BaseSerializer):
    """Simplified player information for lineups"""
    name = serializers.CharField(source='player.name')

    class Meta:
        model = MatchPlayer
        fields = ['name', 'shirt_no', 'position']


class TeamLineupSerializer(serializers.Serializer):
    """Serializer for single team lineup data"""
    team = TeamBasicSerializer()
    starting_formation = serializers.CharField(allow_null=True)
    formation_changes = serializers.ListField(
        child=serializers.DictField()
    )
    starting_lineup = LineupPlayerSerializer(many=True)
    substitutions = serializers.ListField(
        child=serializers.DictField()
    )


class LineupResponseSerializer(serializers.Serializer):
    """Serializer for complete lineup response data"""
    status = serializers.CharField(default='success')
    message = serializers.CharField(allow_null=True, default=None)
    data = serializers.SerializerMethodField()

    def get_data(self, obj):
        return {
            'home_team': TeamLineupSerializer(obj['home_team']).data,
            'away_team': TeamLineupSerializer(obj['away_team']).data
        }


class MatchListSerializer(HalModelSerializer):
    """Simplified match list serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'start_datetime',
            'home_team',
            'away_team',
            'score',
            'venue',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/sbapi/v1/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events'
        }


class MatchDetailSerializer(HalModelSerializer):
    """Detailed match information serializer"""
    home_team = TeamBasicSerializer()
    away_team = TeamBasicSerializer()
    competition_name = serializers.CharField(source='season.competition.name')
    season_name = serializers.CharField(source='season.name')
    _links = serializers.SerializerMethodField()

    class Meta:
        model = Match
        fields = [
            'match_id',
            'competition_name',
            'season_name',
            'start_datetime',
            'venue',
            'attendance',
            'referee_name',
            'home_team',
            'away_team',
            'home_manager_name',
            'away_manager_name',
            'home_team_average_age',
            'away_team_average_age',
            'home_score_ft',
            'away_score_ft',
            '_links'
        ]

    def get__links(self, obj):
        return {
            'self': f'/matches/{obj.match_id}',
            'lineups': f'/sbapi/v1/matches/{obj.match_id}/lineups',
            'events': f'/sbapi/v1/matches/{obj.match_id}/events',
            'stats': f'/sbapi/v1/matches/{obj.match_id}/stats'
        }

================
File: v1/serializers/stats/__init__.py
================
from .player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from .team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer

__all__ = [
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: v1/serializers/stats/player_stats.py
================
from rest_framework import serializers
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BasePlayerStatsSerializer


class PlayerMatchStatsSerializer(
        BaseMatchStatsSerializer, BasePlayerStatsSerializer):
    """Detailed stats for a player in a specific match"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    # Changed from DateField to DateTimeField to match match.start_datetime
    match_date = serializers.DateTimeField()
    position = serializers.CharField()
    shirt_no = serializers.IntegerField()
    is_first_eleven = serializers.BooleanField()

    # Shooting stats
    shots = serializers.IntegerField(default=0)
    shots_on_target = serializers.IntegerField(default=0)
    goals = serializers.IntegerField(default=0)
    big_chances = serializers.IntegerField(default=0)

    # Passing stats
    passes_attempted = serializers.IntegerField(default=0)
    passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    key_passes = serializers.IntegerField(default=0)
    assists = serializers.IntegerField(default=0)

    # Defending stats
    tackles = serializers.IntegerField(default=0)
    interceptions = serializers.IntegerField(default=0)
    ball_recoveries = serializers.IntegerField(default=0)
    duels_won = serializers.IntegerField(default=0)


class PlayerSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BasePlayerStatsSerializer):
    """Season stats serializer"""
    # Basic info
    player_name = serializers.CharField()
    team_name = serializers.CharField()
    position = serializers.CharField()
    games_played = serializers.IntegerField()
    games_started = serializers.IntegerField()

    # Aggregated shooting stats
    total_shots = serializers.IntegerField(default=0)
    total_shots_on_target = serializers.IntegerField(default=0)
    total_goals = serializers.IntegerField(default=0)
    total_big_chances = serializers.IntegerField(default=0)

    # Aggregated passing stats
    total_passes = serializers.IntegerField(default=0)
    total_passes_completed = serializers.IntegerField(default=0)
    pass_accuracy = serializers.FloatField(default=0.0)
    total_key_passes = serializers.IntegerField(default=0)
    total_assists = serializers.IntegerField(default=0)

    # Aggregated defending stats
    total_tackles = serializers.IntegerField(default=0)
    total_interceptions = serializers.IntegerField(default=0)
    total_ball_recoveries = serializers.IntegerField(default=0)
    total_duels_won = serializers.IntegerField(default=0)

    # Per game averages
    avg_shots = serializers.FloatField(default=0.0)
    avg_passes = serializers.FloatField(default=0.0)
    avg_tackles = serializers.FloatField(default=0.0)

================
File: v1/serializers/stats/team_stats.py
================
from rest_framework import serializers
from ..base.match import TeamBasicSerializer
from ..base.common import BaseMatchStatsSerializer, BaseSeasonStatsSerializer, BaseTeamStatsSerializer


class TeamMatchStatsSerializer(
        BaseMatchStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics for a specific match"""
    team = TeamBasicSerializer()
    manager_name = serializers.CharField()
    average_age = serializers.FloatField()

    # Event stats from 'possession' category
    possession = serializers.FloatField(
        source='event_stats.possession.possession_pct', default=0)
    touches = serializers.IntegerField(
        source='event_stats.possession.touches', default=0)
    possession_lost = serializers.IntegerField(
        source='event_stats.possession.possession_lost', default=0)

    # Event stats from 'shooting' category
    total_shots = serializers.IntegerField(
        source='event_stats.shooting.total_shots', default=0)
    shots_on_target = serializers.IntegerField(
        source='event_stats.shooting.shots_on_target', default=0)
    goals = serializers.IntegerField(
        source='event_stats.shooting.goals', default=0)
    big_chances = serializers.IntegerField(
        source='event_stats.shooting.big_chances', default=0)

    # Event stats from 'passing' category
    total_passes = serializers.IntegerField(
        source='event_stats.passing.total_passes', default=0)
    accurate_passes = serializers.IntegerField(
        source='event_stats.passing.accurate_passes', default=0)
    key_passes = serializers.IntegerField(
        source='event_stats.passing.key_passes', default=0)
    assists = serializers.IntegerField(
        source='event_stats.passing.assists', default=0)

    # Event stats from 'defending' category
    tackles_won = serializers.IntegerField(
        source='event_stats.defending.tackles_won', default=0)
    interceptions = serializers.IntegerField(
        source='event_stats.defending.interceptions', default=0)
    clearances = serializers.IntegerField(
        source='event_stats.defending.clearances', default=0)
    blocks = serializers.IntegerField(
        source='event_stats.defending.blocks', default=0)


class TeamSeasonStatsSerializer(
        BaseSeasonStatsSerializer, BaseTeamStatsSerializer):
    """Team statistics aggregated over a season"""
    team = TeamBasicSerializer()
    matches_played = serializers.IntegerField()
    goals_for = serializers.IntegerField()
    avg_possession = serializers.FloatField()
    avg_age = serializers.FloatField(allow_null=True)
    home_matches = serializers.IntegerField()
    away_matches = serializers.IntegerField()
    manager = serializers.CharField()
    formation = serializers.CharField()

================
File: v1/serializers/__init__.py
================
from .base.common import (
    BaseStatsSerializer,
    BaseMatchStatsSerializer,
    BaseSeasonStatsSerializer,
    BasePlayerStatsSerializer,
    BaseTeamStatsSerializer,
)
from .base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)
from .base.events import (
    BaseEventSerializer,
    get_event_serializer
)
from .base.match import (
    TeamBasicSerializer,
    MatchListSerializer,
    MatchDetailSerializer,
    LineupPlayerSerializer,
    LineupResponseSerializer
)
from .stats.player_stats import (
    PlayerMatchStatsSerializer,
    PlayerSeasonStatsSerializer
)
from .stats.team_stats import (
    TeamMatchStatsSerializer,
    TeamSeasonStatsSerializer
)

__all__ = [
    'BaseStatsSerializer',
    'BaseMatchStatsSerializer',
    'BaseSeasonStatsSerializer',
    'BasePlayerStatsSerializer',
    'BaseTeamStatsSerializer',
    'CompetitionListSerializer',
    'CompetitionDetailSerializer',
    'SeasonSerializer',
    'BaseEventSerializer',
    'get_event_serializer',
    'TeamBasicSerializer',
    'MatchListSerializer',
    'MatchDetailSerializer',
    'LineupPlayerSerializer',
    'LineupResponseSerializer',
    'PlayerMatchStatsSerializer',
    'PlayerSeasonStatsSerializer',
    'TeamMatchStatsSerializer',
    'TeamSeasonStatsSerializer'
]

================
File: v1/services/events/__init__.py
================
from .event_aggregator import EventAggregator

__all__ = ['EventAggregator']

================
File: v1/services/events/event_aggregator.py
================
from django.db.models import Count, Q, Sum, F
from sbapi.models.events import (
    ShootingEvent,
    PassEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent
)


class EventAggregator:
    """Service for aggregating and calculating event statistics"""

    def get_match_events(self, match_id, event_type=None):
        """Get events for a match with optional type filtering"""
        try:
            event_mapping = {
                'shooting': ShootingEvent,
                'passing': PassEvent,
                'defending': DefendingEvent,
                'goalkeeper': GoalkeeperEvent,
                'possession': PossessionEvent
            }

            if event_type:
                if event_type not in event_mapping:
                    return {'status': 'error', 'message': 'Invalid event type'}

                events = event_mapping[event_type].objects.filter(
                    match_id=match_id
                ).select_related('team', 'player')

                return {
                    'events': events,
                    'count': events.count(),
                    'status': 'success'
                }

            # If no type specified, return counts for each type
            return {
                'counts': {
                    event_type: model.objects.filter(
                        match_id=match_id
                    ).count()
                    for event_type, model in event_mapping.items()
                },
                'status': 'success'
            }
        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_team_match_events(self, match_id, team_id):
        """Aggregate all events for a team in a match"""
        try:
            event_stats = {
                'possession': self._get_possession_stats(match_id, team_id),
                'shooting': self._get_shooting_stats(match_id, team_id),
                'passing': self._get_passing_stats(match_id, team_id),
                'defending': self._get_defending_stats(match_id, team_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def get_player_match_events(self, match_id, player_id):
        """Aggregate all events for a player in a match"""
        try:
            event_stats = {
                'shooting': self._get_player_shooting_stats(match_id, player_id),
                'passing': self._get_player_passing_stats(match_id, player_id),
                'defending': self._get_player_defending_stats(match_id, player_id)
            }

            return {'stats': event_stats, 'status': 'success'}

        except Exception as e:
            return {'status': 'error', 'message': str(e)}

    def _get_possession_stats(self, match_id, team_id):
        """Calculate possession-related stats"""
        return PossessionEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            touches=Count('touches', filter=Q(touches=True)),
            possession_lost=Count('dispossessed', filter=Q(dispossessed=True)),
            dribbles_won=Count('dribble_won', filter=Q(dribble_won=True)),
            dribbles_lost=Count('dribble_lost', filter=Q(dribble_lost=True))
        )

    def _get_shooting_stats(self, match_id, team_id):
        """Calculate shooting-related stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_passing_stats(self, match_id, team_id):
        """Calculate passing-related stats"""
        return PassEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            total_passes=Count('id'),
            accurate_passes=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True)),
            big_chances_created=Count(
                'big_chance_created', filter=Q(
                    big_chance_created=True))
        )

    def _get_defending_stats(self, match_id, team_id):
        """Calculate defending-related stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            team_id=team_id
        ).aggregate(
            tackles_won=Count('tackle_won', filter=Q(tackle_won=True)),
            interceptions=Count(
                'interception_won', filter=Q(
                    interception_won=True)),
            clearances=Count('is_clearance', filter=Q(is_clearance=True)),
            blocks=Count('outfielder_block', filter=Q(outfielder_block=True))
        )

    def _get_player_shooting_stats(self, match_id, player_id):
        """Calculate player shooting stats"""
        return ShootingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            shots=Count('is_shot', filter=Q(is_shot=True)),
            shots_on_target=Count(
                'shot_on_target', filter=Q(
                    shot_on_target=True)),
            goals=Count('is_goal', filter=Q(is_goal=True)),
            big_chances=Count(
                'id', filter=Q(
                    big_chance_scored=True) | Q(
                    big_chance_missed=True))
        )

    def _get_player_passing_stats(self, match_id, player_id):
        """Calculate player passing stats"""
        stats = PassEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            passes_attempted=Count('id'),
            passes_completed=Count(
                'pass_accurate', filter=Q(
                    pass_accurate=True)),
            key_passes=Count('pass_key', filter=Q(pass_key=True)),
            assists=Count('assist', filter=Q(assist=True))
        )

        # Calculate pass accuracy if there were attempts
        if stats['passes_attempted'] > 0:
            stats['pass_accuracy'] = (
                stats['passes_completed'] / stats['passes_attempted']) * 100
        else:
            stats['pass_accuracy'] = 0

        return stats

    def _get_player_defending_stats(self, match_id, player_id):
        """Calculate player defending stats"""
        return DefendingEvent.objects.filter(
            match_id=match_id,
            player_id=player_id
        ).aggregate(
            tackles=Count('is_tackle', filter=Q(is_tackle=True)),
            interceptions=Count(
                'is_interception', filter=Q(
                    is_interception=True)),
            ball_recoveries=Count(
                'is_ball_recovery', filter=Q(
                    is_ball_recovery=True)),
            duels_won=Count('defensive_duel', filter=Q(defensive_duel=True))
        )

================
File: v1/services/stats/__init__.py
================
from .player_stats import PlayerStatsService
from .team_stats import TeamStatsService

__all__ = [
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: v1/services/stats/player_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from sbapi.models import (
    ShootingEvent,
    PassEvent,
    DefendingEvent
)
from ..events.event_aggregator import EventAggregator

from django.db.models import Count, Avg, Sum, F, Q
from sbapi.models import MatchPlayer, Player
from ..events.event_aggregator import EventAggregator


class PlayerStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, player_id):
        """Calculate detailed player stats for a specific match"""
        try:
            # Get basic match player info
            match_player = MatchPlayer.objects.get(
                match_id=match_id,
                player_id=player_id
            )

            # Get event-based stats
            event_stats = self.event_aggregator.get_player_match_events(
                match_id,
                player_id
            )

            if event_stats['status'] == 'error':
                return event_stats

            return {
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except MatchPlayer.DoesNotExist:
            return {
                'status': 'error',
                'message': f'No stats found for player {player_id} in match {match_id}'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, player_id):
        """Calculate player stats for entire season"""
        try:
            # Get all matches for player in season
            matches = MatchPlayer.objects.filter(
                match__season__competition_id=competition_id,
                match__season_id=season_id,
                player_id=player_id
            ).select_related(
                'match',
                'player',
                'team'
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No stats found for player {player_id} in season {season_id}'
                }

            # Get latest match for player info
            latest_match = matches.order_by('-match__start_datetime').first()
            games_played = matches.count()

            # Get event stats for all matches
            match_ids = list(matches.values_list('match_id', flat=True))

            # Initialize totals
            totals = {
                'total_shots': 0,
                'total_shots_on_target': 0,
                'total_goals': 0,
                'total_big_chances': 0,
                'total_passes': 0,
                'total_passes_completed': 0,
                'total_key_passes': 0,
                'total_assists': 0,
                'total_tackles': 0,
                'total_interceptions': 0,
                'total_ball_recoveries': 0,
                'total_duels_won': 0
            }

            # Calculate totals across all matches
            for match_id in match_ids:
                match_stats = self.event_aggregator.get_player_match_events(
                    match_id, player_id)
                if match_stats['status'] == 'success':
                    # Add shooting stats
                    shooting = match_stats['stats']['shooting']
                    totals['total_shots'] += shooting.get('shots', 0)
                    totals['total_shots_on_target'] += shooting.get(
                        'shots_on_target', 0)
                    totals['total_goals'] += shooting.get('goals', 0)
                    totals['total_big_chances'] += shooting.get(
                        'big_chances', 0)

                    # Add passing stats
                    passing = match_stats['stats']['passing']
                    totals['total_passes'] += passing.get(
                        'passes_attempted', 0)
                    totals['total_passes_completed'] += passing.get(
                        'passes_completed', 0)
                    totals['total_key_passes'] += passing.get('key_passes', 0)
                    totals['total_assists'] += passing.get('assists', 0)

                    # Add defending stats
                    defending = match_stats['stats']['defending']
                    totals['total_tackles'] += defending.get('tackles', 0)
                    totals['total_interceptions'] += defending.get(
                        'interceptions', 0)
                    totals['total_ball_recoveries'] += defending.get(
                        'ball_recoveries', 0)
                    totals['total_duels_won'] += defending.get('duels_won', 0)

            # Calculate averages
            stats = {
                # Basic info
                'player_name': latest_match.player.name,
                'team_name': latest_match.team.name,
                'position': latest_match.position,
                'games_played': games_played,
                'games_started': matches.filter(is_first_eleven=True).count(),

                # Add all totals
                **totals,

                # Calculate overall pass accuracy
                'pass_accuracy': (
                    (totals['total_passes_completed'] /
                     totals['total_passes'] * 100)
                    if totals['total_passes'] > 0 else 0
                ),

                # Calculate per game averages
                'avg_shots': totals['total_shots'] / games_played if games_played > 0 else 0,
                'avg_passes': totals['total_passes'] / games_played if games_played > 0 else 0,
                'avg_tackles': totals['total_tackles'] / games_played if games_played > 0 else 0
            }

            return {
                'status': 'success',
                'stats': stats
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: v1/services/stats/team_stats.py
================
from django.db.models import Count, Avg, Sum, F, Q, Case, When, FloatField
from django.db.models.functions import Cast
from sbapi.models import Team, Match
from ..events.event_aggregator import EventAggregator


class TeamStatsService:
    def __init__(self):
        self.event_aggregator = EventAggregator()

    def calculate_match_stats(self, match_id, team_id):
        """Calculate detailed team stats for a match"""
        try:
            # Get base match info
            match = Match.objects.select_related(
                'home_team',
                'away_team'
            ).get(match_id=match_id)

            # Verify team participated in match
            if team_id not in [match.home_team_id, match.away_team_id]:
                return {
                    'status': 'error',
                    'message': f'Team {team_id} did not participate in match {match_id}'
                }

            # Add team context for serializer
            match.team = match.home_team if match.home_team_id == team_id else match.away_team

            # Get event-based stats
            event_stats = self.event_aggregator.get_team_match_events(
                match_id, team_id)

            if event_stats['status'] == 'error':
                return event_stats

            # Calculate possession percentage if not already included
            if 'possession' not in event_stats['stats']:
                total_touches = event_stats['stats']['possession'].get(
                    'touches', 0)
                opponent_id = match.away_team_id if team_id == match.home_team_id else match.home_team_id
                opponent_stats = self.event_aggregator.get_team_match_events(
                    match_id, opponent_id)
                if opponent_stats['status'] == 'success':
                    opponent_touches = opponent_stats['stats']['possession'].get(
                        'touches', 0)
                    if total_touches + opponent_touches > 0:
                        possession_pct = (
                            total_touches / (total_touches + opponent_touches)) * 100
                        event_stats['stats']['possession']['possession_pct'] = round(
                            possession_pct, 1)
                    else:
                        event_stats['stats']['possession']['possession_pct'] = 0

            # Calculate pass accuracy if not already included
            if 'pass_accuracy' not in event_stats['stats'].get('passing', {}):
                total_passes = event_stats['stats']['passing'].get(
                    'total_passes', 0)
                accurate_passes = event_stats['stats']['passing'].get(
                    'accurate_passes', 0)
                if total_passes > 0:
                    pass_accuracy = (accurate_passes / total_passes) * 100
                    event_stats['stats']['passing']['pass_accuracy'] = round(
                        pass_accuracy, 1)
                else:
                    event_stats['stats']['passing']['pass_accuracy'] = 0

            return {
                'match': match,
                'event_stats': event_stats['stats'],
                'status': 'success'
            }

        except Match.DoesNotExist:
            return {
                'status': 'error',
                'message': f'Match {match_id} not found'
            }
        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

    def calculate_season_stats(self, competition_id, season_id, team_id):
        """Calculate season aggregated stats for a team"""
        try:
            # Get all matches for the team in this season
            matches = (
                Match.objects
                .filter(
                    Q(home_team_id=team_id) | Q(away_team_id=team_id),
                    season__competition_id=competition_id,
                    season_id=season_id
                )
                .select_related('home_team', 'away_team', 'season')
            )

            if not matches.exists():
                return {
                    'status': 'error',
                    'message': f'No matches found for team {team_id} in season {season_id}'
                }

            # Get team info from first match
            first_match = matches.first()
            team = first_match.home_team if first_match.home_team_id == team_id else first_match.away_team
            match_count = matches.count()

            # Initialize aggregated stats with properly formatted team dict
            stats = {
                'team': {
                    'team_id': team.team_id,  # Changed from id to team_id
                    'name': team.name,
                    'country': team.country
                },
                'matches_played': match_count,
                'home_matches': matches.filter(home_team_id=team_id).count(),
                'away_matches': matches.filter(away_team_id=team_id).count(),
                'avg_possession': 0,
                'total_shots': 0,
                'shots_on_target': 0,
                'goals_for': 0,
                'total_passes': 0,
                'accurate_passes': 0,
                'key_passes': 0,
                'assists': 0,
                'tackles_won': 0,
                'interceptions': 0,
                'clearances': 0
            }

        # Rest of the method remains the same...

            # Calculate goals
            goals = matches.aggregate(
                goals_for=Sum(Case(
                    When(home_team_id=team_id, then='home_score_ft'),
                    When(away_team_id=team_id, then='away_score_ft'),
                    default=0,
                    output_field=FloatField()
                ))
            )
            stats['goals_for'] = goals['goals_for'] or 0

            # Calculate average age
            ages = matches.aggregate(
                avg_age=Avg(Case(
                    When(home_team_id=team_id, then='home_team_average_age'),
                    When(away_team_id=team_id, then='away_team_average_age'),
                    default=None,
                    output_field=FloatField()
                ))
            )
            stats['avg_age'] = round(
                ages['avg_age'], 1) if ages['avg_age'] else None

            # Get latest match info
            latest_match = matches.order_by('-start_datetime').first()
            if latest_match:
                stats['manager'] = (
                    latest_match.home_manager_name
                    if latest_match.home_team_id == team_id
                    else latest_match.away_manager_name
                )

                latest_formation = latest_match.formation_set.filter(
                    team_id=team_id
                ).order_by('-start_minute').first()

                stats['formation'] = latest_formation.formation_name if latest_formation else 'Unknown'

                # Aggregate event stats from all matches
                total_possession = 0
                for match in matches:
                    event_stats = self.event_aggregator.get_team_match_events(
                        match.match_id,
                        team_id
                    )
                    if event_stats['status'] == 'success':
                        # Add up possession %
                        possession = event_stats['stats']['possession'].get(
                            'possession_pct', 0)
                        total_possession += possession

                        # Add up other stats
                        shooting = event_stats['stats']['shooting']
                        stats['total_shots'] += shooting.get('total_shots', 0)
                        stats['shots_on_target'] += shooting.get(
                            'shots_on_target', 0)

                        passing = event_stats['stats']['passing']
                        stats['total_passes'] += passing.get('total_passes', 0)
                        stats['accurate_passes'] += passing.get(
                            'accurate_passes', 0)
                        stats['key_passes'] += passing.get('key_passes', 0)
                        stats['assists'] += passing.get('assists', 0)

                        defending = event_stats['stats']['defending']
                        stats['tackles_won'] += defending.get('tackles_won', 0)
                        stats['interceptions'] += defending.get(
                            'interceptions', 0)
                        stats['clearances'] += defending.get('clearances', 0)

                # Calculate averages
                if match_count > 0:
                    stats['avg_possession'] = round(
                        total_possession / match_count, 1)
                    stats['avg_shots'] = round(
                        stats['total_shots'] / match_count, 1)
                    stats['avg_passes'] = round(
                        stats['total_passes'] / match_count, 1)

                # Calculate pass accuracy
                if stats['total_passes'] > 0:
                    stats['pass_accuracy'] = round(
                        (stats['accurate_passes'] /
                         stats['total_passes']) * 100,
                        1
                    )
                else:
                    stats['pass_accuracy'] = 0

            return {
                'stats': stats,
                'status': 'success'
            }

        except Exception as e:
            return {
                'status': 'error',
                'message': str(e)
            }

================
File: v1/services/__init__.py
================
from .events.event_aggregator import EventAggregator
from .stats.player_stats import PlayerStatsService
from .stats.team_stats import TeamStatsService

__all__ = [
    'EventAggregator',
    'PlayerStatsService',
    'TeamStatsService'
]

================
File: v1/views/base/__init__.py
================
from .base import BaseViewSet
from .competition import CompetitionViewSet, CompetitionSeasonsView
from .events import MatchEventsViewSet, EventTypeView
from .match import MatchViewSet

__all__ = [
    'BaseViewSet',
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet'
]

================
File: v1/views/base/base.py
================
from rest_framework import viewsets
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound


class BaseViewSet(viewsets.ReadOnlyModelViewSet):
    """Base ViewSet adding success wrapper and lookup field configuration"""

    # Use match_id/competition_id instead of pk where appropriate
    lookup_field = 'pk'  # Override in child classes if needed

    def get_object(self):
        try:
            queryset = self.filter_queryset(self.get_queryset())

            lookup_url_kwarg = self.lookup_url_kwarg or self.lookup_field
            lookup_value = self.kwargs.get(
                lookup_url_kwarg) or self.kwargs.get('pk')

            if not lookup_value:
                return None

            filter_kwargs = {self.lookup_field: lookup_value}
            obj = queryset.get(**filter_kwargs)

            self.check_object_permissions(self.request, obj)
            return obj
        except (self.queryset.model.DoesNotExist, ValidationError):
            raise NotFound(f"{self.queryset.model.__name__} not found")
        except Exception as e:
            raise ValidationError(f"Error retrieving object: {str(e)}")

    def get_response(self, data):
        """Wrap response in success format"""
        if isinstance(data, list) or (
                isinstance(data, dict) and 'results' in data):
            return Response({
                'status': 'success',
                'data': data,
                'message': None
            })
        # Individual objects already wrapped by serializer
        return Response(data)

    def list(self, request, *args, **kwargs):
        response = super().list(request, *args, **kwargs)
        return self.get_response(response.data)

    def retrieve(self, request, *args, **kwargs):
        response = super().retrieve(request, *args, **kwargs)
        return self.get_response(response.data)

================
File: v1/views/base/competition.py
================
from rest_framework import viewsets, generics
from rest_framework.response import Response
from django.shortcuts import get_object_or_404
from .base import BaseViewSet
from ....models import Competition, Season
from ...serializers.base.competition import (
    CompetitionListSerializer,
    CompetitionDetailSerializer,
    SeasonSerializer
)


class CompetitionViewSet(BaseViewSet):
    """API endpoint for viewing competitions"""
    queryset = Competition.objects.all()
    lookup_field = 'competition_id'
    lookup_url_kwarg = 'competition_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return CompetitionListSerializer
        return CompetitionDetailSerializer


class CompetitionSeasonsView(generics.ListAPIView):
    """API endpoint for viewing seasons of a competition"""
    serializer_class = SeasonSerializer

    def get_queryset(self):
        competition_id = self.kwargs['competition_id']
        return Season.objects.filter(competition_id=competition_id)

================
File: v1/views/base/events.py
================
from rest_framework import viewsets, generics
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError
from django.db.models import Count, Q
from itertools import chain

from ..base.base import BaseViewSet

from ....models.events import (
    DefendingEvent,
    GoalkeeperEvent,
    PassEvent,
    PossessionEvent,
    ShootingEvent,
    SummaryEvent
)

from ...serializers.base.events import (
    BaseEventSerializer,
    get_event_serializer,
    EVENT_TYPE_SERIALIZERS
)

EVENT_TYPE_MODELS = {
    'defending': DefendingEvent,
    'goalkeeper': GoalkeeperEvent,
    'passing': PassEvent,
    'possession': PossessionEvent,
    'shooting': ShootingEvent,
    'summary': SummaryEvent,
}


class MatchEventsViewSet(BaseViewSet):
    """ViewSet for handling all match events"""
    serializer_class = BaseEventSerializer

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.request.query_params.get('type', None)

        if not match_id:
            raise ValidationError("Match ID is required")

        # If specific event type requested
        if event_type and event_type.lower() in EVENT_TYPE_MODELS:
            model = EVENT_TYPE_MODELS[event_type.lower()]
            return model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            ).order_by('minute', 'second')

        # If no specific type, combine all event types
        all_events = []
        for model in EVENT_TYPE_MODELS.values():
            events = model.objects.filter(
                match_id=match_id
            ).select_related(
                'team',
                'player'
            )
            all_events.append(events)

        # Handle None values by defaulting to 0 during sorting
        def sort_key(x):
            return (x.minute, x.second if x.second is not None else 0)

        combined_events = sorted(chain(*all_events), key=sort_key)

        return combined_events

    def get_serializer_class(self):
        event_type = self.request.query_params.get('type')
        if event_type and event_type.lower() in EVENT_TYPE_SERIALIZERS:
            return EVENT_TYPE_SERIALIZERS[event_type.lower()]
        return BaseEventSerializer

    @action(detail=False, methods=['get'])
    def stats(self, request, match_id=None):
        """Get aggregated stats for match events"""
        stats = {
            'total_events': 0,
            'by_type': {},
            'by_team': {},
            'by_period': {
                'FirstHalf': 0,
                'SecondHalf': 0
            }
        }

        # Aggregate stats across all event types
        for event_type, model in EVENT_TYPE_MODELS.items():
            events = model.objects.filter(match_id=match_id)
            event_count = events.count()
            stats['total_events'] += event_count

            # Stats by event type
            stats['by_type'][event_type] = event_count

            # Stats by period
            first_half = events.filter(period='FirstHalf').count()
            second_half = events.filter(period='SecondHalf').count()
            stats['by_period']['FirstHalf'] += first_half
            stats['by_period']['SecondHalf'] += second_half

            # Stats by team
            team_counts = events.values(
                'team__name'
            ).annotate(
                count=Count('id')
            )

            for team in team_counts:
                team_name = team['team__name']
                if team_name not in stats['by_team']:
                    stats['by_team'][team_name] = 0
                stats['by_team'][team_name] += team['count']

        return Response({
            'status': 'success',
            'data': stats,
            'message': None
        })


class EventTypeView(generics.ListAPIView):
    """View for handling specific event types for a match"""

    def get_queryset(self):
        match_id = self.kwargs.get('match_id')
        event_type = self.kwargs.get('event_type', '').lower()

        if event_type not in EVENT_TYPE_MODELS:
            raise ValidationError(f"Invalid event type: {event_type}")

        model = EVENT_TYPE_MODELS[event_type]
        return model.objects.filter(
            match_id=match_id
        ).select_related(
            'team',
            'player'
        ).order_by('minute', 'second')

    def get_serializer_class(self):
        event_type = self.kwargs.get('event_type', '').lower()
        return get_event_serializer(event_type)

#   # Aerial (Type) duels (won and lost are the same, just opposite)
    # looks empty (ie no/null for evryone so may need to do aerial_success + duel OR use the type (Aerial + outomce column)
    # carries xG and xA need calculating

================
File: v1/views/base/match.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from django.db.models import Q, Prefetch
from django.shortcuts import get_object_or_404
from sbapi.models import Match, MatchPlayer, Formation, SummaryEvent
from ...serializers.base.match import (
    MatchListSerializer,
    MatchDetailSerializer,
    LineupResponseSerializer
)
from .base import BaseViewSet


class MatchViewSet(BaseViewSet):
    """ViewSet for managing match data."""
    lookup_field = 'match_id'
    lookup_url_kwarg = 'match_id'

    def get_serializer_class(self):
        if self.action == 'list':
            return MatchListSerializer
        return MatchDetailSerializer

    def get_queryset(self):
        """Retrieve matches with relevant data."""
        queryset = Match.objects.select_related(
            'home_team',
            'away_team',
            'season',
            'season__competition'
        )

        if self.action == 'lineups':
            queryset = queryset.prefetch_related(
                Prefetch(
                    'formation_set',
                    queryset=Formation.objects.select_related(
                        'team').order_by('start_minute')
                ),
                Prefetch(
                    'matchplayer_set',
                    queryset=MatchPlayer.objects.select_related(
                        'player', 'team')
                )
            )

        # Get query parameters
        competition_id = self.request.query_params.get('competition_id')
        season_id = self.request.query_params.get('season_id')

        if competition_id and season_id:
            queryset = queryset.filter(
                season__competition_id=competition_id,
                season_id=season_id
            )

        return queryset.order_by('-start_datetime')

    @action(detail=True, methods=['get'], url_path='lineups')
    def lineups(self, request, **kwargs):
        """Retrieve detailed lineup information."""
        match = self.get_object()

        # Retrieve formations
        home_formations = Formation.objects.filter(
            match=match,
            team=match.home_team
        ).order_by('start_minute')

        away_formations = Formation.objects.filter(
            match=match,
            team=match.away_team
        ).order_by('start_minute')

        # Retrieve starting lineups
        home_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.home_team,
            is_first_eleven=True
        ).select_related('player')

        away_starters = MatchPlayer.objects.filter(
            match=match,
            team=match.away_team,
            is_first_eleven=True
        ).select_related('player')

        # Retrieve substitutions
        substitutions = (
            SummaryEvent.objects.filter(
                Q(sub_on=True) | Q(sub_off=True),
                match=match
            )
            .select_related('team')
            .order_by('minute')
        )

        # Organize substitutions by team
        home_subs = []
        away_subs = []
        for sub in substitutions:
            sub_data = {
                'minute': sub.minute,
                'player': sub.player_name,
                'type': 'on' if sub.sub_on else 'off'
            }
            if sub.team_id == match.home_team_id:
                home_subs.append(sub_data)
            else:
                away_subs.append(sub_data)

        # Prepare response data
        response_data = {
            'home_team': {
                'team': match.home_team,
                'starting_formation': home_formations.first().formation_name if home_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in home_formations[1:]
                ],
                'starting_lineup': home_starters,
                'substitutions': home_subs
            },
            'away_team': {
                'team': match.away_team,
                'starting_formation': away_formations.first().formation_name if away_formations else None,
                'formation_changes': [
                    {
                        'formation': f.formation_name,
                        'minute': f.start_minute
                    } for f in away_formations[1:]
                ],
                'starting_lineup': away_starters,
                'substitutions': away_subs
            }
        }

        serializer = LineupResponseSerializer(response_data)
        return Response({
            'status': 'success',
            'data': serializer.data,
            'message': None
        })

================
File: v1/views/stats/__init__.py
================
from .player_stats import PlayerStatsViewSet
from .team_stats import TeamStatsViewSet

__all__ = [
    'PlayerStatsViewSet',
    'TeamStatsViewSet'
]

================
File: v1/views/stats/player_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import MatchPlayer, Season
from ...serializers.stats.player_stats import PlayerMatchStatsSerializer, PlayerSeasonStatsSerializer
from ...services.stats.player_stats import PlayerStatsService


class PlayerStatsViewSet(BaseViewSet):
    """ViewSet for player statistics"""
    player_stats_service = PlayerStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get player stats for a specific match"""
        match_id = kwargs.get('match_id')
        player_id = kwargs.get('player_id')

        # Get event stats first
        stats_result = self.player_stats_service.calculate_match_stats(
            match_id, player_id)

        if stats_result['status'] == 'error':
            raise NotFound(stats_result['message'])

        # Get match player info
        match_player = get_object_or_404(
            MatchPlayer.objects.select_related('player', 'team', 'match'),
            match_id=match_id,
            player_id=player_id
        )

        # Create data dictionary combining match player info and event stats
        all_stats = {
            'player_name': match_player.player.name,
            'team_name': match_player.team.name,
            'match_date': match_player.match.start_datetime,
            'position': match_player.position,
            'shirt_no': match_player.shirt_no,
            'is_first_eleven': match_player.is_first_eleven,
            **stats_result['event_stats']['shooting'],
            **stats_result['event_stats']['passing'],
            **stats_result['event_stats']['defending']
        }

        serializer = PlayerMatchStatsSerializer(all_stats)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get player stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        player_id = kwargs.get('player_id')

        result = self.player_stats_service.calculate_season_stats(
            competition_id,
            season_id,
            player_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = PlayerSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)
        return Response(serializer.data)

================
File: v1/views/stats/team_stats.py
================
from rest_framework import viewsets
from rest_framework.decorators import action
from rest_framework.response import Response
from rest_framework.exceptions import ValidationError, NotFound
from django.shortcuts import get_object_or_404

from ..base.base import BaseViewSet
from sbapi.models import Season
from ...serializers.stats.team_stats import TeamMatchStatsSerializer, TeamSeasonStatsSerializer
from ...services.stats.team_stats import TeamStatsService


class TeamStatsViewSet(BaseViewSet):
    """ViewSet for team statistics"""
    team_stats_service = TeamStatsService()

    @action(detail=True, methods=['get'])
    def get_match_stats(self, request, *args, **kwargs):
        """Get team stats for a specific match"""
        match_id = kwargs.get('match_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_match_stats(
            match_id, team_id)

        if result['status'] == 'error':
            raise NotFound(result['message'])

        match = result['match']
        # Determine if team is home or away
        is_home = match.home_team_id == team_id

        match_data = {
            'team': match.home_team if is_home else match.away_team,
            'manager_name': match.home_manager_name if is_home else match.away_manager_name,
            'average_age': match.home_team_average_age if is_home else match.away_team_average_age,
            'event_stats': result['event_stats']
        }

        serializer = TeamMatchStatsSerializer(match_data)
        return Response(serializer.data)

    @action(detail=True, methods=['get'])
    def get_season_stats(self, request, *args, **kwargs):
        """Get team stats for a season"""
        competition_id = kwargs.get('competition_id')
        season_id = kwargs.get('season_id')
        team_id = kwargs.get('team_id')

        result = self.team_stats_service.calculate_season_stats(
            competition_id=competition_id,
            season_id=season_id,
            team_id=team_id
        )

        if result['status'] == 'error':
            raise NotFound(result['message'])

        # Get competition and season names
        season = get_object_or_404(
            Season.objects.select_related('competition'),
            pk=season_id)

        # Add competition and season info to stats
        result['stats'].update({
            'competition_name': season.competition.name,
            'season_name': season.name
        })

        serializer = TeamSeasonStatsSerializer(data=result['stats'])
        serializer.is_valid(raise_exception=True)

        return Response(serializer.data)

================
File: v1/views/__init__.py
================
from .base.competition import CompetitionViewSet, CompetitionSeasonsView
from .base.events import MatchEventsViewSet, EventTypeView
from .base.match import MatchViewSet
from .stats.player_stats import PlayerStatsViewSet
from .stats.team_stats import TeamStatsViewSet

__all__ = [
    'CompetitionViewSet',
    'CompetitionSeasonsView',
    'MatchEventsViewSet',
    'EventTypeView',
    'MatchViewSet',
    'PlayerStatsViewSet',
    'TeamStatsViewSet',
]

================
File: v1/urls.py
================
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views.base.competition import CompetitionViewSet, CompetitionSeasonsView
from .views.base.match import MatchViewSet
from .views.base.events import MatchEventsViewSet, EventTypeView
from .views.stats.player_stats import PlayerStatsViewSet
from .views.stats.team_stats import TeamStatsViewSet

# Create router for viewsets
router = DefaultRouter()
router.register(r'competitions', CompetitionViewSet, basename='competition')
router.register(r'matches', MatchViewSet, basename='match')

urlpatterns = [
    # Include router URLs
    path('', include(router.urls)),

    # Competition and season routes
    path('competitions/<int:competition_id>/seasons/',
         CompetitionSeasonsView.as_view()),  # ALL COMPS
    path('competitions/<int:competition_id>/seasons/<int:season_id>/', include([  # ALL SEASONS OF A COMP
        path('stats/players/<int:player_id>/',
             PlayerStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A PLAYER
        path('stats/teams/<int:team_id>/',
             TeamStatsViewSet.as_view({'get': 'get_season_stats'})),  # SEASON STATS FOR A TEAM
    ])),

    # Match routes
    path('matches/<int:match_id>/', include([
        # Match events
        path('events/', MatchEventsViewSet.as_view({'get': 'list'})),
        path('events/stats/', MatchEventsViewSet.as_view({'get': 'stats'})),
        path('events/<str:event_type>/', EventTypeView.as_view()),

        # Match stats
        path('stats/', include([
            path('players/<int:player_id>/',
                 PlayerStatsViewSet.as_view({'get': 'get_match_stats'})),
            path('teams/<int:team_id>/',
                 TeamStatsViewSet.as_view({'get': 'get_match_stats'})),
        ])),

        # Match lineups
        path('lineups/', MatchViewSet.as_view({'get': 'lineups'})),
    ])),
]

================
File: v1/utils.py
================
from rest_framework.views import exception_handler
from rest_framework.response import Response


def custom_exception_handler(exc, context):
    response = exception_handler(exc, context)

    if response is not None:
        response.data = {
            'status': 'error',
            'message': str(exc),
            'data': response.data
        }

    return response

================
File: admin.py
================
from django.contrib import admin
from django.db.models import Count, Q
from .models import (
    Competition,
    Season,
    Team,
    Player,
    Match,
    Formation,
    MatchPlayer,
    PassEvent,
    ShootingEvent,
    DefendingEvent,
    GoalkeeperEvent,
    PossessionEvent,
    SummaryEvent
)


@admin.register(Competition)
class CompetitionAdmin(admin.ModelAdmin):
    list_display = ('competition_id', 'name', 'country', 'get_seasons',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('country',)
    search_fields = ('name', 'country')

    def get_seasons(self, obj):
        return ", ".join([season.name for season in obj.season_set.all()])
    get_seasons.short_description = 'Seasons'

    def get_match_count(self, obj):
        return obj.season_set.aggregate(
            match_count=Count('match')
        )['match_count']
    get_match_count.short_description = 'Matches'


@admin.register(Season)
class SeasonAdmin(admin.ModelAdmin):
    list_display = ('season_id', 'name', 'competition', 'is_current',
                    'get_match_count', 'created_at', 'last_updated')
    list_filter = ('competition', 'is_current')
    search_fields = ('name', 'competition__name')

    def get_match_count(self, obj):
        return obj.match_set.count()
    get_match_count.short_description = 'Matches'


@admin.register(Team)
class TeamAdmin(admin.ModelAdmin):
    list_display = ('team_id', 'name', 'country')
    list_filter = ('country',)
    search_fields = ('name', 'country')
    list_per_page = 50


@admin.register(Player)
class PlayerAdmin(admin.ModelAdmin):
    list_display = ('player_id', 'name', 'get_matches_played')
    search_fields = ('name',)
    list_filter = ('matchplayer__team',)
    list_per_page = 50

    def get_matches_played(self, obj):
        return obj.matchplayer_set.count()
    get_matches_played.short_description = 'Matches Played'


@admin.register(Match)
class MatchAdmin(admin.ModelAdmin):
    list_display = ('match_id', 'season', 'competition', 'start_datetime', 'home_team',
                    'score', 'away_team', 'venue', 'attendance', 'referee_name')
    list_filter = ('season__competition', 'season', 'start_datetime')
    search_fields = ('home_team__name', 'away_team__name', 'venue',
                     'season__competition__name', 'season__name')
    date_hierarchy = 'start_datetime'
    raw_id_fields = ('home_team', 'away_team', 'season')
    list_per_page = 50


@admin.register(Formation)
class FormationAdmin(admin.ModelAdmin):
    list_display = (
        'match',
        'team',
        'formation_name',
        'start_minute',
        'end_minute')
    list_filter = ('formation_name',)
    search_fields = (
        'match__home_team__name',
        'match__away_team__name',
        'team__name',
        'formation_name')
    list_per_page = 50


@admin.register(MatchPlayer)
class MatchPlayerAdmin(admin.ModelAdmin):
    list_display = ('match', 'player', 'team', 'position', 'is_first_eleven',
                    'is_man_of_match')
    list_filter = ('position', 'is_first_eleven', 'is_man_of_match')
    search_fields = ('player__name', 'team__name')
    raw_id_fields = ('match', 'player', 'team')
    list_per_page = 50

# Base Event Admin


class BaseEventAdmin(admin.ModelAdmin):
    list_display = ('id', 'match', 'team', 'player_name', 'minute', 'x', 'y', 'type',
                    'outcome_type', 'situation')
    list_filter = ('type', 'period', 'outcome_type', 'situation')
    search_fields = ('player_name', 'team__name')
    date_hierarchy = 'match__start_datetime'
    raw_id_fields = ('match', 'team', 'player')
    ordering = ('-match__start_datetime', 'minute')
    list_per_page = 50


@admin.register(PassEvent)
class PassEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('pass_accurate', 'assist', 'pass_key')
    list_filter = BaseEventAdmin.list_filter + (
        'pass_accurate', 'assist', 'pass_key', 'big_chance_created'
    )


@admin.register(ShootingEvent)
class ShootingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('is_goal', 'shot_on_target',
                                                  'big_chance_missed')
    list_filter = BaseEventAdmin.list_filter + (
        'is_goal', 'shot_on_target', 'big_chance_missed', 'penalty_scored'
    )


@admin.register(DefendingEvent)
class DefendingEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('duel_aerial_won', 'tackle_won', 'interception_won', 'aerial_success',
                                                  'offensive_duel', 'defensive_duel')
    list_filter = BaseEventAdmin.list_filter + (
        'tackle_won', 'interception_won', 'duel_aerial_won', 'offensive_duel', 'defensive_duel', 'goal_own',
    )


@admin.register(GoalkeeperEvent)
class GoalkeeperEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )
    list_filter = BaseEventAdmin.list_filter + (
        'keeper_save_total',
        'keeper_claim_won',
        'keeper_penalty_saved'
    )

    def get_queryset(self, request):
        return super().get_queryset(request).select_related(
            'match',
            'team',
            'player'  # Changed from player__matchplayer
        ).prefetch_related(
            'player__matchplayer_set'  # Added prefetch_related for MatchPlayer
        )


@admin.register(PossessionEvent)
class PossessionEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + ('dispossessed', 'dribble_won',
                                                  'turnover')
    list_filter = BaseEventAdmin.list_filter + (
        'dispossessed', 'dribble_won', 'turnover'
    )


@admin.register(SummaryEvent)
class SummaryEventAdmin(BaseEventAdmin):
    list_display = BaseEventAdmin.list_display + \
        ('card_type', 'sub_on', 'sub_off', 'foul_committed')
    list_filter = BaseEventAdmin.list_filter + \
        ('card_type',
         'sub_on',
         'sub_off',
         'foul_committed',
         'penalty_conceded',
         'penalty_won')

================
File: apps.py
================
from django.apps import AppConfig


class SbapiConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'sbapi'

================
File: tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: backend/sbapi/tests.py
================
from django.test import TestCase

# Create your tests here.

================
File: backend/manage.py
================
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'backend.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()

================
File: backend/requirements.txt
================
asgiref==3.8.1
astroid==3.3.5
attrs==24.2.0
autopep8==2.3.1
beautifulsoup4==4.12.3
cattrs==24.1.2
certifi==2024.8.30
charset-normalizer==3.4.0
contourpy==1.3.0
cycler==0.12.1
dill==0.3.9
Django==5.1.2
django-cors-headers==4.5.0
djangorestframework==3.15.2
fonttools==4.54.1
h11==0.14.0
idna==3.10
inflect==7.4.0
isort==5.13.2
Jinja2==3.1.4
joblib==1.4.2
kiwisolver==1.4.7
MarkupSafe==3.0.2
matplotlib==3.9.2
mccabe==0.7.0
more-itertools==10.5.0
mpld3==0.5.10
mplsoccer==1.2.2
numpy==2.1.2
outcome==1.3.0.post0
packaging==24.1
pandas==2.2.3
pillow==11.0.0
platformdirs==4.3.6
pycodestyle==2.12.1
pylint==3.3.1
pyparsing==3.2.0
PySocks==1.7.1
python-dateutil==2.9.0.post0
python-decouple==3.8
python-dotenv==1.0.1
pytz==2024.2
requests==2.32.3
requests-cache==1.2.1
scipy==1.14.1
seaborn==0.13.2
selenium==4.16.0
six==1.16.0
sniffio==1.3.1
sortedcontainers==2.4.0
soupsieve==2.6
sqlparse==0.5.1
statsbombpy==1.14.0
tomlkit==0.13.2
tqdm==4.67.1
trio==0.27.0
trio-websocket==0.11.1
typeguard==4.3.0
typing_extensions==4.12.2
tzdata==2024.2
unzip==1.0.0
url-normalize==1.4.3
urllib3==2.2.3
webdriver-manager==4.0.2
wsproto==1.2.0

================
File: frontend/public/index.html
================
<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: frontend/public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: frontend/public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: frontend/src/components/common/BaseLayout.js
================
// src/components/common/BaseLayout.js
import React from 'react';
import Navbar from './Navbar';

const BaseLayout = ({ children, className = '' }) => {
  return (
    <div className='min-h-screen bg-gray-100'>
      <Navbar />
      <main
        className={`container mx-auto min-h-[calc(100vh-4rem)] px-4 py-6 sm:px-6 lg:px-8 ${className}`}
      >
        {children}
      </main>
      <footer className='mt-auto border-t border-gray-200 bg-white py-4 dark:border-gray-800 dark:bg-gray-800'>
        <div className='container mx-auto px-4 text-center text-sm text-gray-600 dark:text-gray-400'>
          © {new Date().getFullYear()} Statsball. All rights reserved.
        </div>
      </footer>
    </div>
  );
};

export default BaseLayout;

================
File: frontend/src/components/common/ErrorMessage1.js
================
// ErrorMessage.js
import React from 'react';

const ErrorMessage = ({ message }) => {
  if (!message) return null;

  return (
    <div
      className='mb-6 rounded-lg border border-red-400 bg-red-100 px-4 py-3 text-center text-red-700'
      role='alert'
    >
      {message}
    </div>
  );
};

export default ErrorMessage;

================
File: frontend/src/components/common/index.js
================
// src/components/common/index.js
import React from 'react';
import { AlertCircle, Loader2 } from 'lucide-react';

export const ErrorMessage = ({
  message,
  variant = 'error',
  action,
  className = '',
}) => {
  const styles = {
    error: 'bg-red-50 text-red-700 border-red-200',
    warning: 'bg-yellow-50 text-yellow-700 border-yellow-200',
    info: 'bg-blue-50 text-blue-700 border-blue-200',
  };

  return (
    <div className={`rounded-lg border p-4 ${styles[variant]} ${className}`}>
      <div className='flex items-center gap-3'>
        <AlertCircle className='h-5 w-5' />
        <div className='flex-1'>{message}</div>
        {action && (
          <button
            onClick={action.onClick}
            className='rounded bg-white px-3 py-1 text-sm font-medium shadow-sm hover:bg-gray-50'
          >
            {action.label}
          </button>
        )}
      </div>
    </div>
  );
};

export const LoadingSpinner = ({
  fullScreen = false,
  message = 'Loading...',
  className = '',
}) => {
  const containerStyles = fullScreen
    ? 'fixed inset-0 bg-white/80 backdrop-blur-sm'
    : 'w-full';

  return (
    <div
      className={`flex items-center justify-center p-8 ${containerStyles} ${className}`}
    >
      <div className='flex flex-col items-center gap-2'>
        <Loader2 className='h-8 w-8 animate-spin text-blue-500' />
        <p className='text-sm text-gray-500'>{message}</p>
      </div>
    </div>
  );
};

export const EmptyState = ({
  title,
  message,
  icon: Icon,
  action,
  className = '',
}) => (
  <div
    className={`flex flex-col items-center justify-center rounded-lg border border-dashed border-gray-300 bg-white p-8 ${className}`}
  >
    {Icon && <Icon className='mb-3 h-12 w-12 text-gray-400' />}
    <h3 className='mb-1 text-lg font-medium'>{title}</h3>
    <p className='mb-4 text-sm text-gray-500'>{message}</p>
    {action && (
      <button
        onClick={action.onClick}
        className='rounded-full bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-600'
      >
        {action.label}
      </button>
    )}
  </div>
);

================
File: frontend/src/components/common/LoadingSpinner1.js
================
import React from 'react';

const LoadingSpinner = ({ fullScreen = false }) => {
  const baseClasses = 'flex items-center justify-center';
  const containerClasses = fullScreen ? `${baseClasses} h-screen` : baseClasses;

  return (
    <div className={containerClasses} role='status'>
      <div
        className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent'
        aria-label='Loading'
      />
      <span className='sr-only'>Loading...</span>
    </div>
  );
};

export default LoadingSpinner;

================
File: frontend/src/components/common/Modal.js
================
// Modal.js
import React, { useRef, useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children, footer }) => {
  const modalRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = event => {
      if (modalRef.current && !modalRef.current.contains(event.target)) {
        onClose();
      }
    };

    const handleEscapeKey = event => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('keydown', handleEscapeKey);
      // Prevent scroll when modal is open
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscapeKey);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div
      className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'
      role='dialog'
      aria-modal='true'
      aria-labelledby='modal-title'
    >
      <div
        ref={modalRef}
        className='w-full max-w-lg overflow-hidden rounded-lg bg-white shadow-lg'
      >
        <div className='flex items-center justify-between border-b p-4'>
          <h2 id='modal-title' className='text-xl font-semibold'>
            {title}
          </h2>
          <button
            className='rounded-full p-1 text-gray-500 hover:bg-gray-100 hover:text-gray-700'
            onClick={onClose}
            aria-label='Close modal'
          >
            ×
          </button>
        </div>
        <div className='p-6'>{children}</div>
        {footer && <div className='border-t p-4 text-right'>{footer}</div>}
      </div>
    </div>
  );
};

export default Modal;

================
File: frontend/src/components/common/Navbar.js
================
import React, { useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, Menu, Trophy, Activity, X } from 'lucide-react';

const navigation = [
  { name: 'Home', href: '/', icon: Home },
  { name: 'Competitions', href: '/competitions', icon: Trophy },
  { name: 'Match Center', href: '/matches', icon: Activity },
];

const Navbar = () => {
  const [isOpen, setIsOpen] = useState(false);
  const location = useLocation();

  const isActive = path => location.pathname === path;

  return (
    <header>
      <nav className='bg-blue-600 shadow-lg' aria-label='Main navigation'>
        <div className='mx-auto max-w-7xl px-4 sm:px-6 lg:px-8'>
          <div className='flex h-16 justify-between'>
            <div className='flex'>
              <div className='flex flex-shrink-0 items-center'>
                <Link to='/' className='flex items-center space-x-2'>
                  <img
                    src='/api/placeholder/32/32'
                    alt='Logo'
                    className='h-8 w-8 rounded-full'
                  />
                  <span className='hidden text-xl font-bold text-white sm:block'>
                    Statsball
                  </span>
                </Link>
              </div>

              <div className='hidden sm:ml-6 sm:flex sm:space-x-8'>
                {navigation.map(item => (
                  <Link
                    key={item.name}
                    to={item.href}
                    className={`inline-flex items-center space-x-2 border-b-2 px-1 pt-1 text-sm font-medium ${
                      isActive(item.href)
                        ? 'border-white text-white'
                        : 'border-transparent text-blue-100 hover:border-blue-200 hover:text-white'
                    }`}
                  >
                    <item.icon className='h-4 w-4' />
                    <span>{item.name}</span>
                  </Link>
                ))}
              </div>
            </div>

            <div className='flex items-center sm:hidden'>
              <button
                onClick={() => setIsOpen(!isOpen)}
                className='inline-flex items-center justify-center rounded-md p-2 text-blue-100 hover:bg-blue-700 hover:text-white'
              >
                {isOpen ? (
                  <X className='h-6 w-6' aria-hidden='true' />
                ) : (
                  <Menu className='h-6 w-6' aria-hidden='true' />
                )}
              </button>
            </div>
          </div>
        </div>

        {isOpen && (
          <div className='sm:hidden'>
            <div className='space-y-1 pb-3 pt-2'>
              {navigation.map(item => (
                <Link
                  key={item.name}
                  to={item.href}
                  className={`flex items-center space-x-2 border-l-4 py-2 pl-3 pr-4 text-base font-medium ${
                    isActive(item.href)
                      ? 'border-white bg-blue-700 text-white'
                      : 'border-transparent text-blue-100 hover:border-blue-300 hover:bg-blue-700 hover:text-white'
                  }`}
                  onClick={() => setIsOpen(false)}
                >
                  <item.icon className='h-5 w-5' />
                  <span>{item.name}</span>
                </Link>
              ))}
            </div>
          </div>
        )}
      </nav>
    </header>
  );
};

export default Navbar;

================
File: frontend/src/components/competition/CompetitionOverview.js
================
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage, EmptyState } from '../common';
import { Calendar } from 'lucide-react';
import { format } from 'date-fns';
import * as api from '../../services/api';

const CompetitionOverview = () => {
  const { competitionId, seasonId } = useParams();
  const [allMatches, setAllMatches] = useState([]);
  const [displayedMatches, setDisplayedMatches] = useState([]);
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [leagueInfo, setLeagueInfo] = useState(null);
  const navigate = useNavigate();

  const [showAllMatches, setShowAllMatches] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [matchesPerPage] = useState(10);

  const loadData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const leagueData = await api.getCompetitionInfo(competitionId, seasonId);
      setLeagueInfo(leagueData);

      await new Promise(resolve => setTimeout(resolve, 500));

      const matchesData = await api.getCompetitionMatches(
        competitionId,
        seasonId,
      );
      const sortedMatches = matchesData
        .filter(match => match?.match_date)
        .sort((a, b) => new Date(b.match_date) - new Date(a.match_date));

      setAllMatches(sortedMatches);
      setDisplayedMatches(sortedMatches.slice(0, 5));

      const uniqueTeams = Array.from(
        new Set(
          matchesData
            .filter(match => match?.home_team && match?.away_team)
            .flatMap(match => [match.home_team, match.away_team]),
        ),
      ).sort();

      setTeams(uniqueTeams);
    } catch (err) {
      console.error('Error loading data:', err);
      setError('Failed to load data. Please try again later.');
    } finally {
      setLoading(false);
    }
  }, [competitionId, seasonId]);

  useEffect(() => {
    if (competitionId && seasonId) {
      const timer = setTimeout(loadData, 100);
      return () => clearTimeout(timer);
    }
  }, [competitionId, seasonId, loadData]);

  const indexOfLastMatch = currentPage * matchesPerPage;
  const indexOfFirstMatch = indexOfLastMatch - matchesPerPage;
  const totalPages = Math.ceil(allMatches.length / matchesPerPage);

  useEffect(() => {
    if (showAllMatches) {
      setDisplayedMatches(
        allMatches.slice(indexOfFirstMatch, indexOfLastMatch),
      );
    } else {
      setDisplayedMatches(allMatches.slice(0, 5));
    }
  }, [
    showAllMatches,
    currentPage,
    allMatches,
    indexOfFirstMatch,
    indexOfLastMatch,
  ]);

  const handlePageChange = pageNumber => {
    setCurrentPage(pageNumber);
  };

  const toggleMatchesView = () => {
    setShowAllMatches(!showAllMatches);
    setCurrentPage(1);
  };

  if (loading) {
    return <LoadingSpinner message='Loading competition data...' />;
  }

  if (error) {
    return (
      <ErrorMessage
        message={error}
        action={{
          label: 'Try Again',
          onClick: loadData,
        }}
      />
    );
  }

  if (!allMatches.length) {
    return (
      <EmptyState
        icon={Calendar}
        title='No Matches Found'
        message='There are no matches available for this competition yet.'
      />
    );
  }

  return (
    <div className='container mx-auto py-6'>
      <div className='mb-6 rounded bg-blue-600 p-4 text-white'>
        <h2 className='text-2xl font-bold'>
          {leagueInfo?.competition || 'League'}
        </h2>
        <p className='opacity-80'>{leagueInfo?.season || 'Season'}</p>
      </div>

      <div className='mb-6 rounded bg-white shadow'>
        <div className='flex items-center justify-between rounded-t bg-gray-100 p-4'>
          <h4 className='text-xl font-semibold'>
            {showAllMatches ? 'All Matches' : 'Recent Matches'}
          </h4>
          <button
            className='rounded border border-blue-500 px-3 py-1 text-blue-500 hover:bg-blue-500 hover:text-white'
            onClick={toggleMatchesView}
          >
            {showAllMatches ? 'Show Recent Matches' : 'View All Matches'}
          </button>
        </div>
        <div className='overflow-x-auto'>
          <table className='min-w-full divide-y divide-gray-200'>
            <thead className='bg-gray-50'>
              <tr>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Date
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Home Team
                </th>
                <th className='px-6 py-3 text-center text-xs font-medium uppercase text-gray-500'>
                  Score
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Away Team
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Week
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Status
                </th>
              </tr>
            </thead>
            <tbody className='divide-y divide-gray-200 bg-white'>
              {displayedMatches.map(match => (
                <tr
                  key={match.match_id}
                  className='cursor-pointer hover:bg-gray-100'
                  onClick={() =>
                    navigate(
                      `/match/${competitionId}/${seasonId}/${match.match_id}`,
                      {
                        state: {
                          matchData: match,
                          competitionId,
                          seasonId,
                        },
                      },
                    )
                  }
                >
                  <td className='px-6 py-4'>
                    {format(new Date(match.match_date), 'MMM d, yyyy')}
                    <br />
                    <span className='text-xs text-gray-500'>
                      {match.kick_off}
                    </span>
                  </td>
                  <td className='px-6 py-4'>{match.home_team}</td>
                  <td className='px-6 py-4 text-center font-semibold'>
                    {match.home_score} - {match.away_score}
                  </td>
                  <td className='px-6 py-4'>{match.away_team}</td>
                  <td className='px-6 py-4'>
                    Week {match.match_week || 'N/A'}
                  </td>
                  <td className='px-6 py-4'>
                    <span
                      className={`rounded px-2 py-1 ${
                        match.match_status === 'available'
                          ? 'bg-green-100 text-green-800'
                          : 'bg-gray-100 text-gray-800'
                      }`}
                    >
                      {match.match_status}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {showAllMatches && totalPages > 1 && (
          <div className='flex justify-center p-4'>
            <div className='flex gap-2'>
              {[...Array(totalPages)].map((_, index) => (
                <button
                  key={index + 1}
                  onClick={() => handlePageChange(index + 1)}
                  className={`rounded px-3 py-1 ${
                    currentPage === index + 1
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  {index + 1}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      <div className='rounded bg-white shadow'>
        <div className='rounded-t bg-gray-100 p-4'>
          <h4 className='text-xl font-semibold'>Teams</h4>
        </div>
        <div className='grid gap-4 p-4 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-5'>
          {teams.map(team => (
            <div
              key={team}
              className='cursor-pointer rounded-lg bg-white p-4 text-center shadow hover:bg-gray-100'
              onClick={() => console.log('Team clicked:', team)}
            >
              <img
                src='/api/placeholder/50/50'
                alt={`${team} logo`}
                className='mx-auto mb-2 h-12 w-12'
              />
              <h6 className='text-sm font-medium'>{team}</h6>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default CompetitionOverview;

================
File: frontend/src/components/homepage/Home.js
================
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage } from '../common';
import * as api from '../../services/api';

const Home = () => {
  const [leagues, setLeagues] = useState([]);
  const [selectedLeague, setSelectedLeague] = useState(null);
  const [seasons, setSeasons] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showModal, setShowModal] = useState(false);
  const modalRef = useRef(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchLeagues = async () => {
      try {
        const competitionsData = await api.getCompetitions();
        const uniqueLeagues = Object.values(
          competitionsData.reduce((acc, comp) => {
            if (
              !acc[comp.competition_id] ||
              new Date(comp.season_name) >
                new Date(acc[comp.competition_id].season_name)
            ) {
              acc[comp.competition_id] = {
                id: comp.competition_id,
                name: comp.competition_name,
                country: comp.country_name,
                gender: comp.competition_gender,
                international: comp.competition_international,
                logoUrl: `/api/placeholder/100/100`,
              };
            }
            return acc;
          }, {}),
        ).sort((a, b) => a.name.localeCompare(b.name));

        setLeagues(uniqueLeagues);
        setError(null);
      } catch (err) {
        setError('Failed to load leagues');
      } finally {
        setLoading(false);
      }
    };

    fetchLeagues();
  }, []);

  useEffect(() => {
    const handleClickOutside = event => {
      if (modalRef.current && !modalRef.current.contains(event.target)) {
        setShowModal(false);
      }
    };

    if (showModal) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showModal]);

  const handleLeagueClick = async league => {
    try {
      const seasonsData = await api.getSeasons(league.id);
      const sortedSeasons = seasonsData.sort(
        (a, b) => new Date(b.season_name) - new Date(a.season_name),
      );
      setSeasons(sortedSeasons);
      setSelectedLeague(league);
      setShowModal(true);
      setError(null);
    } catch (err) {
      setError('Failed to load seasons for this league');
    }
  };

  if (loading) {
    return <LoadingSpinner message='Loading leagues...' />;
  }

  if (error) {
    return (
      <ErrorMessage
        message={error}
        action={{
          label: 'Try Again',
          onClick: () => window.location.reload(),
        }}
      />
    );
  }

  return (
    <div className='container mx-auto bg-gray-100 py-8'>
      <h1 className='mb-6 text-center text-3xl font-semibold'>
        Select a League
      </h1>

      {error && (
        <div className='mb-6 rounded border border-red-400 bg-red-100 px-4 py-3 text-center text-red-700'>
          {error}
        </div>
      )}

      <div className='grid gap-6 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4'>
        {leagues.map(league => (
          <div
            key={league.id}
            className='transform cursor-pointer rounded-lg bg-white p-6 text-center shadow-lg transition-transform hover:scale-105'
            onClick={() => handleLeagueClick(league)}
          >
            <img
              src={league.logoUrl}
              alt={`${league.name} logo`}
              className='mx-auto mb-4 h-24 w-24 object-contain'
            />
            <h3 className='text-xl font-semibold'>{league.name}</h3>
            <p className='text-gray-500'>
              {league.country} {league.international && '• International'}
            </p>
          </div>
        ))}
      </div>

      {showModal && (
        <div className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'>
          <div
            ref={modalRef}
            className='w-full max-w-lg overflow-hidden rounded-lg bg-white shadow-lg'
          >
            <div className='flex items-center justify-between border-b p-4'>
              <h2 className='text-xl font-semibold'>
                {selectedLeague?.name} - Select Season
              </h2>
              <button
                className='text-gray-500 hover:text-gray-700'
                onClick={() => setShowModal(false)}
              >
                &times;
              </button>
            </div>
            <div className='p-6'>
              <div className='grid gap-4 sm:grid-cols-2'>
                {seasons.map(season => (
                  <div
                    key={season.season_id}
                    className='cursor-pointer rounded-lg bg-gray-100 p-4 text-center hover:bg-gray-200'
                    onClick={() =>
                      navigate(
                        `/league/${selectedLeague.id}/${season.season_id}`,
                      )
                    }
                  >
                    <h3 className='text-lg'>{season.season_name}</h3>
                  </div>
                ))}
              </div>
            </div>
            <div className='border-t p-4 text-right'>
              <button
                className='rounded-lg bg-gray-200 px-4 py-2 hover:bg-gray-300'
                onClick={() => setShowModal(false)}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Home;

================
File: frontend/src/components/match/MatchDetails.js
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage } from '../common';
import MatchHeader from './MatchHeader';
import MatchLineups from './MatchLineups';
import * as api from '../../services/api';

const MatchDetails = () => {
  const { competitionId, seasonId, matchId } = useParams(); // Updated
  const navigate = useNavigate();
  const location = useLocation();
  const [matchData, setMatchData] = useState(location.state?.matchData || null);
  const [lineups, setLineups] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);

        // If we don't have match data from navigation state, fetch it
        let currentMatch = matchData;
        if (!currentMatch) {
          const matches = await api.getCompetitionMatches(
            competitionId,
            seasonId,
          ); // Updated
          currentMatch = matches.find(m => m.match_id.toString() === matchId);
          if (!currentMatch) throw new Error('Match not found');
          setMatchData(currentMatch);
        }

        // Fetch lineups
        const lineupsData = await api.getMatchLineups(matchId);
        console.log('Fetched lineups:', lineupsData);
        setLineups(lineupsData);
        setError(null);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('Failed to load match data');
      } finally {
        setLoading(false);
      }
    };

    if (matchId) fetchData();
  }, [matchId, competitionId, seasonId, matchData]); // Updated dependencies

  const handlePlayerClick = player => {
    if (!player?.player_name) {
      console.error('Invalid player data:', player);
      return;
    }

    navigate(
      `/player-performance/${competitionId}/${seasonId}/${matchId}/${encodeURIComponent(player.player_name)}`, // Updated
      {
        state: {
          playerInfo: {
            playerId: player.player_id,
            playerName: player.player_name,
            nickname: player.nickname,
            jerseyNumber: player.jersey_number,
            team: player.team_name,
            position: player.positions?.[0]?.position,
          },
          matchData: matchData,
        },
      },
    );
  };

  if (loading) return <LoadingSpinner message='Loading match data...' />;
  if (error) return <ErrorMessage message={error} />;
  if (!matchData || !lineups) return null;

  return (
    <div className='container mx-auto px-4 py-4'>
      <MatchHeader matchData={matchData} />
      <MatchLineups
        lineups={lineups}
        matchData={matchData}
        onPlayerClick={handlePlayerClick}
      />
    </div>
  );
};

export default MatchDetails;

================
File: frontend/src/components/match/MatchHeader.js
================
import React from 'react';
import { format } from 'date-fns';
import { MapPin, User, Clock } from 'lucide-react';

const MatchHeader = ({ matchData }) => {
  if (!matchData) return null;

  const getStatusColor = status => {
    switch (status?.toLowerCase()) {
      case 'available':
        return 'bg-green-100 text-green-800';
      case 'scheduled':
        return 'bg-blue-100 text-blue-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className='mb-6 overflow-hidden rounded-lg bg-white shadow'>
      {/* Competition Info */}
      <div className='border-b border-gray-200 bg-blue-600 p-4 text-white'>
        <h2 className='text-2xl font-bold'>{matchData.competition}</h2>
        <p className='text-sm opacity-80'>
          {matchData.season} - {matchData.competition_stage}
        </p>
      </div>

      {/* Match Status & Date */}
      <div className='border-b border-gray-200 bg-gray-50 p-4'>
        <div className='flex items-center justify-between'>
          <div className='flex items-center gap-2'>
            <Clock className='h-4 w-4 text-gray-500' />
            <span className='text-sm text-gray-600'>
              {format(new Date(matchData.match_date), 'MMMM d, yyyy')} -{' '}
              {matchData.kick_off?.slice(0, 5)}
            </span>
          </div>
          <span
            className={`rounded-full px-3 py-1 text-sm ${getStatusColor(matchData.match_status)}`}
          >
            {matchData.match_status}
          </span>
        </div>
      </div>

      {/* Teams & Score */}
      <div className='grid grid-cols-7 items-center gap-4 p-6'>
        {/* Home Team */}
        <div className='col-span-3 text-right'>
          <h3 className='text-xl font-semibold'>{matchData.home_team}</h3>
          {matchData.home_managers && (
            <div className='mt-2 flex items-center justify-end gap-1 text-sm text-gray-600'>
              <User className='h-4 w-4' />
              {matchData.home_managers}
            </div>
          )}
        </div>

        {/* Score */}
        <div className='col-span-1 text-center'>
          <div className='text-2xl font-bold'>
            {typeof matchData.home_score === 'number' &&
            typeof matchData.away_score === 'number'
              ? `${matchData.home_score} - ${matchData.away_score}`
              : 'vs'}
          </div>
          {matchData.match_week && (
            <div className='mt-1 text-xs text-gray-500'>
              Week {matchData.match_week}
            </div>
          )}
        </div>

        {/* Away Team */}
        <div className='col-span-3 text-left'>
          <h3 className='text-xl font-semibold'>{matchData.away_team}</h3>
          {matchData.away_managers && (
            <div className='mt-2 flex items-center gap-1 text-sm text-gray-600'>
              <User className='h-4 w-4' />
              {matchData.away_managers}
            </div>
          )}
        </div>
      </div>

      {/* Additional Info */}
      {(matchData.stadium || matchData.referee) && (
        <div className='border-t border-gray-200 bg-gray-50 p-4'>
          <div className='flex flex-wrap items-center gap-6'>
            {matchData.stadium && (
              <div className='flex items-center gap-2 text-sm text-gray-600'>
                <MapPin className='h-4 w-4' />
                {matchData.stadium}
              </div>
            )}
            {matchData.referee && (
              <div className='flex items-center gap-2 text-sm text-gray-600'>
                <User className='h-4 w-4' />
                Referee: {matchData.referee}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default MatchHeader;

================
File: frontend/src/components/match/MatchLineups.js
================
import React, { useState } from 'react';
import TeamLineup from './TeamLineup';

const MatchLineups = ({ lineups, matchData, onPlayerClick }) => {
  const [showSubs, setShowSubs] = useState(true);

  // Debug logs
  console.log('Match Data:', matchData);
  console.log('Lineups Data:', lineups);

  // Ensure we have the required data
  if (!matchData?.home_team || !matchData?.away_team || !lineups) {
    return null;
  }

  const handleToggleSubs = () => {
    setShowSubs(!showSubs);
  };

  // Create lineup data for each team
  const homeTeam = {
    teamName: matchData.home_team,
    players: (lineups[matchData.home_team] || []).map(player => ({
      ...player,
      team_name: matchData.home_team,
    })),
  };

  const awayTeam = {
    teamName: matchData.away_team,
    players: (lineups[matchData.away_team] || []).map(player => ({
      ...player,
      team_name: matchData.away_team,
    })),
  };

  return (
    <div className='grid gap-6 md:grid-cols-2'>
      <TeamLineup
        teamName={homeTeam.teamName}
        players={homeTeam.players}
        onPlayerClick={onPlayerClick}
        showSubs={showSubs}
        onToggleSubs={handleToggleSubs}
        side='left'
      />
      <TeamLineup
        teamName={awayTeam.teamName}
        players={awayTeam.players}
        onPlayerClick={onPlayerClick}
        showSubs={showSubs}
        onToggleSubs={handleToggleSubs}
        side='right'
      />
    </div>
  );
};

export default MatchLineups;

================
File: frontend/src/components/match/TeamLineup.js
================
import React from 'react';
import { Users, ChevronDown, ChevronUp } from 'lucide-react';
import TeamLineupTable from './TeamLineupTable';

const TeamLineup = ({
  teamName,
  players,
  onPlayerClick,
  showSubs,
  onToggleSubs,
  side = 'left',
}) => {
  const getPlayerStatus = player => {
    if (!player.positions?.length) return 'Unknown';
    const startReason = player.positions[0].start_reason;
    if (startReason?.includes('Substitution - On')) return 'Substitute';
    if (startReason === 'Starting XI') return 'Starting XI';
    return startReason || 'Unknown';
  };

  const startingXI = players.filter(p => getPlayerStatus(p) === 'Starting XI');
  const substitutes = players.filter(
    p =>
      p.positions?.length > 0 &&
      p.positions[0].start_reason?.includes('Substitution - On'),
  );

  return (
    <div className='mb-6 overflow-hidden rounded-lg bg-white shadow'>
      <div className='border-b border-gray-200 bg-gray-50 px-4 py-3'>
        <div className='flex items-center justify-between'>
          <div className='flex items-center gap-2'>
            <Users className='h-5 w-5 text-gray-500' />
            <h5 className='m-0 font-semibold'>{teamName}</h5>
          </div>
        </div>
      </div>

      <div className='p-0'>
        <div className='border-b border-gray-100 bg-green-50/30 px-4 py-2'>
          <h6 className='m-0 text-sm font-semibold text-gray-600'>
            Starting XI ({startingXI.length})
          </h6>
        </div>

        <TeamLineupTable players={startingXI} onPlayerClick={onPlayerClick} />

        {substitutes.length > 0 && (
          <div className='border-t-2 border-blue-200'>
            <div
              className='flex cursor-pointer items-center justify-between bg-blue-50 px-4 py-3'
              onClick={onToggleSubs}
            >
              <h6 className='m-0 text-sm font-semibold text-gray-600'>
                Substitutes ({substitutes.length})
              </h6>
              {showSubs ? (
                <ChevronUp className='h-5 w-5 text-blue-500' />
              ) : (
                <ChevronDown className='h-5 w-5 text-blue-500' />
              )}
            </div>

            {showSubs && (
              <TeamLineupTable
                players={substitutes}
                onPlayerClick={onPlayerClick}
              />
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default TeamLineup;

================
File: frontend/src/components/match/TeamLineupTable.js
================
import React from 'react';

const TeamLineupTable = ({ players, onPlayerClick }) => (
  <table className='w-full'>
    <tbody>
      {players.map(player => (
        <tr
          key={player.player_id}
          onClick={() => onPlayerClick(player)}
          className='cursor-pointer border-b border-gray-50 hover:bg-gray-50'
        >
          <td className='px-4 py-3 text-sm'>{player.jersey_number || '-'}</td>
          <td className='px-4 py-3'>
            <div>
              <div className='font-medium'>
                {player.nickname || player.player_name}
              </div>
              {player.nationality && (
                <div className='text-xs text-gray-500'>
                  {player.nationality}
                </div>
              )}
            </div>
          </td>
          <td className='px-4 py-3 text-sm'>
            {player.positions?.[0]?.position || '-'}
          </td>
        </tr>
      ))}
    </tbody>
  </table>
);

export default TeamLineupTable;

================
File: frontend/src/components/pitch/BasePitch.js
================
import React from 'react';
import { ORIENTATIONS } from './constants';

const getViewBox = orientation => {
  switch (orientation) {
    case ORIENTATIONS.VERTICAL:
      return '0 -2 80 124';
    case ORIENTATIONS.HALF_VERTICAL:
      return '-2 -2 84 64';
    case ORIENTATIONS.HORIZONTAL:
    default:
      return '-2 -2 124 84';
  }
};

const getAspectRatio = orientation => {
  switch (orientation) {
    case ORIENTATIONS.VERTICAL:
      return 'aspect-[2/3]';
    case ORIENTATIONS.HALF_VERTICAL:
      return 'aspect-[4/3]';
    case ORIENTATIONS.HORIZONTAL:
    default:
      return 'aspect-[3/2]';
  }
};

const BasePitch = ({
  children,
  onPitchClick,
  orientation = ORIENTATIONS.HORIZONTAL,
  background = 'bg-white',
  stroke = '#CBD5E1',
  fill = 'none',
  maxWidth = 'max-w-3xl',
}) => {
  const isVertical = orientation === ORIENTATIONS.VERTICAL;
  const isHalfVertical = orientation === ORIENTATIONS.HALF_VERTICAL;

  const renderPitchElements = () => {
    if (isHalfVertical) {
      return (
        <>
          <rect x='0' y='0' width='80' height='60' />
          <line x1='0' y1='60' x2='80' y2='60' />
          <path d='M 30,60 A 10,10 0 0 1 50,60' />
          <circle cx='40' cy='60' r='0.3' fill={stroke} />
          <rect x='18' y='0' width='44' height='18' />
          <rect x='30' y='0' width='20' height='6' />
          <rect
            x='36'
            y='-0.5'
            width='8'
            height='0.5'
            style={{ fill: stroke }}
          />
          <path d='M 32.5,18 A 10,10 0 0,0 48,18' />
          <circle cx='40' cy='12' r='0.3' fill={stroke} />
          <path d='M 0,1 A 3,3 0 0,0 1,0' />
          <path d='M 79,0 A 3,3 0 0,0 80,1' />
        </>
      );
    }

    const standardElements = (
      <>
        <rect
          x='0'
          y='0'
          width={isVertical ? '80' : '120'}
          height={isVertical ? '120' : '80'}
          style={{ fill }}
        />
        {isVertical ? (
          <line x1='0' y1='60' x2='80' y2='60' />
        ) : (
          <line x1='60' y1='0' x2='60' y2='80' />
        )}
        <circle
          cx={isVertical ? '40' : '60'}
          cy={isVertical ? '60' : '40'}
          r='10'
        />
        <circle
          cx={isVertical ? '40' : '60'}
          cy={isVertical ? '60' : '40'}
          r='0.3'
          fill={stroke}
        />
        {/* Penalty areas and other elements */}
        {isVertical ? (
          <>
            {/* Vertical orientation penalty areas */}
            <rect x='18' y='0' width='44' height='18' />
            <rect x='30' y='0' width='20' height='6' />
            <rect x='18' y='102' width='44' height='18' />
            <rect x='30' y='114' width='20' height='6' />
            {/* Goals */}
            <rect
              x='36'
              y='-0.5'
              width='8'
              height='0.5'
              style={{ fill: stroke }}
            />
            <rect
              x='36'
              y='120'
              width='8'
              height='0.5'
              style={{ fill: stroke }}
            />
            {/* Penalty arcs */}
            <path d='M 32.5,18 A 10,10 0 0,0 48,18' />
            <path d='M 32.5,102 A 10,10 0 0,1 48,102' />
          </>
        ) : (
          <>
            {/* Horizontal orientation penalty areas */}
            <rect x='0' y='18' width='18' height='44' />
            <rect x='0' y='30' width='6' height='20' />
            <rect x='102' y='18' width='18' height='44' />
            <rect x='114' y='30' width='6' height='20' />
            {/* Goals */}
            <rect
              x='-0.5'
              y='36'
              width='0.5'
              height='8'
              style={{ fill: stroke }}
            />
            <rect
              x='120'
              y='36'
              width='0.5'
              height='8'
              style={{ fill: stroke }}
            />
            {/* Penalty arcs */}
            <path d='M 18,32.5 A 10,10 0 0,1 18,48' />
            <path d='M 102,32.5 A 10,10 0 0,0 102,48' />
          </>
        )}
      </>
    );

    return standardElements;
  };

  return (
    <div
      className={`relative ${getAspectRatio(orientation)} w-full ${maxWidth} border-2 border-slate-400 ${background}`}
    >
      <svg
        viewBox={getViewBox(orientation)}
        className='absolute inset-0 h-full w-full'
        style={{
          strokeWidth: '0.2',
          stroke,
          fill: 'none',
        }}
        onClick={onPitchClick}
      >
        {renderPitchElements()}
        {children}
      </svg>
    </div>
  );
};

export default BasePitch;

================
File: frontend/src/components/pitch/constants.js
================
export const ORIENTATIONS = {
  HORIZONTAL: 'horizontal',
  VERTICAL: 'vertical',
  HALF_VERTICAL: 'half-vertical',
};

export const COLOR_SCHEMES = {
  LIGHT: {
    background: 'bg-white',
    stroke: '#CBD5E1',
    fill: 'none',
  },
  DARK: {
    background: 'bg-black',
    stroke: '#CBD5E1',
    fill: '#121212',
  },
};

================
File: frontend/src/components/pitch/GoalPost.js
================
import React from 'react';

export const GoalPostVisualization = ({ children }) => {
  const goalStroke = 'grey'; // color of posts
  const lineStroke = 'black'; // ground color
  const goalStrokeWidth = 0.4; // Stroke width of the goal frame
  const lineStrokeWidth = 0.1; // Stroke width of the ground line
  const lineBottom = 2.67 + 2.67 + goalStrokeWidth / 2; // Calculate Y post of ground line (affected by width of the goal)

  //     viewBox="30 -1 20 7" ONLY SHOWING THE SIX YARD BOX CAN LATER MAP BACK TO OG COORD TO FIND MAX HEIGHT SHOWING
  //         |<---20--->|
  // 30      36    44      50
  // |       |     |       |
  // |       ╭─────╮       |
  // |       │     │       |
  // |       │     │       |
  // |   ────┴─────┴────   |
  //     32         48

  // Y coordinate
  //    -1 ─ ─ ─ Above origin (top of view)
  //     0 ──── Origin
  //     1 ────
  //     2 ────
  //     3 ──── ╭─────╮  Goal posts start at Y=2.67
  //     4 ──── │     │
  //     5 ──── │     │  Goal posts end at Y=5.34
  //     6 ──── ┴─────┴  Ground line at Y=5.74
  //     |
  //    7 units
  //    total
  //    height

  return (
    <div className='h-[300px] w-full'>
      <svg
        viewBox='30 -1 20 7'
        className='h-full w-full'
        preserveAspectRatio='xMidYMid meet'
      >
        {/* Goal frame as a path - only top and sides */}
        <path
          d='M36 5.34 L36 2.67 L44 2.67 L44 5.34'
          fill='none'
          stroke={goalStroke}
          strokeWidth={goalStrokeWidth}
          strokeLinejoin='round'
          strokeLinecap='square'
        />

        {/* Ground line */}
        <line
          x1='30'
          y1={lineBottom}
          x2='50'
          y2={lineBottom}
          stroke={lineStroke}
          strokeWidth={lineStrokeWidth}
          strokeLinecap='square'
        />

        {children}
      </svg>
    </div>
  );
};

export default GoalPostVisualization;

================
File: frontend/src/components/pitch/HalfVerticalPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const HalfVerticalPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HALF_VERTICAL}
    {...COLOR_SCHEMES.LIGHT}
    maxWidth='max-w-xl'
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default HalfVerticalPitch;

================
File: frontend/src/components/pitch/HeatSoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const HeatSoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HORIZONTAL}
    {...COLOR_SCHEMES.DARK}
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default HeatSoccerPitch;

================
File: frontend/src/components/pitch/index.js
================
export { default as SoccerPitch } from './SoccerPitch';
export { default as HeatSoccerPitch } from './HeatSoccerPitch';
export { default as VerticalSoccerPitch } from './VerticalSoccerPitch';
export { default as HalfVerticalPitch } from './HalfVerticalPitch';
export * from './constants';

================
File: frontend/src/components/pitch/SoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const SoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HORIZONTAL}
    {...COLOR_SCHEMES.LIGHT}
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default SoccerPitch;

================
File: frontend/src/components/pitch/VerticalSoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const VerticalSoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.VERTICAL}
    {...COLOR_SCHEMES.LIGHT}
    maxWidth='max-w-xl'
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default VerticalSoccerPitch;

================
File: frontend/src/components/player/features/defending/DefendingItemDetails.js
================
import React from 'react';

export const DefendingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a defensive action to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Action Type</p>
        <p className='text-sm font-bold'>{selectedItem.type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Outcome</p>
        <p className='text-sm font-bold'>
          {selectedItem.outcome || 'Successful'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Pressure Duration</p>
        <p className='text-sm font-bold'>
          {selectedItem.pressure_duration
            ? `${selectedItem.pressure_duration}s`
            : 'N/A'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Duel Type</p>
        <p className='text-sm font-bold'>{selectedItem.duel_type || 'N/A'}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Recovery Type</p>
        <p className='text-sm font-bold'>
          {selectedItem.recovery_type || 'N/A'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Pressure Regain</p>
        <p className='text-sm font-bold'>
          {selectedItem.pressure_regain ? 'Yes' : 'No'}
        </p>
      </div>
    </div>
  );
};

================
File: frontend/src/components/player/features/passing/PassingItemDetails.js
================
import React from 'react';

export const PassingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a pass to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Pass Type</p>
        <p className='text-sm font-bold'>{selectedItem.pass_type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Length</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_length?.toFixed(1)}m
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Outcome</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_outcome || 'Complete'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Height</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_height || 'Ground'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Progressive</p>
        <p className='text-sm font-bold'>
          {selectedItem.progressive ? 'Yes' : 'No'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Assist</p>
        <p className='text-sm font-bold'>
          {selectedItem.assist ? 'Yes' : 'No'}
        </p>
      </div>
    </div>
  );
};

================
File: frontend/src/components/player/features/shooting/ShootingItemDetails.js
================
import React from 'react';

export const ShootingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a shot to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Shot Outcome</p>
        <p className='text-sm font-bold'>{selectedItem.shot_outcome}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Expected Goals (xG)</p>
        <p className='text-sm font-bold'>
          {selectedItem.shot_statsbomb_xg?.toFixed(2)}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Shot Type</p>
        <p className='text-sm font-bold'>{selectedItem.shot_type}</p>
      </div>
    </div>
  );
};

================
File: frontend/src/components/player/features/summary/SummaryItemDetails.js
================
import React from 'react';

export const SummaryItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a touch point to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Touch Type</p>
        <p className='text-sm font-bold'>{selectedItem.type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>X Location</p>
        <p className='text-sm font-bold'>
          {selectedItem.location[0].toFixed(1)}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Y Location</p>
        <p className='text-sm font-bold'>
          {selectedItem.location[1].toFixed(1)}
        </p>
      </div>
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/statoverview/ShootingStatsOverview.js
================
import React from 'react';
import { StatCard } from './StatCard';

export const ShootingStatsOverview = ({ statistics }) => {
  if (!statistics) return null;

  return (
    <div className='grid grid-cols-2 gap-2'>
      {/* First row - Goals and xG side by side */}
      <StatCard label='Goals' value={`${statistics.goals}`} />
      <StatCard label='Expected Goals' value={statistics.total_xg.toFixed(2)} />

      {/* Second row */}
      <StatCard
        label='Shots on target'
        value={`${statistics.shots_on_target}`}
      />
      <StatCard
        label='Shots off target'
        value={`${statistics.shots_off_target}`}
      />

      {/* Only render shots blocked if not zero */}
      {statistics.shots_blocked > 0 && (
        <div className='col-span-2'>
          <StatCard
            label='Shots blocked'
            value={`${statistics.shots_blocked}`}
          />
        </div>
      )}

      {/* Accuracy and conversion side by side */}
      <StatCard
        label='Shooting accuracy'
        value={`${statistics.shot_accuracy}%`}
      />
      <StatCard
        label='Shot conversion'
        value={`${statistics.shot_conversion}%`}
      />
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/statoverview/StatCard.js
================
export const StatCard = ({ label, value, className = '' }) => (
  <div className={`rounded-lg bg-gray-50 p-3 ${className}`}>
    <p className='text-xs text-gray-500'>{label}</p>
    <p className='text-lg font-bold'>{value}</p>
  </div>
);

================
File: frontend/src/components/player/PlayerMatchPerformance/components/statoverview/SummaryStatsOverview.js
================
import React from 'react';
import { StatCard } from './StatCard';

export const SummaryStatsOverview = ({ touches }) => {
  if (!touches) return null;

  return (
    <div className='grid grid-cols-3 gap-2 lg:grid-cols-1'>
      <StatCard label='Touches' value={touches.length} />
      <StatCard
        label='Shots'
        value={touches.filter(t => t.type === 'Shot').length}
      />
      <StatCard
        label='Passes'
        value={touches.filter(t => t.type === 'Pass').length}
      />
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/ItemDetails.js
================
// src/components/ItemDetails.jsx
import React from 'react';
import { STAT_TYPES } from '../config/statTypes';
// EDIT FOR ONLY SUBSTAT
export const ItemDetails = ({ selectedStat, selectedItem }) => {
  const renderDetails = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        if (!selectedItem) {
          return (
            <div className='text-center text-gray-500'>
              Select a shot to see details
            </div>
          );
        }
        return (
          <div className='grid grid-cols-3 gap-4'>
            <div>
              <p className='text-xs text-gray-500'>Shot Outcome</p>
              <p className='text-sm font-bold'>{selectedItem.shot_outcome}</p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Expected Goals (xG)</p>
              <p className='text-sm font-bold'>
                {selectedItem.shot_statsbomb_xg?.toFixed(2)}
              </p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Shot Type</p>
              <p className='text-sm font-bold'>{selectedItem.shot_type}</p>
            </div>
          </div>
        );

      case STAT_TYPES.SUMMARY:
        if (!selectedItem) {
          return (
            <div className='text-center text-gray-500'>
              Select a touch point to see details
            </div>
          );
        }
        return (
          <div className='grid grid-cols-3 gap-4'>
            <div>
              <p className='text-xs text-gray-500'>Touch Type</p>
              <p className='text-sm font-bold'>{selectedItem.type}</p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>X Location</p>
              <p className='text-sm font-bold'>
                {selectedItem.location[0].toFixed(1)}
              </p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Y Location</p>
              <p className='text-sm font-bold'>
                {selectedItem.location[1].toFixed(1)}
              </p>
            </div>
          </div>
        );

      default:
        return (
          <div className='text-center text-gray-500'>
            Select an item to see details
          </div>
        );
    }
  };

  return (
    <div className='rounded-lg bg-white p-4 shadow-sm'>{renderDetails()}</div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/PlayerProfile.js
================
import React from 'react';

export const PlayerProfile = ({ playerInfo = {} }) => {
  return (
    <div className='col-span-12 rounded-lg bg-white p-4 shadow-lg lg:col-span-3'>
      <div className='flex items-center space-x-4'>
        <div className='h-16 w-16 rounded-full bg-gray-200'>
          {playerInfo?.jerseyNumber && (
            <div className='flex h-full w-full items-center justify-center text-xl font-bold text-gray-600'>
              {playerInfo.jerseyNumber}
            </div>
          )}
        </div>
        <div>
          <h3 className='font-semibold'>
            {playerInfo?.nickname || playerInfo?.playerName || 'Player Name'}
          </h3>
          <p className='text-sm text-gray-600'>
            {playerInfo?.team} • {playerInfo?.position || 'Position'}
          </p>
        </div>
      </div>
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/StatNavigation.js
================
import React from 'react';
import { statCategories } from '../config/statConfig';

export const StatNavigation = ({ selectedStat, onStatChange }) => (
  <div className='col-span-12 flex items-center rounded-lg bg-white px-6 py-4 shadow-lg lg:col-span-9'>
    <div className='flex space-x-4 overflow-x-auto'>
      {statCategories.map(category => (
        <button
          key={category.id}
          className={`whitespace-nowrap rounded-full px-4 py-1.5 text-sm font-medium transition-colors ${
            selectedStat === category.id
              ? 'bg-blue-500 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
          onClick={() => onStatChange(category)}
        >
          {category.name}
        </button>
      ))}
    </div>
  </div>
);

================
File: frontend/src/components/player/PlayerMatchPerformance/components/StatOverview.js
================
import { STAT_TYPES, STAT_TITLES } from '../config/statTypes';
import { ShootingStatsOverview } from './statoverview/ShootingStatsOverview';
import { SummaryStatsOverview } from './statoverview/SummaryStatsOverview';

export const StatOverview = ({ selectedStat, data }) => {
  const renderStats = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        return <ShootingStatsOverview statistics={data?.statistics} />;
      case STAT_TYPES.SUMMARY:
        return <SummaryStatsOverview touches={data?.touches} />;
      default:
        return null;
    }
  };

  return (
    <div className='mb-4 rounded-lg bg-white p-4 shadow-lg'>
      <h3 className='mb-3 text-lg font-semibold'>
        {STAT_TITLES[selectedStat] || 'Overview'}
      </h3>
      {renderStats()}
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/SubStatNavigation.js
================
import React from 'react';
import { statCategories } from '../config/statConfig'; // change for getSubStatTypes(selectedStat);

export const SubStatNavigation = ({
  selectedStat,
  selectedSubStat,
  onSubStatChange,
}) => {
  const subStats =
    statCategories.find(cat => cat.id === selectedStat)?.subStats || [];

  return (
    <div className='mb-4 flex space-x-4 overflow-x-auto'>
      {subStats.map(subStat => (
        <button
          key={subStat.id}
          className={`whitespace-nowrap rounded-md px-4 py-2 ${
            selectedSubStat === subStat.id
              ? 'bg-blue-100 text-blue-700'
              : 'text-gray-600 hover:bg-gray-100'
          }`}
          onClick={() => onSubStatChange(subStat.id)}
        >
          {subStat.name}
        </button>
      ))}
    </div>
  );
};

================
File: frontend/src/components/player/PlayerMatchPerformance/components/Visualization.js
================
// src/components/Visualization.jsx
import React from 'react';
import { STAT_TYPES } from '../config/statTypes';
import { statCategories } from '../config/statConfig';

export const Visualization = ({
  selectedStat,
  selectedSubStat,
  data,
  selectedItem,
  onItemClick,
}) => {
  const category = statCategories.find(cat => cat.id === selectedStat);
  const subStat = category?.subStats.find(sub => sub.id === selectedSubStat);

  if (!subStat) return null;

  const { container: Container, component: Component } = subStat;

  // Determine props based on stat type
  const getComponentProps = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        return {
          shots: data?.shots || [],
          onShotClick: onItemClick,
          selectedShot: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.SUMMARY:
        return {
          touches: data?.touches || [], // Fix: Access touches from data object
          onTouchClick: onItemClick,
          selectedTouch: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.PASSING:
        return {
          passes: data?.passes || [],
          onPassClick: onItemClick,
          selectedPass: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.DEFENDING:
        return {
          actions: data?.actions || [],
          onActionClick: onItemClick,
          selectedAction: selectedItem,
          showLabels: false,
        };

      default:
        return {};
    }
  };

  const componentProps = getComponentProps();

  return (
    <Container>
      <Component {...componentProps} />
    </Container>
  );
};

// component = touches and container = pitch

================
File: frontend/src/components/player/PlayerMatchPerformance/config/statConfig.js
================
import { STAT_TYPES } from './statTypes';
import SoccerPitch from '../../../pitch/SoccerPitch';
import VerticalSoccerPitch from '../../../pitch/VerticalSoccerPitch';
import HalfVerticalPitch from '../../../pitch/HalfVerticalPitch';
import { GoalPostVisualization } from '../../../pitch/GoalPost';
import PlayerMatchTouches from '../visualizations/PlayerMatchTouches';
import PlayerMatchShots from '../visualizations/PlayerMatchShots';

export const statCategories = [
  {
    id: STAT_TYPES.SUMMARY, // Using new enum
    name: 'Summary',
    subStats: [
      {
        id: 'touches',
        name: 'Touches',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchTouches {...props} orientation='horizontal' />
        ),
      },
      {
        id: 'heatmap',
        name: 'Heatmap',
        container: ({ children }) => (
          <div className='mx-auto w-full max-w-xl'>
            <VerticalSoccerPitch>{children}</VerticalSoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchTouches {...props} orientation='vertical' />
        ),
      },
    ],
  },
  {
    id: STAT_TYPES.SHOOTING,
    name: 'Shooting',
    subStats: [
      {
        id: 'shots-vertical',
        name: 'Shots (Vertical)',
        container: ({ children }) => (
          <div className='mx-auto w-full max-w-xl'>
            <HalfVerticalPitch>{children}</HalfVerticalPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='vertical' />
        ),
      },
      {
        id: 'shots-horizontal',
        name: 'Shots (Horizontal)',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='horizontal' />
        ),
      },
      {
        id: 'shots-goalview',
        name: 'Shots (Goal View)',
        container: ({ children }) => (
          <div className='w-full'>
            <GoalPostVisualization>{children}</GoalPostVisualization>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='goalview' />
        ),
      },
    ],
  },
  // New categories
  {
    id: STAT_TYPES.PASSING,
    name: 'Passing',
    subStats: [
      {
        id: 'passMap',
        name: 'Pass Map',
        container: ({ children }) => (
          <div className='w-full'>
            <GoalPostVisualization>{children}</GoalPostVisualization>
          </div>
        ),
        component: PlayerMatchTouches, // You'll need to create passing specific components
      },
    ],
  },
  {
    id: STAT_TYPES.DEFENDING,
    name: 'Defending',
    subStats: [
      {
        id: 'defensiveActions',
        name: 'Defensive Actions',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: PlayerMatchTouches, // You'll need to create defending specific components
      },
    ],
  },
];

export const getStatConfig = statType => {
  return statCategories.find(config => config.id === statType);
};

================
File: frontend/src/components/player/PlayerMatchPerformance/config/statTypes.js
================
export const STAT_TYPES = {
  SUMMARY: 'summary',
  SHOOTING: 'shooting',
  PASSING: 'passing',
  DEFENDING: 'defending',
};

export const SUB_STAT_TYPES = {
  SUMMARY: {
    TOUCHES: 'touches',
    HEATMAP: 'heatmap',
  },
  SHOOTING: {
    SHOTS_VERTICAL: 'shots-vertical',
    SHOTS_HORIZONTAL: 'shots-horizontal',
    SHOTS_GOALVIEW: 'shots-goalview',
  },
  PASSING: {
    PASS_MAP: 'passMap',
  },
  DEFENDING: {
    DEFENSIVE_ACTIONS: 'defensiveActions',
  },
};

export const STAT_TITLES = {
  [STAT_TYPES.SUMMARY]: 'Match Overview',
  [STAT_TYPES.SHOOTING]: 'Shooting Overview',
  [STAT_TYPES.PASSING]: 'Passing Overview',
  [STAT_TYPES.DEFENDING]: 'Defending Overview',
};

export const getSubStatTypes = statType => {
  switch (statType) {
    case STAT_TYPES.SUMMARY:
      return SUB_STAT_TYPES.SUMMARY;
    case STAT_TYPES.SHOOTING:
      return SUB_STAT_TYPES.SHOOTING;
    case STAT_TYPES.PASSING:
      return SUB_STAT_TYPES.PASSING;
    case STAT_TYPES.DEFENDING:
      return SUB_STAT_TYPES.DEFENDING;
    default:
      return {};
  }
};

export const getDefaultSubStat = statType => {
  switch (statType) {
    case STAT_TYPES.SUMMARY:
      return SUB_STAT_TYPES.SUMMARY.TOUCHES;
    case STAT_TYPES.SHOOTING:
      return SUB_STAT_TYPES.SHOOTING.SHOTS_VERTICAL;
    case STAT_TYPES.PASSING:
      return SUB_STAT_TYPES.PASSING.PASS_MAP;
    case STAT_TYPES.DEFENDING:
      return SUB_STAT_TYPES.DEFENDING.DEFENSIVE_ACTIONS;
    default:
      return '';
  }
};

================
File: frontend/src/components/player/PlayerMatchPerformance/hooks/useStatData.js
================
import { useState, useEffect } from 'react';
import { STAT_TYPES } from '../config/statTypes';
import * as api from '../../../../services/api';

export const useStatData = (matchId, playerName, selectedStat) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      if (!matchId || !playerName) {
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        let result;

        switch (selectedStat) {
          case STAT_TYPES.SUMMARY: {
            const touchesData = await api.getPlayerMatchTouches(
              matchId,
              playerName,
            );
            result = {
              touches: touchesData,
            };
            break;
          }

          case STAT_TYPES.SHOOTING: {
            result = await api.getPlayerMatchShooting(matchId, playerName);
            break;
          }

          case STAT_TYPES.PASSING: {
            const passingData = await api.getPlayerMatchPassing(
              matchId,
              playerName,
            );
            result = {
              passes: passingData,
            };
            break;
          }

          case STAT_TYPES.DEFENDING: {
            const defendingData = await api.getPlayerMatchDefending(
              matchId,
              playerName,
            );
            result = {
              actions: defendingData,
            };
            break;
          }

          default:
            throw new Error(`Invalid stat type: ${selectedStat}`);
        }

        setData(result);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError(err.message || 'Failed to load data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [matchId, playerName, selectedStat]);

  return {
    data,
    loading,
    error,
    refresh: () => {
      setData(null);
      setLoading(true);
    },
  };
};

================
File: frontend/src/components/player/PlayerMatchPerformance/visualizations/index.js
================
export { default as PlayerMatchShots } from './PlayerMatchShots';
export { default as PlayerMatchTouches } from './PlayerMatchTouches';
export { default as PlayerVertMatchTouches } from './PlayerVertMatchTouches';

================
File: frontend/src/components/player/PlayerMatchPerformance/visualizations/PlayerMatchShots.js
================
import React, { useCallback } from 'react';

const PlayerMatchShots = ({
  shots = [],
  onShotClick,
  selectedShot,
  showLabels = true,
  orientation = 'vertical',
}) => {
  const handleShotClick = useCallback(
    (shot, event) => {
      event.stopPropagation();
      onShotClick?.(shot);
    },
    [onShotClick],
  );

  const getShotRadius = (xg, isGoalView) => {
    if (isGoalView) {
      return 0.2; // Smaller, fixed size for goal view
    }

    if (!xg) return 1;
    const xgValue = parseFloat(xg);
    if (xgValue <= 0.05) return 0.8;
    if (xgValue <= 0.15) return 1.2;
    if (xgValue <= 0.25) return 1.6;
    if (xgValue <= 0.35) return 2;
    return 2.4;
  };

  const getShotStyle = (shot, isSelected, isGoalView) => {
    const isGoal = shot.shot_outcome === 'Goal';
    return {
      fill: isGoal ? 'rgba(244, 63, 94, 0.6)' : 'rgba(0, 0, 0, 0.1)',
      stroke: isGoal ? '#000000' : '#000000',
      strokeWidth: isSelected
        ? isGoalView
          ? '0.1'
          : '0.4'
        : isGoalView
          ? '0.05'
          : '0.2',
      cursor: 'pointer',
    };
  };

  const mapRange = (value, a, b, c, d) => {
    return c + ((value - a) * (d - c)) / (b - a);
  };

  const getCoordinates = (location, isEndLocation = false) => {
    if (!location) return { x: 0, y: 0 };

    const [originalX, originalY, originalZ] = location;

    if (orientation === 'goalview' && isEndLocation) {
      return {
        x: originalY,
        y: originalZ !== undefined ? mapRange(originalZ, 0, 5.34, 5.34, 0) : 0,
      };
    }

    if (orientation === 'vertical') {
      return {
        x: originalY,
        y: 120 - originalX,
      };
    }

    return {
      x: originalX,
      y: originalY,
    };
  };

  const getLineStartPoint = (start, end, radius, isSelected) => {
    const startCoord = getCoordinates(start);
    const endCoord = getCoordinates(end);

    const dx = endCoord.x - startCoord.x;
    const dy = endCoord.y - startCoord.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const totalRadius = radius + (isSelected ? 0.5 : 0);

    return {
      x: startCoord.x + (dx / length) * totalRadius,
      y: startCoord.y + (dy / length) * totalRadius,
    };
  };

  return (
    <>
      {shots.map((shot, index) => {
        const isGoalView = orientation === 'goalview';
        const coords = isGoalView
          ? getCoordinates(shot.shot_end_location, true)
          : getCoordinates(shot.location);

        const isSelected = selectedShot?.id === shot.id;
        const shotStyle = getShotStyle(shot, isSelected, isGoalView);
        const radius = getShotRadius(shot.shot_statsbomb_xg, isGoalView);

        // Skip shots without end location for goalview
        if (isGoalView && !shot.shot_end_location) {
          return null;
        }

        return (
          <g
            key={shot.id || `${index}-${coords.x}-${coords.y}`}
            onClick={e => handleShotClick(shot, e)}
          >
            {isSelected && (
              <circle
                cx={coords.x}
                cy={coords.y}
                r={radius + (isGoalView ? 0.14 : 0.6)}
                fill='none'
                stroke='rgb(255, 0, 0)'
                strokeWidth={isGoalView ? '0.1' : '0.4'}
              />
            )}

            <circle cx={coords.x} cy={coords.y} r={radius} style={shotStyle} />

            {showLabels && !isGoalView && (
              <text
                x={coords.x}
                y={coords.y - radius - 0.5}
                fontSize='2'
                fill={shotStyle.stroke}
                textAnchor='middle'
                alignmentBaseline='bottom'
              >
                {index + 1}
              </text>
            )}

            {/* Only show trajectory line for pitch views, not goalview */}
            {isSelected && shot.shot_end_location && !isGoalView && (
              <line
                x1={
                  getLineStartPoint(
                    shot.location,
                    shot.shot_end_location,
                    radius,
                    true,
                  ).x
                }
                y1={
                  getLineStartPoint(
                    shot.location,
                    shot.shot_end_location,
                    radius,
                    true,
                  ).y
                }
                x2={getCoordinates(shot.shot_end_location).x}
                y2={getCoordinates(shot.shot_end_location).y}
                stroke='rgb(255, 0, 0)'
                strokeWidth='0.4'
              />
            )}
          </g>
        );
      })}
    </>
  );
};

export default PlayerMatchShots;

================
File: frontend/src/components/player/PlayerMatchPerformance/visualizations/PlayerMatchTouches.js
================
import React, { useCallback } from 'react';

const PlayerMatchTouches = ({
  touches = [],
  onTouchClick,
  selectedTouch,
  showLabels = true,
  orientation = 'horizontal', // New prop to control orientation
}) => {
  const handleTouchClick = useCallback(
    (touch, event) => {
      if (onTouchClick) {
        event.stopPropagation();
        onTouchClick(touch);
      }
    },
    [onTouchClick],
  );

  const getTouchStyle = touch => {
    const touchColors = {
      Shot: 'rgba(59, 130, 246, 0.5)',
      assist: 'rgba(234, 179, 8, 0.5)',
      default: 'rgba(234, 179, 8, 0.5)',
    };

    const borderColors = {
      Shot: 'rgb(59, 130, 246)',
      assist: 'rgb(234, 179, 8)',
      default: 'rgb(234, 179, 8)',
    };

    return {
      fill: touchColors[touch.type] || touchColors.default,
      stroke: borderColors[touch.type] || borderColors.default,
      strokeWidth: selectedTouch === touch ? '0.4' : '0.2',
    };
  };

  const getCoordinates = touch => {
    const [originalX, originalY] = touch.location;
    if (orientation === 'vertical') {
      return {
        x: originalY,
        y: 120 - originalX, // Assuming 120 is the pitch height
      };
    }
    return {
      x: originalX,
      y: originalY,
    };
  };

  return (
    <>
      {touches.map((touch, index) => {
        const { x, y } = getCoordinates(touch);
        const touchStyle = getTouchStyle(touch);

        return (
          <g
            key={`${index}-${touch.type}-${x}-${y}`}
            onClick={e => handleTouchClick(touch, e)}
            style={{ cursor: 'pointer' }}
          >
            {selectedTouch === touch && (
              <circle
                cx={x}
                cy={y}
                r='1.5'
                fill='none'
                stroke='rgb(239, 68, 68)'
                strokeWidth='0.2'
                strokeDasharray='0.5'
              />
            )}

            <circle cx={x} cy={y} r='1' {...touchStyle} />

            {showLabels && (
              <text
                x={x}
                y={y - 1.5}
                fontSize='2'
                fill={touchStyle.stroke}
                textAnchor='middle'
                alignmentBaseline='bottom'
              >
                {index + 1}
              </text>
            )}
          </g>
        );
      })}
    </>
  );
};

export default PlayerMatchTouches;

================
File: frontend/src/components/player/PlayerMatchPerformance/PlayerMatchPerformance.js
================
import React, { useState, useEffect } from 'react';
import { useParams, useLocation, useNavigate } from 'react-router-dom';
import { STAT_TYPES, getDefaultSubStat } from './config/statTypes';
import { useStatData } from './hooks/useStatData';
import { PlayerProfile } from './components/PlayerProfile';
import { StatNavigation } from './components/StatNavigation';
import { StatOverview } from './components/StatOverview';
import { SubStatNavigation } from './components/SubStatNavigation';
import { ItemDetails } from './components/ItemDetails';
import { Visualization } from './components/Visualization';
import MatchHeader from '../../match/MatchHeader';
import * as api from '../../../services/api';

const LOADING_DELAY = 500;
const MAX_RETRY_ATTEMPTS = 2;
const RETRY_DELAY = 1000;

const PlayerMatchPerformance = () => {
  const { competitionId, seasonId, matchId, playerName } = useParams();
  const location = useLocation();
  const navigate = useNavigate();

  const [playerInfo, setPlayerInfo] = useState(
    location.state?.playerInfo || null,
  );
  const [matchData, setMatchData] = useState(location.state?.matchData || null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState(null);
  const [retryCount, setRetryCount] = useState(0);

  const [selectedStat, setSelectedStat] = useState(STAT_TYPES.SUMMARY);
  const [selectedSubStat, setSelectedSubStat] = useState(
    getDefaultSubStat(STAT_TYPES.SUMMARY),
  );
  const [selectedTeam, setSelectedTeam] = useState('team1');
  const [selectedItem, setSelectedItem] = useState(null);

  // Initial loading delay
  useEffect(() => {
    const timer = setTimeout(() => {
      if (!location.state) {
        setIsLoading(false);
      }
    }, LOADING_DELAY);

    return () => clearTimeout(timer);
  }, [location.state]);

  // Load match data with retries
  useEffect(() => {
    const getMatch = async () => {
      if (!matchData && !isLoading) {
        try {
          const matches = await api.getCompetitionMatches(
            competitionId,
            seasonId,
          );
          const match = matches.find(m => m.match_id.toString() === matchId);

          if (!match) {
            throw new Error('Match not found');
          }

          setMatchData(match);
          setError(null);
        } catch (error) {
          console.error('Error fetching match:', error);

          if (retryCount < MAX_RETRY_ATTEMPTS) {
            setTimeout(() => {
              setRetryCount(prev => prev + 1);
            }, RETRY_DELAY);
          } else {
            setError('Unable to load match data. Please try again later.');
          }
        }
      }
    };
    getMatch();
  }, [matchData, competitionId, seasonId, matchId, isLoading, retryCount]);

  // Load player info with validation
  useEffect(() => {
    const getPlayer = async () => {
      if (!playerInfo && matchData) {
        try {
          const lineupsData = await api.getMatchLineups(matchId);

          if (!lineupsData || Object.keys(lineupsData).length === 0) {
            throw new Error('No lineup data available');
          }

          const allPlayers = [
            ...(Object.values(lineupsData)[0] || []),
            ...(Object.values(lineupsData)[1] || []),
          ];

          const decodedPlayerName = decodeURIComponent(playerName);
          const player = allPlayers.find(
            p =>
              p.player_name === decodedPlayerName ||
              p.nickname === decodedPlayerName,
          );

          if (!player) {
            throw new Error('Player not found in match lineup');
          }

          setPlayerInfo({
            playerId: player.player_id,
            playerName: player.player_name,
            nickname: player.nickname,
            jerseyNumber: player.jersey_number,
            team: Object.keys(lineupsData).find(team =>
              lineupsData[team].some(p => p.player_id === player.player_id),
            ),
            position: player.positions?.[0]?.position,
          });
          setError(null);
        } catch (error) {
          console.error('Error fetching player:', error);
          setError(
            error.message === 'Player not found in match lineup'
              ? 'Player not found in match lineup. Please check the player name and try again.'
              : 'Unable to load player data. Please try again later.',
          );
        }
      }
    };
    getPlayer();
  }, [playerInfo, matchData, matchId, playerName]);

  const {
    data,
    loading: statsLoading,
    error: statsError,
  } = useStatData(
    matchData && playerInfo ? matchId : null,
    playerInfo?.playerName || null,
    selectedStat,
  );

  const handleStatChange = category => {
    setSelectedStat(category.id);
    setSelectedSubStat(getDefaultSubStat(category.id));
    setSelectedItem(null);
  };

  const handleSubStatChange = subStatId => {
    setSelectedSubStat(subStatId);
    setSelectedItem(null);
  };

  const handleItemClick = item => {
    setSelectedItem(prev => (prev === item ? null : item));
  };

  const handleRetry = () => {
    setError(null);
    setRetryCount(0);
    setIsLoading(true);
    setTimeout(() => setIsLoading(false), LOADING_DELAY);
  };

  // Error UI
  if (error) {
    return (
      <div className='flex h-screen flex-col items-center justify-center bg-gray-100'>
        <div className='rounded-lg bg-white p-8 shadow-lg'>
          <h2 className='mb-4 text-xl font-bold text-red-600'>Error</h2>
          <p className='mb-6 text-gray-700'>{error}</p>
          <div className='flex gap-4'>
            <button
              onClick={handleRetry}
              className='rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600'
            >
              Try Again
            </button>
            <button
              onClick={() => navigate(-1)}
              className='rounded bg-gray-500 px-4 py-2 text-white hover:bg-gray-600'
            >
              Go Back
            </button>
          </div>
        </div>
      </div>
    );
  }

  // Loading UI
  if (isLoading || !matchData || !playerInfo) {
    return (
      <div className='flex h-screen flex-col items-center justify-center bg-gray-100'>
        <div className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent' />
        <p className='mt-4 text-gray-600'>Loading match data...</p>
      </div>
    );
  }

  return (
    <div className='min-h-screen bg-gray-100'>
      <div className='container mx-auto px-4 py-8'>
        <div className='mb-6'>
          <MatchHeader matchData={matchData} />
        </div>

        <div className='grid grid-cols-12 gap-4'>
          <div className='col-span-12 grid grid-cols-12 gap-4'>
            <PlayerProfile playerInfo={playerInfo} />
            <StatNavigation
              selectedStat={selectedStat}
              onStatChange={handleStatChange}
            />
          </div>

          <div className='col-span-12 lg:col-span-3'>
            <StatOverview selectedStat={selectedStat} data={data} />
          </div>

          <div className='col-span-12 lg:col-span-9'>
            <div className='rounded-lg bg-white shadow-lg'>
              <div className='px-6 pt-4'>
                <SubStatNavigation
                  selectedStat={selectedStat}
                  selectedSubStat={selectedSubStat}
                  onSubStatChange={handleSubStatChange}
                />
              </div>

              <div className='px-6 pb-6'>
                {statsLoading ? (
                  <div className='flex h-64 items-center justify-center'>
                    <div className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent' />
                  </div>
                ) : statsError ? (
                  <div className='flex h-64 items-center justify-center'>
                    <div className='text-center'>
                      <p className='mb-4 text-red-500'>{statsError}</p>
                      <button
                        onClick={handleRetry}
                        className='rounded bg-blue-500 px-4 py-2 text-white hover:bg-blue-600'
                      >
                        Retry
                      </button>
                    </div>
                  </div>
                ) : (
                  <>
                    <Visualization
                      selectedStat={selectedStat}
                      selectedSubStat={selectedSubStat}
                      data={data}
                      selectedItem={selectedItem}
                      onItemClick={handleItemClick}
                    />

                    <div className='mt-4 rounded-lg bg-gray-50 p-4'>
                      <ItemDetails
                        selectedStat={selectedStat}
                        selectedItem={selectedItem}
                      />
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>

        <div className='mt-4 flex justify-center'>
          <button
            className='rounded-full bg-gray-800 px-6 py-2 text-white shadow-lg hover:bg-gray-700'
            onClick={() =>
              setSelectedTeam(prev => (prev === 'team1' ? 'team2' : 'team1'))
            }
          >
            Switch to {selectedTeam === 'team1' ? 'Team 2' : 'Team 1'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default PlayerMatchPerformance;

================
File: frontend/src/services/api.js
================
import axios from 'axios';

const API_URL = 'http://127.0.0.1:8000/api/';

// Configure axios instance
const apiClient = axios.create({
  baseURL: API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add logging
apiClient.interceptors.request.use(request => {
  console.log('Making request to:', request.url);
  return request;
});

apiClient.interceptors.response.use(
  response => response,
  error => {
    console.error('API Error:', error?.response?.data || error.message);
    throw error;
  },
);

// =====================================
// Competition & Season Related Endpoints
// =====================================

export const getCompetitions = async () => {
  try {
    const response = await apiClient.get('competitions/');
    return response.data;
  } catch (error) {
    console.error('Failed to fetch competitions:', error);
    throw new Error('Failed to load competitions');
  }
};

export const getSeasons = async competitionId => {
  try {
    const response = await apiClient.get(`seasons/${competitionId}/`);
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch seasons for competition ${competitionId}:`,
      error,
    );
    throw new Error('Failed to load seasons');
  }
};

export const getCompetitionInfo = async (competitionId, seasonId) => {
  try {
    const response = await apiClient.get(
      `competition-info/${competitionId}/${seasonId}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch competition info for competition ${competitionId}, season ${seasonId}:`,
      error,
    );
    throw new Error('Failed to load competition information');
  }
};

export const getCompetitionMatches = async (competitionId, seasonId) => {
  try {
    const response = await apiClient.get(
      `matches/${competitionId}/${seasonId}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch matches for competition ${competitionId}, season ${seasonId}:`,
      error,
    );
    throw new Error('Failed to load matches');
  }
};

// =====================================
// Match Related Endpoints
// =====================================

export const getMatchInfo = async matchId => {
  try {
    const response = await apiClient.get(`match-info/${matchId}/`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch match info for match ${matchId}:`, error);
    throw new Error('Failed to load match information');
  }
};

export const getMatchLineups = async matchId => {
  try {
    const response = await apiClient.get(`match-lineups/${matchId}/`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch lineups for match ${matchId}:`, error);
    throw new Error('Failed to load match lineups');
  }
};

// =====================================
// Player Match Performance Endpoints
// =====================================

export const getPlayerMatchTouches = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-touches/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch touch data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player touch data');
  }
};

export const getPlayerMatchPassing = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-passing/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch passing data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player passing data');
  }
};

export const getPlayerMatchShooting = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-shooting/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch shooting data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player shooting data');
  }
};

export const getPlayerMatchDefending = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-def/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch defending data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player defending data');
  }
};

export const getPlayerMatchPossession = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-poss/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch possession data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player possession data');
  }
};

export const getGoalkeeperMatchStats = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-gk/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch goalkeeper data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load goalkeeper data');
  }
};

================
File: frontend/src/App.js
================
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import Home from './components/homepage/Home';
import CompetitionOverview from './components/competition/CompetitionOverview';
import BaseLayout from './components/common/BaseLayout';
import MatchDetails from './components/match/MatchDetails';
import PlayerMatchPerformance from './components/player/PlayerMatchPerformance/PlayerMatchPerformance';
import './index.css';

function App() {
  return (
    <Router>
      <BaseLayout>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route
            path='/league/:competitionId/:seasonId'
            element={<CompetitionOverview />}
          />
          {/* Updated match route to include competition and season IDs */}
          <Route
            path='/match/:competitionId/:seasonId/:matchId'
            element={<MatchDetails />}
          />
          {/* Updated player performance route */}
          <Route
            path='/player-performance/:competitionId/:seasonId/:matchId/:playerName'
            element={<PlayerMatchPerformance />}
          />
        </Routes>
      </BaseLayout>
    </Router>
  );
}

export default App;

================
File: frontend/src/App.test.js
================
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

================
File: frontend/src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-gray-900;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: frontend/src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

================
File: frontend/src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: frontend/src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: frontend/src/setupTests.js
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

================
File: frontend/.gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

================
File: frontend/.prettierrc
================
{
  "arrowParens": "avoid",
  "bracketSpacing": true,
  "htmlWhitespaceSensitivity": "css",
  "jsxSingleQuote": true,
  "printWidth": 80,
  "proseWrap": "always",
  "endOfLine": "lf",
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "quoteProps": "as-needed",
  "useTabs": false,
  "plugins": ["prettier-plugin-tailwindcss"]
}

================
File: frontend/package.json
================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "bootstrap": "^5.3.3",
    "date-fns": "^2.30.0",
    "react": "^18.3.1",
    "react-bootstrap": "^2.10.5",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.27.0",
    "react-scripts": "^5.0.1",
    "theme-change": "^2.5.0",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts --openssl-legacy-provider start",
    "build": "react-scripts --openssl-legacy-provider build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "daisyui": "^4.12.14",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.8",
    "tailwindcss": "^3.4.14"
  }
}

================
File: frontend/README.md
================
# Getting Started with Create React App

This project was bootstrapped with
[Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about
[running tests](https://facebook.github.io/create-react-app/docs/running-tests)
for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the
best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about
[deployment](https://facebook.github.io/create-react-app/docs/deployment) for
more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can
`eject` at any time. This command will remove the single build dependency from
your project.

Instead, it will copy all the configuration files and the transitive
dependencies (webpack, Babel, ESLint, etc) right into your project so you have
full control over them. All of the commands except `eject` will still work, but
they will point to the copied scripts so you can tweak them. At this point
you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for
small and middle deployments, and you shouldn't feel obligated to use this
feature. However we understand that this tool wouldn't be useful if you couldn't
customize it when you are ready for it.

## Learn More

You can learn more in the
[Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here:
[https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here:
[https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here:
[https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here:
[https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here:
[https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here:
[https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

================
File: frontend/repomix-output.txt
================
This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-23T01:31:11.683Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
public/
  index.html
  manifest.json
  robots.txt
src/
  components/
    common/
      BaseLayout.js
      ErrorMessage1.js
      index.js
      LoadingSpinner1.js
      Modal.js
      Navbar.js
    competition/
      CompetitionOverview.js
    homepage/
      Home.js
    match/
      MatchDetails.js
      MatchHeader.js
      MatchLineups.js
      TeamLineup.js
      TeamLineupTable.js
    pitch/
      BasePitch.js
      constants.js
      GoalPost.js
      HalfVerticalPitch.js
      HeatSoccerPitch.js
      index.js
      SoccerPitch.js
      VerticalSoccerPitch.js
    player/
      features/
        defending/
          DefendingItemDetails.js
        passing/
          PassingItemDetails.js
        shooting/
          ShootingItemDetails.js
        summary/
          SummaryItemDetails.js
      PlayerMatchPerformance/
        components/
          statoverview/
            ShootingStatsOverview.js
            StatCard.js
            SummaryStatsOverview.js
          ItemDetails.js
          PlayerProfile.js
          StatNavigation.js
          StatOverview.js
          SubStatNavigation.js
          Visualization.js
        config/
          statConfig.js
          statTypes.js
        hooks/
          useStatData.js
        visualizations/
          index.js
          PlayerMatchShots.js
          PlayerMatchTouches.js
        PlayerMatchPerformance.js
  services/
    api.js
  App.js
  App.test.js
  index.css
  index.js
  logo.svg
  reportWebVitals.js
  setupTests.js
.gitignore
.prettierrc
package.json
README.md
tailwind.config.js

================================================================
Repository Files
================================================================

================
File: public/index.html
================
<!doctype html>
<html lang="en" data-theme="dark">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Web site created using create-react-app"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: src/components/common/BaseLayout.js
================
// src/components/common/BaseLayout.js
import React from 'react';
import Navbar from './Navbar';

const BaseLayout = ({ children, className = '' }) => {
  return (
    <div className='min-h-screen bg-gray-100'>
      <Navbar />
      <main
        className={`container mx-auto min-h-[calc(100vh-4rem)] px-4 py-6 sm:px-6 lg:px-8 ${className}`}
      >
        {children}
      </main>
      <footer className='mt-auto border-t border-gray-200 bg-white py-4 dark:border-gray-800 dark:bg-gray-800'>
        <div className='container mx-auto px-4 text-center text-sm text-gray-600 dark:text-gray-400'>
          © {new Date().getFullYear()} Statsball. All rights reserved.
        </div>
      </footer>
    </div>
  );
};

export default BaseLayout;

================
File: src/components/common/ErrorMessage1.js
================
// ErrorMessage.js
import React from 'react';

const ErrorMessage = ({ message }) => {
  if (!message) return null;

  return (
    <div
      className='mb-6 rounded-lg border border-red-400 bg-red-100 px-4 py-3 text-center text-red-700'
      role='alert'
    >
      {message}
    </div>
  );
};

export default ErrorMessage;

================
File: src/components/common/index.js
================
// src/components/common/index.js
import React from 'react';
import { AlertCircle, Loader2 } from 'lucide-react';

export const ErrorMessage = ({
  message,
  variant = 'error',
  action,
  className = '',
}) => {
  const styles = {
    error: 'bg-red-50 text-red-700 border-red-200',
    warning: 'bg-yellow-50 text-yellow-700 border-yellow-200',
    info: 'bg-blue-50 text-blue-700 border-blue-200',
  };

  return (
    <div className={`rounded-lg border p-4 ${styles[variant]} ${className}`}>
      <div className='flex items-center gap-3'>
        <AlertCircle className='h-5 w-5' />
        <div className='flex-1'>{message}</div>
        {action && (
          <button
            onClick={action.onClick}
            className='rounded bg-white px-3 py-1 text-sm font-medium shadow-sm hover:bg-gray-50'
          >
            {action.label}
          </button>
        )}
      </div>
    </div>
  );
};

export const LoadingSpinner = ({
  fullScreen = false,
  message = 'Loading...',
  className = '',
}) => {
  const containerStyles = fullScreen
    ? 'fixed inset-0 bg-white/80 backdrop-blur-sm'
    : 'w-full';

  return (
    <div
      className={`flex items-center justify-center p-8 ${containerStyles} ${className}`}
    >
      <div className='flex flex-col items-center gap-2'>
        <Loader2 className='h-8 w-8 animate-spin text-blue-500' />
        <p className='text-sm text-gray-500'>{message}</p>
      </div>
    </div>
  );
};

export const EmptyState = ({
  title,
  message,
  icon: Icon,
  action,
  className = '',
}) => (
  <div
    className={`flex flex-col items-center justify-center rounded-lg border border-dashed border-gray-300 bg-white p-8 ${className}`}
  >
    {Icon && <Icon className='mb-3 h-12 w-12 text-gray-400' />}
    <h3 className='mb-1 text-lg font-medium'>{title}</h3>
    <p className='mb-4 text-sm text-gray-500'>{message}</p>
    {action && (
      <button
        onClick={action.onClick}
        className='rounded-full bg-blue-500 px-4 py-2 text-sm font-medium text-white hover:bg-blue-600'
      >
        {action.label}
      </button>
    )}
  </div>
);

================
File: src/components/common/LoadingSpinner1.js
================
import React from 'react';

const LoadingSpinner = ({ fullScreen = false }) => {
  const baseClasses = 'flex items-center justify-center';
  const containerClasses = fullScreen ? `${baseClasses} h-screen` : baseClasses;

  return (
    <div className={containerClasses} role='status'>
      <div
        className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent'
        aria-label='Loading'
      />
      <span className='sr-only'>Loading...</span>
    </div>
  );
};

export default LoadingSpinner;

================
File: src/components/common/Modal.js
================
// Modal.js
import React, { useRef, useEffect } from 'react';

const Modal = ({ isOpen, onClose, title, children, footer }) => {
  const modalRef = useRef(null);

  useEffect(() => {
    const handleClickOutside = event => {
      if (modalRef.current && !modalRef.current.contains(event.target)) {
        onClose();
      }
    };

    const handleEscapeKey = event => {
      if (event.key === 'Escape') {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      document.addEventListener('keydown', handleEscapeKey);
      // Prevent scroll when modal is open
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.removeEventListener('keydown', handleEscapeKey);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  if (!isOpen) return null;

  return (
    <div
      className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'
      role='dialog'
      aria-modal='true'
      aria-labelledby='modal-title'
    >
      <div
        ref={modalRef}
        className='w-full max-w-lg overflow-hidden rounded-lg bg-white shadow-lg'
      >
        <div className='flex items-center justify-between border-b p-4'>
          <h2 id='modal-title' className='text-xl font-semibold'>
            {title}
          </h2>
          <button
            className='rounded-full p-1 text-gray-500 hover:bg-gray-100 hover:text-gray-700'
            onClick={onClose}
            aria-label='Close modal'
          >
            ×
          </button>
        </div>
        <div className='p-6'>{children}</div>
        {footer && <div className='border-t p-4 text-right'>{footer}</div>}
      </div>
    </div>
  );
};

export default Modal;

================
File: src/components/common/Navbar.js
================
import React, { useState } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { Home, Menu, Trophy, Activity, X } from 'lucide-react';

const navigation = [
  { name: 'Home', href: '/', icon: Home },
  { name: 'Competitions', href: '/competitions', icon: Trophy },
  { name: 'Match Center', href: '/matches', icon: Activity },
];

const Navbar = () => {
  const [isOpen, setIsOpen] = useState(false);
  const location = useLocation();

  const isActive = path => location.pathname === path;

  return (
    <header>
      <nav className='bg-blue-600 shadow-lg' aria-label='Main navigation'>
        <div className='mx-auto max-w-7xl px-4 sm:px-6 lg:px-8'>
          <div className='flex h-16 justify-between'>
            <div className='flex'>
              <div className='flex flex-shrink-0 items-center'>
                <Link to='/' className='flex items-center space-x-2'>
                  <img
                    src='/api/placeholder/32/32'
                    alt='Logo'
                    className='h-8 w-8 rounded-full'
                  />
                  <span className='hidden text-xl font-bold text-white sm:block'>
                    Statsball
                  </span>
                </Link>
              </div>

              <div className='hidden sm:ml-6 sm:flex sm:space-x-8'>
                {navigation.map(item => (
                  <Link
                    key={item.name}
                    to={item.href}
                    className={`inline-flex items-center space-x-2 border-b-2 px-1 pt-1 text-sm font-medium ${
                      isActive(item.href)
                        ? 'border-white text-white'
                        : 'border-transparent text-blue-100 hover:border-blue-200 hover:text-white'
                    }`}
                  >
                    <item.icon className='h-4 w-4' />
                    <span>{item.name}</span>
                  </Link>
                ))}
              </div>
            </div>

            <div className='flex items-center sm:hidden'>
              <button
                onClick={() => setIsOpen(!isOpen)}
                className='inline-flex items-center justify-center rounded-md p-2 text-blue-100 hover:bg-blue-700 hover:text-white'
              >
                {isOpen ? (
                  <X className='h-6 w-6' aria-hidden='true' />
                ) : (
                  <Menu className='h-6 w-6' aria-hidden='true' />
                )}
              </button>
            </div>
          </div>
        </div>

        {isOpen && (
          <div className='sm:hidden'>
            <div className='space-y-1 pb-3 pt-2'>
              {navigation.map(item => (
                <Link
                  key={item.name}
                  to={item.href}
                  className={`flex items-center space-x-2 border-l-4 py-2 pl-3 pr-4 text-base font-medium ${
                    isActive(item.href)
                      ? 'border-white bg-blue-700 text-white'
                      : 'border-transparent text-blue-100 hover:border-blue-300 hover:bg-blue-700 hover:text-white'
                  }`}
                  onClick={() => setIsOpen(false)}
                >
                  <item.icon className='h-5 w-5' />
                  <span>{item.name}</span>
                </Link>
              ))}
            </div>
          </div>
        )}
      </nav>
    </header>
  );
};

export default Navbar;

================
File: src/components/competition/CompetitionOverview.js
================
import React, { useState, useEffect, useCallback } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage, EmptyState } from '../common';
import { Calendar } from 'lucide-react';
import { format } from 'date-fns';
import * as api from '../../services/api';

const CompetitionOverview = () => {
  const { competitionId, seasonId } = useParams();
  const [allMatches, setAllMatches] = useState([]);
  const [displayedMatches, setDisplayedMatches] = useState([]);
  const [teams, setTeams] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [leagueInfo, setLeagueInfo] = useState(null);
  const navigate = useNavigate();

  const [showAllMatches, setShowAllMatches] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [matchesPerPage] = useState(10);

  const loadData = useCallback(async () => {
    try {
      setLoading(true);
      setError(null);

      const leagueData = await api.getCompetitionInfo(competitionId, seasonId);
      setLeagueInfo(leagueData);

      await new Promise(resolve => setTimeout(resolve, 500));

      const matchesData = await api.getCompetitionMatches(
        competitionId,
        seasonId,
      );
      const sortedMatches = matchesData
        .filter(match => match?.match_date)
        .sort((a, b) => new Date(b.match_date) - new Date(a.match_date));

      setAllMatches(sortedMatches);
      setDisplayedMatches(sortedMatches.slice(0, 5));

      const uniqueTeams = Array.from(
        new Set(
          matchesData
            .filter(match => match?.home_team && match?.away_team)
            .flatMap(match => [match.home_team, match.away_team]),
        ),
      ).sort();

      setTeams(uniqueTeams);
    } catch (err) {
      console.error('Error loading data:', err);
      setError('Failed to load data. Please try again later.');
    } finally {
      setLoading(false);
    }
  }, [competitionId, seasonId]);

  useEffect(() => {
    if (competitionId && seasonId) {
      const timer = setTimeout(loadData, 100);
      return () => clearTimeout(timer);
    }
  }, [competitionId, seasonId, loadData]);

  const indexOfLastMatch = currentPage * matchesPerPage;
  const indexOfFirstMatch = indexOfLastMatch - matchesPerPage;
  const totalPages = Math.ceil(allMatches.length / matchesPerPage);

  useEffect(() => {
    if (showAllMatches) {
      setDisplayedMatches(
        allMatches.slice(indexOfFirstMatch, indexOfLastMatch),
      );
    } else {
      setDisplayedMatches(allMatches.slice(0, 5));
    }
  }, [
    showAllMatches,
    currentPage,
    allMatches,
    indexOfFirstMatch,
    indexOfLastMatch,
  ]);

  const handlePageChange = pageNumber => {
    setCurrentPage(pageNumber);
  };

  const toggleMatchesView = () => {
    setShowAllMatches(!showAllMatches);
    setCurrentPage(1);
  };

  if (loading) {
    return <LoadingSpinner message='Loading competition data...' />;
  }

  if (error) {
    return (
      <ErrorMessage
        message={error}
        action={{
          label: 'Try Again',
          onClick: loadData,
        }}
      />
    );
  }

  if (!allMatches.length) {
    return (
      <EmptyState
        icon={Calendar}
        title='No Matches Found'
        message='There are no matches available for this competition yet.'
      />
    );
  }

  return (
    <div className='container mx-auto py-6'>
      <div className='mb-6 rounded bg-blue-600 p-4 text-white'>
        <h2 className='text-2xl font-bold'>
          {leagueInfo?.competition || 'League'}
        </h2>
        <p className='opacity-80'>{leagueInfo?.season || 'Season'}</p>
      </div>

      <div className='mb-6 rounded bg-white shadow'>
        <div className='flex items-center justify-between rounded-t bg-gray-100 p-4'>
          <h4 className='text-xl font-semibold'>
            {showAllMatches ? 'All Matches' : 'Recent Matches'}
          </h4>
          <button
            className='rounded border border-blue-500 px-3 py-1 text-blue-500 hover:bg-blue-500 hover:text-white'
            onClick={toggleMatchesView}
          >
            {showAllMatches ? 'Show Recent Matches' : 'View All Matches'}
          </button>
        </div>
        <div className='overflow-x-auto'>
          <table className='min-w-full divide-y divide-gray-200'>
            <thead className='bg-gray-50'>
              <tr>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Date
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Home Team
                </th>
                <th className='px-6 py-3 text-center text-xs font-medium uppercase text-gray-500'>
                  Score
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Away Team
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Week
                </th>
                <th className='px-6 py-3 text-left text-xs font-medium uppercase text-gray-500'>
                  Status
                </th>
              </tr>
            </thead>
            <tbody className='divide-y divide-gray-200 bg-white'>
              {displayedMatches.map(match => (
                <tr
                  key={match.match_id}
                  className='cursor-pointer hover:bg-gray-100'
                  onClick={() =>
                    navigate(`/match/${match.match_id}`, {
                      state: { matchData: match },
                    })
                  }
                >
                  <td className='px-6 py-4'>
                    {format(new Date(match.match_date), 'MMM d, yyyy')}
                    <br />
                    <span className='text-xs text-gray-500'>
                      {match.kick_off}
                    </span>
                  </td>
                  <td className='px-6 py-4'>{match.home_team}</td>
                  <td className='px-6 py-4 text-center font-semibold'>
                    {match.home_score} - {match.away_score}
                  </td>
                  <td className='px-6 py-4'>{match.away_team}</td>
                  <td className='px-6 py-4'>
                    Week {match.match_week || 'N/A'}
                  </td>
                  <td className='px-6 py-4'>
                    <span
                      className={`rounded px-2 py-1 ${
                        match.match_status === 'available'
                          ? 'bg-green-100 text-green-800'
                          : 'bg-gray-100 text-gray-800'
                      }`}
                    >
                      {match.match_status}
                    </span>
                  </td>
                </tr>
              ))}
            </tbody>
          </table>
        </div>

        {showAllMatches && totalPages > 1 && (
          <div className='flex justify-center p-4'>
            <div className='flex gap-2'>
              {[...Array(totalPages)].map((_, index) => (
                <button
                  key={index + 1}
                  onClick={() => handlePageChange(index + 1)}
                  className={`rounded px-3 py-1 ${
                    currentPage === index + 1
                      ? 'bg-blue-500 text-white'
                      : 'bg-gray-200 hover:bg-gray-300'
                  }`}
                >
                  {index + 1}
                </button>
              ))}
            </div>
          </div>
        )}
      </div>

      <div className='rounded bg-white shadow'>
        <div className='rounded-t bg-gray-100 p-4'>
          <h4 className='text-xl font-semibold'>Teams</h4>
        </div>
        <div className='grid gap-4 p-4 sm:grid-cols-2 md:grid-cols-4 lg:grid-cols-5'>
          {teams.map(team => (
            <div
              key={team}
              className='cursor-pointer rounded-lg bg-white p-4 text-center shadow hover:bg-gray-100'
              onClick={() => console.log('Team clicked:', team)}
            >
              <img
                src='/api/placeholder/50/50'
                alt={`${team} logo`}
                className='mx-auto mb-2 h-12 w-12'
              />
              <h6 className='text-sm font-medium'>{team}</h6>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default CompetitionOverview;

================
File: src/components/homepage/Home.js
================
import React, { useState, useEffect, useRef } from 'react';
import { useNavigate } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage } from '../common';
import * as api from '../../services/api';

const Home = () => {
  const [leagues, setLeagues] = useState([]);
  const [selectedLeague, setSelectedLeague] = useState(null);
  const [seasons, setSeasons] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const [showModal, setShowModal] = useState(false);
  const modalRef = useRef(null);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchLeagues = async () => {
      try {
        const competitionsData = await api.getCompetitions();
        const uniqueLeagues = Object.values(
          competitionsData.reduce((acc, comp) => {
            if (
              !acc[comp.competition_id] ||
              new Date(comp.season_name) >
                new Date(acc[comp.competition_id].season_name)
            ) {
              acc[comp.competition_id] = {
                id: comp.competition_id,
                name: comp.competition_name,
                country: comp.country_name,
                gender: comp.competition_gender,
                international: comp.competition_international,
                logoUrl: `/api/placeholder/100/100`,
              };
            }
            return acc;
          }, {}),
        ).sort((a, b) => a.name.localeCompare(b.name));

        setLeagues(uniqueLeagues);
        setError(null);
      } catch (err) {
        setError('Failed to load leagues');
      } finally {
        setLoading(false);
      }
    };

    fetchLeagues();
  }, []);

  useEffect(() => {
    const handleClickOutside = event => {
      if (modalRef.current && !modalRef.current.contains(event.target)) {
        setShowModal(false);
      }
    };

    if (showModal) {
      document.addEventListener('mousedown', handleClickOutside);
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
    };
  }, [showModal]);

  const handleLeagueClick = async league => {
    try {
      const seasonsData = await api.getSeasons(league.id);
      const sortedSeasons = seasonsData.sort(
        (a, b) => new Date(b.season_name) - new Date(a.season_name),
      );
      setSeasons(sortedSeasons);
      setSelectedLeague(league);
      setShowModal(true);
      setError(null);
    } catch (err) {
      setError('Failed to load seasons for this league');
    }
  };

  if (loading) {
    return <LoadingSpinner message='Loading leagues...' />;
  }

  if (error) {
    return (
      <ErrorMessage
        message={error}
        action={{
          label: 'Try Again',
          onClick: () => window.location.reload(),
        }}
      />
    );
  }

  return (
    <div className='container mx-auto bg-gray-100 py-8'>
      <h1 className='mb-6 text-center text-3xl font-semibold'>
        Select a League
      </h1>

      {error && (
        <div className='mb-6 rounded border border-red-400 bg-red-100 px-4 py-3 text-center text-red-700'>
          {error}
        </div>
      )}

      <div className='grid gap-6 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4'>
        {leagues.map(league => (
          <div
            key={league.id}
            className='transform cursor-pointer rounded-lg bg-white p-6 text-center shadow-lg transition-transform hover:scale-105'
            onClick={() => handleLeagueClick(league)}
          >
            <img
              src={league.logoUrl}
              alt={`${league.name} logo`}
              className='mx-auto mb-4 h-24 w-24 object-contain'
            />
            <h3 className='text-xl font-semibold'>{league.name}</h3>
            <p className='text-gray-500'>
              {league.country} {league.international && '• International'}
            </p>
          </div>
        ))}
      </div>

      {showModal && (
        <div className='fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-50'>
          <div
            ref={modalRef}
            className='w-full max-w-lg overflow-hidden rounded-lg bg-white shadow-lg'
          >
            <div className='flex items-center justify-between border-b p-4'>
              <h2 className='text-xl font-semibold'>
                {selectedLeague?.name} - Select Season
              </h2>
              <button
                className='text-gray-500 hover:text-gray-700'
                onClick={() => setShowModal(false)}
              >
                &times;
              </button>
            </div>
            <div className='p-6'>
              <div className='grid gap-4 sm:grid-cols-2'>
                {seasons.map(season => (
                  <div
                    key={season.season_id}
                    className='cursor-pointer rounded-lg bg-gray-100 p-4 text-center hover:bg-gray-200'
                    onClick={() =>
                      navigate(
                        `/league/${selectedLeague.id}/${season.season_id}`,
                      )
                    }
                  >
                    <h3 className='text-lg'>{season.season_name}</h3>
                  </div>
                ))}
              </div>
            </div>
            <div className='border-t p-4 text-right'>
              <button
                className='rounded-lg bg-gray-200 px-4 py-2 hover:bg-gray-300'
                onClick={() => setShowModal(false)}
              >
                Close
              </button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
};

export default Home;

================
File: src/components/match/MatchDetails.js
================
import React, { useState, useEffect } from 'react';
import { useParams, useNavigate, useLocation } from 'react-router-dom';
import { LoadingSpinner, ErrorMessage } from '../common';
import MatchHeader from './MatchHeader';
import MatchLineups from './MatchLineups';
import * as api from '../../services/api';

const MatchDetails = () => {
  const { matchId } = useParams();
  const navigate = useNavigate();
  const location = useLocation();
  const [matchData, setMatchData] = useState(location.state?.matchData || null);
  const [lineups, setLineups] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        setLoading(true);

        // If we don't have match data from navigation state, fetch it
        let currentMatch = matchData;
        if (!currentMatch) {
          const matchesData = await api.getCompetitionMatches();
          currentMatch = matchesData.find(
            m => m.match_id.toString() === matchId,
          );
          if (!currentMatch) throw new Error('Match not found');
          setMatchData(currentMatch);
        }

        // Fetch lineups
        const lineupsData = await api.getMatchLineups(matchId);
        console.log('Fetched lineups:', lineupsData); // Debug log
        setLineups(lineupsData);
        setError(null);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError('Failed to load match data');
      } finally {
        setLoading(false);
      }
    };

    if (matchId) fetchData();
  }, [matchId, matchData]);

  const handlePlayerClick = player => {
    if (!player?.player_name) {
      console.error('Invalid player data:', player);
      return;
    }

    navigate(
      `/player-performance/${matchId}/${encodeURIComponent(player.player_name)}`,
      {
        state: {
          playerInfo: {
            playerId: player.player_id,
            playerName: player.player_name,
            nickname: player.nickname,
            jerseyNumber: player.jersey_number,
            team: player.team_name,
            position: player.positions?.[0]?.position,
          },
          matchData: matchData,
        },

      },
    );
  };

  if (loading) return <LoadingSpinner message='Loading match data...' />;
  if (error) return <ErrorMessage message={error} />;
  if (!matchData || !lineups) return null;

  return (
    <div className='container mx-auto px-4 py-4'>
      <MatchHeader matchData={matchData} />
      <MatchLineups
        lineups={lineups}
        matchData={matchData}
        onPlayerClick={handlePlayerClick}
      />
    </div>
  );
};

export default MatchDetails;

================
File: src/components/match/MatchHeader.js
================
import React from 'react';
import { format } from 'date-fns';
import { MapPin, User, Clock } from 'lucide-react';

const MatchHeader = ({ matchData }) => {
  if (!matchData) return null;

  const getStatusColor = status => {
    switch (status?.toLowerCase()) {
      case 'available':
        return 'bg-green-100 text-green-800';
      case 'scheduled':
        return 'bg-blue-100 text-blue-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  return (
    <div className='mb-6 overflow-hidden rounded-lg bg-white shadow'>
      {/* Competition Info */}
      <div className='border-b border-gray-200 bg-blue-600 p-4 text-white'>
        <h2 className='text-2xl font-bold'>{matchData.competition}</h2>
        <p className='text-sm opacity-80'>
          {matchData.season} - {matchData.competition_stage}
        </p>
      </div>

      {/* Match Status & Date */}
      <div className='border-b border-gray-200 bg-gray-50 p-4'>
        <div className='flex items-center justify-between'>
          <div className='flex items-center gap-2'>
            <Clock className='h-4 w-4 text-gray-500' />
            <span className='text-sm text-gray-600'>
              {format(new Date(matchData.match_date), 'MMMM d, yyyy')} -{' '}
              {matchData.kick_off?.slice(0, 5)}
            </span>
          </div>
          <span
            className={`rounded-full px-3 py-1 text-sm ${getStatusColor(matchData.match_status)}`}
          >
            {matchData.match_status}
          </span>
        </div>
      </div>

      {/* Teams & Score */}
      <div className='grid grid-cols-7 items-center gap-4 p-6'>
        {/* Home Team */}
        <div className='col-span-3 text-right'>
          <h3 className='text-xl font-semibold'>{matchData.home_team}</h3>
          {matchData.home_managers && (
            <div className='mt-2 flex items-center justify-end gap-1 text-sm text-gray-600'>
              <User className='h-4 w-4' />
              {matchData.home_managers}
            </div>
          )}
        </div>

        {/* Score */}
        <div className='col-span-1 text-center'>
          <div className='text-2xl font-bold'>
            {typeof matchData.home_score === 'number' &&
            typeof matchData.away_score === 'number'
              ? `${matchData.home_score} - ${matchData.away_score}`
              : 'vs'}
          </div>
          {matchData.match_week && (
            <div className='mt-1 text-xs text-gray-500'>
              Week {matchData.match_week}
            </div>
          )}
        </div>

        {/* Away Team */}
        <div className='col-span-3 text-left'>
          <h3 className='text-xl font-semibold'>{matchData.away_team}</h3>
          {matchData.away_managers && (
            <div className='mt-2 flex items-center gap-1 text-sm text-gray-600'>
              <User className='h-4 w-4' />
              {matchData.away_managers}
            </div>
          )}
        </div>
      </div>

      {/* Additional Info */}
      {(matchData.stadium || matchData.referee) && (
        <div className='border-t border-gray-200 bg-gray-50 p-4'>
          <div className='flex flex-wrap items-center gap-6'>
            {matchData.stadium && (
              <div className='flex items-center gap-2 text-sm text-gray-600'>
                <MapPin className='h-4 w-4' />
                {matchData.stadium}
              </div>
            )}
            {matchData.referee && (
              <div className='flex items-center gap-2 text-sm text-gray-600'>
                <User className='h-4 w-4' />
                Referee: {matchData.referee}
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default MatchHeader;

================
File: src/components/match/MatchLineups.js
================
import React, { useState } from 'react';
import TeamLineup from './TeamLineup';

const MatchLineups = ({ lineups, matchData, onPlayerClick }) => {
  const [showSubs, setShowSubs] = useState(true);

  // Debug logs
  console.log('Match Data:', matchData);
  console.log('Lineups Data:', lineups);

  // Ensure we have the required data
  if (!matchData?.home_team || !matchData?.away_team || !lineups) {
    return null;
  }

  const handleToggleSubs = () => {
    setShowSubs(!showSubs);
  };

  // Create lineup data for each team
  const homeTeam = {
    teamName: matchData.home_team,
    players: (lineups[matchData.home_team] || []).map(player => ({
      ...player,
      team_name: matchData.home_team,
    })),
  };

  const awayTeam = {
    teamName: matchData.away_team,
    players: (lineups[matchData.away_team] || []).map(player => ({
      ...player,
      team_name: matchData.away_team,
    })),
  };

  return (
    <div className='grid gap-6 md:grid-cols-2'>
      <TeamLineup
        teamName={homeTeam.teamName}
        players={homeTeam.players}
        onPlayerClick={onPlayerClick}
        showSubs={showSubs}
        onToggleSubs={handleToggleSubs}
        side='left'
      />
      <TeamLineup
        teamName={awayTeam.teamName}
        players={awayTeam.players}
        onPlayerClick={onPlayerClick}
        showSubs={showSubs}
        onToggleSubs={handleToggleSubs}
        side='right'
      />
    </div>
  );
};

export default MatchLineups;

================
File: src/components/match/TeamLineup.js
================
import React from 'react';
import { Users, ChevronDown, ChevronUp } from 'lucide-react';
import TeamLineupTable from './TeamLineupTable';

const TeamLineup = ({
  teamName,
  players,
  onPlayerClick,
  showSubs,
  onToggleSubs,
  side = 'left',
}) => {
  const getPlayerStatus = player => {
    if (!player.positions?.length) return 'Unknown';
    const startReason = player.positions[0].start_reason;
    if (startReason?.includes('Substitution - On')) return 'Substitute';
    if (startReason === 'Starting XI') return 'Starting XI';
    return startReason || 'Unknown';
  };

  const startingXI = players.filter(p => getPlayerStatus(p) === 'Starting XI');
  const substitutes = players.filter(
    p =>
      p.positions?.length > 0 &&
      p.positions[0].start_reason?.includes('Substitution - On'),
  );

  return (
    <div className='mb-6 overflow-hidden rounded-lg bg-white shadow'>
      <div className='border-b border-gray-200 bg-gray-50 px-4 py-3'>
        <div className='flex items-center justify-between'>
          <div className='flex items-center gap-2'>
            <Users className='h-5 w-5 text-gray-500' />
            <h5 className='m-0 font-semibold'>{teamName}</h5>
          </div>
        </div>
      </div>

      <div className='p-0'>
        <div className='border-b border-gray-100 bg-green-50/30 px-4 py-2'>
          <h6 className='m-0 text-sm font-semibold text-gray-600'>
            Starting XI ({startingXI.length})
          </h6>
        </div>

        <TeamLineupTable players={startingXI} onPlayerClick={onPlayerClick} />

        {substitutes.length > 0 && (
          <div className='border-t-2 border-blue-200'>
            <div
              className='flex cursor-pointer items-center justify-between bg-blue-50 px-4 py-3'
              onClick={onToggleSubs}
            >
              <h6 className='m-0 text-sm font-semibold text-gray-600'>
                Substitutes ({substitutes.length})
              </h6>
              {showSubs ? (
                <ChevronUp className='h-5 w-5 text-blue-500' />
              ) : (
                <ChevronDown className='h-5 w-5 text-blue-500' />
              )}
            </div>

            {showSubs && (
              <TeamLineupTable
                players={substitutes}
                onPlayerClick={onPlayerClick}
              />
            )}
          </div>
        )}
      </div>
    </div>
  );
};

export default TeamLineup;

================
File: src/components/match/TeamLineupTable.js
================
import React from 'react';

const TeamLineupTable = ({ players, onPlayerClick }) => (
  <table className='w-full'>
    <tbody>
      {players.map(player => (
        <tr
          key={player.player_id}
          onClick={() => onPlayerClick(player)}
          className='cursor-pointer border-b border-gray-50 hover:bg-gray-50'
        >
          <td className='px-4 py-3 text-sm'>{player.jersey_number || '-'}</td>
          <td className='px-4 py-3'>
            <div>
              <div className='font-medium'>
                {player.nickname || player.player_name}
              </div>
              {player.nationality && (
                <div className='text-xs text-gray-500'>
                  {player.nationality}
                </div>
              )}
            </div>
          </td>
          <td className='px-4 py-3 text-sm'>
            {player.positions?.[0]?.position || '-'}
          </td>
        </tr>
      ))}
    </tbody>
  </table>
);

export default TeamLineupTable;

================
File: src/components/pitch/BasePitch.js
================
import React from 'react';
import { ORIENTATIONS } from './constants';

const getViewBox = orientation => {
  switch (orientation) {
    case ORIENTATIONS.VERTICAL:
      return '0 -2 80 124';
    case ORIENTATIONS.HALF_VERTICAL:
      return '-2 -2 84 64';
    case ORIENTATIONS.HORIZONTAL:
    default:
      return '-2 -2 124 84';
  }
};

const getAspectRatio = orientation => {
  switch (orientation) {
    case ORIENTATIONS.VERTICAL:
      return 'aspect-[2/3]';
    case ORIENTATIONS.HALF_VERTICAL:
      return 'aspect-[4/3]';
    case ORIENTATIONS.HORIZONTAL:
    default:
      return 'aspect-[3/2]';
  }
};

const BasePitch = ({
  children,
  onPitchClick,
  orientation = ORIENTATIONS.HORIZONTAL,
  background = 'bg-white',
  stroke = '#CBD5E1',
  fill = 'none',
  maxWidth = 'max-w-3xl',
}) => {
  const isVertical = orientation === ORIENTATIONS.VERTICAL;
  const isHalfVertical = orientation === ORIENTATIONS.HALF_VERTICAL;

  const renderPitchElements = () => {
    if (isHalfVertical) {
      return (
        <>
          <rect x='0' y='0' width='80' height='60' />
          <line x1='0' y1='60' x2='80' y2='60' />
          <path d='M 30,60 A 10,10 0 0 1 50,60' />
          <circle cx='40' cy='60' r='0.3' fill={stroke} />
          <rect x='18' y='0' width='44' height='18' />
          <rect x='30' y='0' width='20' height='6' />
          <rect
            x='36'
            y='-0.5'
            width='8'
            height='0.5'
            style={{ fill: stroke }}
          />
          <path d='M 32.5,18 A 10,10 0 0,0 48,18' />
          <circle cx='40' cy='12' r='0.3' fill={stroke} />
          <path d='M 0,1 A 3,3 0 0,0 1,0' />
          <path d='M 79,0 A 3,3 0 0,0 80,1' />
        </>
      );
    }

    const standardElements = (
      <>
        <rect
          x='0'
          y='0'
          width={isVertical ? '80' : '120'}
          height={isVertical ? '120' : '80'}
          style={{ fill }}
        />
        {isVertical ? (
          <line x1='0' y1='60' x2='80' y2='60' />
        ) : (
          <line x1='60' y1='0' x2='60' y2='80' />
        )}
        <circle
          cx={isVertical ? '40' : '60'}
          cy={isVertical ? '60' : '40'}
          r='10'
        />
        <circle
          cx={isVertical ? '40' : '60'}
          cy={isVertical ? '60' : '40'}
          r='0.3'
          fill={stroke}
        />
        {/* Penalty areas and other elements */}
        {isVertical ? (
          <>
            {/* Vertical orientation penalty areas */}
            <rect x='18' y='0' width='44' height='18' />
            <rect x='30' y='0' width='20' height='6' />
            <rect x='18' y='102' width='44' height='18' />
            <rect x='30' y='114' width='20' height='6' />
            {/* Goals */}
            <rect
              x='36'
              y='-0.5'
              width='8'
              height='0.5'
              style={{ fill: stroke }}
            />
            <rect
              x='36'
              y='120'
              width='8'
              height='0.5'
              style={{ fill: stroke }}
            />
            {/* Penalty arcs */}
            <path d='M 32.5,18 A 10,10 0 0,0 48,18' />
            <path d='M 32.5,102 A 10,10 0 0,1 48,102' />
          </>
        ) : (
          <>
            {/* Horizontal orientation penalty areas */}
            <rect x='0' y='18' width='18' height='44' />
            <rect x='0' y='30' width='6' height='20' />
            <rect x='102' y='18' width='18' height='44' />
            <rect x='114' y='30' width='6' height='20' />
            {/* Goals */}
            <rect
              x='-0.5'
              y='36'
              width='0.5'
              height='8'
              style={{ fill: stroke }}
            />
            <rect
              x='120'
              y='36'
              width='0.5'
              height='8'
              style={{ fill: stroke }}
            />
            {/* Penalty arcs */}
            <path d='M 18,32.5 A 10,10 0 0,1 18,48' />
            <path d='M 102,32.5 A 10,10 0 0,0 102,48' />
          </>
        )}
      </>
    );

    return standardElements;
  };

  return (
    <div
      className={`relative ${getAspectRatio(orientation)} w-full ${maxWidth} border-2 border-slate-400 ${background}`}
    >
      <svg
        viewBox={getViewBox(orientation)}
        className='absolute inset-0 h-full w-full'
        style={{
          strokeWidth: '0.2',
          stroke,
          fill: 'none',
        }}
        onClick={onPitchClick}
      >
        {renderPitchElements()}
        {children}
      </svg>
    </div>
  );
};

export default BasePitch;

================
File: src/components/pitch/constants.js
================
export const ORIENTATIONS = {
  HORIZONTAL: 'horizontal',
  VERTICAL: 'vertical',
  HALF_VERTICAL: 'half-vertical',
};

export const COLOR_SCHEMES = {
  LIGHT: {
    background: 'bg-white',
    stroke: '#CBD5E1',
    fill: 'none',
  },
  DARK: {
    background: 'bg-black',
    stroke: '#CBD5E1',
    fill: '#121212',
  },
};

================
File: src/components/pitch/GoalPost.js
================
import React from 'react';

export const GoalPostVisualization = ({ children }) => {
  const goalStroke = 'grey'; // color of posts
  const lineStroke = 'black'; // ground color
  const goalStrokeWidth = 0.4; // Stroke width of the goal frame
  const lineStrokeWidth = 0.1; // Stroke width of the ground line
  const lineBottom = 2.67 + 2.67 + goalStrokeWidth / 2; // Calculate Y post of ground line (affected by width of the goal)

  //     viewBox="30 -1 20 7" ONLY SHOWING THE SIX YARD BOX CAN LATER MAP BACK TO OG COORD TO FIND MAX HEIGHT SHOWING
  //         |<---20--->|
  // 30      36    44      50
  // |       |     |       |
  // |       ╭─────╮       |
  // |       │     │       |
  // |       │     │       |
  // |   ────┴─────┴────   |
  //     32         48

  // Y coordinate
  //    -1 ─ ─ ─ Above origin (top of view)
  //     0 ──── Origin
  //     1 ────
  //     2 ────
  //     3 ──── ╭─────╮  Goal posts start at Y=2.67
  //     4 ──── │     │
  //     5 ──── │     │  Goal posts end at Y=5.34
  //     6 ──── ┴─────┴  Ground line at Y=5.74
  //     |
  //    7 units
  //    total
  //    height

  return (
    <div className='h-[300px] w-full'>
      <svg
        viewBox='30 -1 20 7'
        className='h-full w-full'
        preserveAspectRatio='xMidYMid meet'
      >
        {/* Goal frame as a path - only top and sides */}
        <path
          d='M36 5.34 L36 2.67 L44 2.67 L44 5.34'
          fill='none'
          stroke={goalStroke}
          strokeWidth={goalStrokeWidth}
          strokeLinejoin='round'
          strokeLinecap='square'
        />

        {/* Ground line */}
        <line
          x1='30'
          y1={lineBottom}
          x2='50'
          y2={lineBottom}
          stroke={lineStroke}
          strokeWidth={lineStrokeWidth}
          strokeLinecap='square'
        />

        {children}
      </svg>
    </div>
  );
};

export default GoalPostVisualization;

================
File: src/components/pitch/HalfVerticalPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const HalfVerticalPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HALF_VERTICAL}
    {...COLOR_SCHEMES.LIGHT}
    maxWidth='max-w-xl'
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default HalfVerticalPitch;

================
File: src/components/pitch/HeatSoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const HeatSoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HORIZONTAL}
    {...COLOR_SCHEMES.DARK}
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default HeatSoccerPitch;

================
File: src/components/pitch/index.js
================
export { default as SoccerPitch } from './SoccerPitch';
export { default as HeatSoccerPitch } from './HeatSoccerPitch';
export { default as VerticalSoccerPitch } from './VerticalSoccerPitch';
export { default as HalfVerticalPitch } from './HalfVerticalPitch';
export * from './constants';

================
File: src/components/pitch/SoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const SoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.HORIZONTAL}
    {...COLOR_SCHEMES.LIGHT}
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default SoccerPitch;

================
File: src/components/pitch/VerticalSoccerPitch.js
================
import React from 'react';
import BasePitch from './BasePitch';
import { ORIENTATIONS, COLOR_SCHEMES } from './constants';

const VerticalSoccerPitch = ({ children, onPitchClick }) => (
  <BasePitch
    orientation={ORIENTATIONS.VERTICAL}
    {...COLOR_SCHEMES.LIGHT}
    maxWidth='max-w-xl'
    onPitchClick={onPitchClick}
  >
    {children}
  </BasePitch>
);

export default VerticalSoccerPitch;

================
File: src/components/player/features/defending/DefendingItemDetails.js
================
import React from 'react';

export const DefendingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a defensive action to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Action Type</p>
        <p className='text-sm font-bold'>{selectedItem.type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Outcome</p>
        <p className='text-sm font-bold'>
          {selectedItem.outcome || 'Successful'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Pressure Duration</p>
        <p className='text-sm font-bold'>
          {selectedItem.pressure_duration
            ? `${selectedItem.pressure_duration}s`
            : 'N/A'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Duel Type</p>
        <p className='text-sm font-bold'>{selectedItem.duel_type || 'N/A'}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Recovery Type</p>
        <p className='text-sm font-bold'>
          {selectedItem.recovery_type || 'N/A'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Pressure Regain</p>
        <p className='text-sm font-bold'>
          {selectedItem.pressure_regain ? 'Yes' : 'No'}
        </p>
      </div>
    </div>
  );
};

================
File: src/components/player/features/passing/PassingItemDetails.js
================
import React from 'react';

export const PassingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a pass to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Pass Type</p>
        <p className='text-sm font-bold'>{selectedItem.pass_type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Length</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_length?.toFixed(1)}m
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Outcome</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_outcome || 'Complete'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Height</p>
        <p className='text-sm font-bold'>
          {selectedItem.pass_height || 'Ground'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Progressive</p>
        <p className='text-sm font-bold'>
          {selectedItem.progressive ? 'Yes' : 'No'}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Assist</p>
        <p className='text-sm font-bold'>
          {selectedItem.assist ? 'Yes' : 'No'}
        </p>
      </div>
    </div>
  );
};

================
File: src/components/player/features/shooting/ShootingItemDetails.js
================
import React from 'react';

export const ShootingItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a shot to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Shot Outcome</p>
        <p className='text-sm font-bold'>{selectedItem.shot_outcome}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Expected Goals (xG)</p>
        <p className='text-sm font-bold'>
          {selectedItem.shot_statsbomb_xg?.toFixed(2)}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Shot Type</p>
        <p className='text-sm font-bold'>{selectedItem.shot_type}</p>
      </div>
    </div>
  );
};

================
File: src/components/player/features/summary/SummaryItemDetails.js
================
import React from 'react';

export const SummaryItemDetails = ({ selectedItem }) => {
  if (!selectedItem) {
    return (
      <div className='text-center text-gray-500'>
        Select a touch point to see details
      </div>
    );
  }

  return (
    <div className='grid grid-cols-3 gap-4'>
      <div>
        <p className='text-xs text-gray-500'>Touch Type</p>
        <p className='text-sm font-bold'>{selectedItem.type}</p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>X Location</p>
        <p className='text-sm font-bold'>
          {selectedItem.location[0].toFixed(1)}
        </p>
      </div>
      <div>
        <p className='text-xs text-gray-500'>Y Location</p>
        <p className='text-sm font-bold'>
          {selectedItem.location[1].toFixed(1)}
        </p>
      </div>
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/statoverview/ShootingStatsOverview.js
================
import React from 'react';
import { StatCard } from './StatCard';

export const ShootingStatsOverview = ({ statistics }) => {
  if (!statistics) return null;

  return (
    <div className='grid grid-cols-2 gap-2'>
      {/* First row - Goals and xG side by side */}
      <StatCard label='Goals' value={`${statistics.goals}`} />
      <StatCard label='Expected Goals' value={statistics.total_xg.toFixed(2)} />

      {/* Second row */}
      <StatCard
        label='Shots on target'
        value={`${statistics.shots_on_target}`}
      />
      <StatCard
        label='Shots off target'
        value={`${statistics.shots_off_target}`}
      />

      {/* Only render shots blocked if not zero */}
      {statistics.shots_blocked > 0 && (
        <div className='col-span-2'>
          <StatCard
            label='Shots blocked'
            value={`${statistics.shots_blocked}`}
          />
        </div>
      )}

      {/* Accuracy and conversion side by side */}
      <StatCard
        label='Shooting accuracy'
        value={`${statistics.shot_accuracy}%`}
      />
      <StatCard
        label='Shot conversion'
        value={`${statistics.shot_conversion}%`}
      />
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/statoverview/StatCard.js
================
export const StatCard = ({ label, value, className = '' }) => (
  <div className={`rounded-lg bg-gray-50 p-3 ${className}`}>
    <p className='text-xs text-gray-500'>{label}</p>
    <p className='text-lg font-bold'>{value}</p>
  </div>
);

================
File: src/components/player/PlayerMatchPerformance/components/statoverview/SummaryStatsOverview.js
================
import React from 'react';
import { StatCard } from './StatCard';

export const SummaryStatsOverview = ({ touches }) => {
  if (!touches) return null;

  return (
    <div className='grid grid-cols-3 gap-2 lg:grid-cols-1'>
      <StatCard label='Touches' value={touches.length} />
      <StatCard
        label='Shots'
        value={touches.filter(t => t.type === 'Shot').length}
      />
      <StatCard
        label='Passes'
        value={touches.filter(t => t.type === 'Pass').length}
      />
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/ItemDetails.js
================
// src/components/ItemDetails.jsx
import React from 'react';
import { STAT_TYPES } from '../config/statTypes';
// EDIT FOR ONLY SUBSTAT
export const ItemDetails = ({ selectedStat, selectedItem }) => {
  const renderDetails = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        if (!selectedItem) {
          return (
            <div className='text-center text-gray-500'>
              Select a shot to see details
            </div>
          );
        }
        return (
          <div className='grid grid-cols-3 gap-4'>
            <div>
              <p className='text-xs text-gray-500'>Shot Outcome</p>
              <p className='text-sm font-bold'>{selectedItem.shot_outcome}</p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Expected Goals (xG)</p>
              <p className='text-sm font-bold'>
                {selectedItem.shot_statsbomb_xg?.toFixed(2)}
              </p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Shot Type</p>
              <p className='text-sm font-bold'>{selectedItem.shot_type}</p>
            </div>
          </div>
        );

      case STAT_TYPES.SUMMARY:
        if (!selectedItem) {
          return (
            <div className='text-center text-gray-500'>
              Select a touch point to see details
            </div>
          );
        }
        return (
          <div className='grid grid-cols-3 gap-4'>
            <div>
              <p className='text-xs text-gray-500'>Touch Type</p>
              <p className='text-sm font-bold'>{selectedItem.type}</p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>X Location</p>
              <p className='text-sm font-bold'>
                {selectedItem.location[0].toFixed(1)}
              </p>
            </div>
            <div>
              <p className='text-xs text-gray-500'>Y Location</p>
              <p className='text-sm font-bold'>
                {selectedItem.location[1].toFixed(1)}
              </p>
            </div>
          </div>
        );

      default:
        return (
          <div className='text-center text-gray-500'>
            Select an item to see details
          </div>
        );
    }
  };

  return (
    <div className='rounded-lg bg-white p-4 shadow-sm'>{renderDetails()}</div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/PlayerProfile.js
================
import React from 'react';

export const PlayerProfile = ({ playerInfo = {} }) => {
  return (
    <div className='col-span-12 rounded-lg bg-white p-4 shadow-lg lg:col-span-3'>
      <div className='flex items-center space-x-4'>
        <div className='h-16 w-16 rounded-full bg-gray-200'>
          {playerInfo?.jerseyNumber && (
            <div className='flex h-full w-full items-center justify-center text-xl font-bold text-gray-600'>
              {playerInfo.jerseyNumber}
            </div>
          )}
        </div>
        <div>
          <h3 className='font-semibold'>
            {playerInfo?.nickname || playerInfo?.playerName || 'Player Name'}
          </h3>
          <p className='text-sm text-gray-600'>
            {playerInfo?.team} • {playerInfo?.position || 'Position'}
          </p>
        </div>
      </div>
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/StatNavigation.js
================
import React from 'react';
import { statCategories } from '../config/statConfig';

export const StatNavigation = ({ selectedStat, onStatChange }) => (
  <div className='col-span-12 flex items-center rounded-lg bg-white px-6 py-4 shadow-lg lg:col-span-9'>
    <div className='flex space-x-4 overflow-x-auto'>
      {statCategories.map(category => (
        <button
          key={category.id}
          className={`whitespace-nowrap rounded-full px-4 py-1.5 text-sm font-medium transition-colors ${
            selectedStat === category.id
              ? 'bg-blue-500 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
          onClick={() => onStatChange(category)}
        >
          {category.name}
        </button>
      ))}
    </div>
  </div>
);

================
File: src/components/player/PlayerMatchPerformance/components/StatOverview.js
================
import { STAT_TYPES, STAT_TITLES } from '../config/statTypes';
import { ShootingStatsOverview } from './statoverview/ShootingStatsOverview';
import { SummaryStatsOverview } from './statoverview/SummaryStatsOverview';

export const StatOverview = ({ selectedStat, data }) => {
  const renderStats = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        return <ShootingStatsOverview statistics={data?.statistics} />;
      case STAT_TYPES.SUMMARY:
        return <SummaryStatsOverview touches={data?.touches} />;
      default:
        return null;
    }
  };

  return (
    <div className='mb-4 rounded-lg bg-white p-4 shadow-lg'>
      <h3 className='mb-3 text-lg font-semibold'>
        {STAT_TITLES[selectedStat] || 'Overview'}
      </h3>
      {renderStats()}
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/SubStatNavigation.js
================
import React from 'react';
import { statCategories } from '../config/statConfig'; // change for getSubStatTypes(selectedStat);

export const SubStatNavigation = ({
  selectedStat,
  selectedSubStat,
  onSubStatChange,
}) => {
  const subStats =
    statCategories.find(cat => cat.id === selectedStat)?.subStats || [];

  return (
    <div className='mb-4 flex space-x-4 overflow-x-auto'>
      {subStats.map(subStat => (
        <button
          key={subStat.id}
          className={`whitespace-nowrap rounded-md px-4 py-2 ${
            selectedSubStat === subStat.id
              ? 'bg-blue-100 text-blue-700'
              : 'text-gray-600 hover:bg-gray-100'
          }`}
          onClick={() => onSubStatChange(subStat.id)}
        >
          {subStat.name}
        </button>
      ))}
    </div>
  );
};

================
File: src/components/player/PlayerMatchPerformance/components/Visualization.js
================
// src/components/Visualization.jsx
import React from 'react';
import { STAT_TYPES } from '../config/statTypes';
import { statCategories } from '../config/statConfig';

export const Visualization = ({
  selectedStat,
  selectedSubStat,
  data,
  selectedItem,
  onItemClick,
}) => {
  const category = statCategories.find(cat => cat.id === selectedStat);
  const subStat = category?.subStats.find(sub => sub.id === selectedSubStat);

  if (!subStat) return null;

  const { container: Container, component: Component } = subStat;

  // Determine props based on stat type
  const getComponentProps = () => {
    switch (selectedStat) {
      case STAT_TYPES.SHOOTING:
        return {
          shots: data?.shots || [],
          onShotClick: onItemClick,
          selectedShot: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.SUMMARY:
        return {
          touches: data?.touches || [], // Fix: Access touches from data object
          onTouchClick: onItemClick,
          selectedTouch: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.PASSING:
        return {
          passes: data?.passes || [],
          onPassClick: onItemClick,
          selectedPass: selectedItem,
          showLabels: false,
        };

      case STAT_TYPES.DEFENDING:
        return {
          actions: data?.actions || [],
          onActionClick: onItemClick,
          selectedAction: selectedItem,
          showLabels: false,
        };

      default:
        return {};
    }
  };

  const componentProps = getComponentProps();

  return (
    <Container>
      <Component {...componentProps} />
    </Container>
  );
};

// component = touches and container = pitch

================
File: src/components/player/PlayerMatchPerformance/config/statConfig.js
================
import { STAT_TYPES } from './statTypes';
import SoccerPitch from '../../../pitch/SoccerPitch';
import VerticalSoccerPitch from '../../../pitch/VerticalSoccerPitch';
import HalfVerticalPitch from '../../../pitch/HalfVerticalPitch';
import { GoalPostVisualization } from '../../../pitch/GoalPost';
import PlayerMatchTouches from '../visualizations/PlayerMatchTouches';
import PlayerMatchShots from '../visualizations/PlayerMatchShots';

export const statCategories = [
  {
    id: STAT_TYPES.SUMMARY, // Using new enum
    name: 'Summary',
    subStats: [
      {
        id: 'touches',
        name: 'Touches',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchTouches {...props} orientation='horizontal' />
        ),
      },
      {
        id: 'heatmap',
        name: 'Heatmap',
        container: ({ children }) => (
          <div className='mx-auto w-full max-w-xl'>
            <VerticalSoccerPitch>{children}</VerticalSoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchTouches {...props} orientation='vertical' />
        ),
      },
    ],
  },
  {
    id: STAT_TYPES.SHOOTING,
    name: 'Shooting',
    subStats: [
      {
        id: 'shots-vertical',
        name: 'Shots (Vertical)',
        container: ({ children }) => (
          <div className='mx-auto w-full max-w-xl'>
            <HalfVerticalPitch>{children}</HalfVerticalPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='vertical' />
        ),
      },
      {
        id: 'shots-horizontal',
        name: 'Shots (Horizontal)',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='horizontal' />
        ),
      },
      {
        id: 'shots-goalview',
        name: 'Shots (Goal View)',
        container: ({ children }) => (
          <div className='w-full'>
            <GoalPostVisualization>{children}</GoalPostVisualization>
          </div>
        ),
        component: props => (
          <PlayerMatchShots {...props} orientation='goalview' />
        ),
      },
    ],
  },
  // New categories
  {
    id: STAT_TYPES.PASSING,
    name: 'Passing',
    subStats: [
      {
        id: 'passMap',
        name: 'Pass Map',
        container: ({ children }) => (
          <div className='w-full'>
            <GoalPostVisualization>{children}</GoalPostVisualization>
          </div>
        ),
        component: PlayerMatchTouches, // You'll need to create passing specific components
      },
    ],
  },
  {
    id: STAT_TYPES.DEFENDING,
    name: 'Defending',
    subStats: [
      {
        id: 'defensiveActions',
        name: 'Defensive Actions',
        container: ({ children }) => (
          <div className='w-full'>
            <SoccerPitch>{children}</SoccerPitch>
          </div>
        ),
        component: PlayerMatchTouches, // You'll need to create defending specific components
      },
    ],
  },
];

export const getStatConfig = statType => {
  return statCategories.find(config => config.id === statType);
};

================
File: src/components/player/PlayerMatchPerformance/config/statTypes.js
================
export const STAT_TYPES = {
  SUMMARY: 'summary',
  SHOOTING: 'shooting',
  PASSING: 'passing',
  DEFENDING: 'defending',
};

export const SUB_STAT_TYPES = {
  SUMMARY: {
    TOUCHES: 'touches',
    HEATMAP: 'heatmap',
  },
  SHOOTING: {
    SHOTS_VERTICAL: 'shots-vertical',
    SHOTS_HORIZONTAL: 'shots-horizontal',
    SHOTS_GOALVIEW: 'shots-goalview',
  },
  PASSING: {
    PASS_MAP: 'passMap',
  },
  DEFENDING: {
    DEFENSIVE_ACTIONS: 'defensiveActions',
  },
};

export const STAT_TITLES = {
  [STAT_TYPES.SUMMARY]: 'Match Overview',
  [STAT_TYPES.SHOOTING]: 'Shooting Overview',
  [STAT_TYPES.PASSING]: 'Passing Overview',
  [STAT_TYPES.DEFENDING]: 'Defending Overview',
};

export const getSubStatTypes = statType => {
  switch (statType) {
    case STAT_TYPES.SUMMARY:
      return SUB_STAT_TYPES.SUMMARY;
    case STAT_TYPES.SHOOTING:
      return SUB_STAT_TYPES.SHOOTING;
    case STAT_TYPES.PASSING:
      return SUB_STAT_TYPES.PASSING;
    case STAT_TYPES.DEFENDING:
      return SUB_STAT_TYPES.DEFENDING;
    default:
      return {};
  }
};

export const getDefaultSubStat = statType => {
  switch (statType) {
    case STAT_TYPES.SUMMARY:
      return SUB_STAT_TYPES.SUMMARY.TOUCHES;
    case STAT_TYPES.SHOOTING:
      return SUB_STAT_TYPES.SHOOTING.SHOTS_VERTICAL;
    case STAT_TYPES.PASSING:
      return SUB_STAT_TYPES.PASSING.PASS_MAP;
    case STAT_TYPES.DEFENDING:
      return SUB_STAT_TYPES.DEFENDING.DEFENSIVE_ACTIONS;
    default:
      return '';
  }
};

================
File: src/components/player/PlayerMatchPerformance/hooks/useStatData.js
================
import { useState, useEffect } from 'react';
import { STAT_TYPES } from '../config/statTypes';
import * as api from '../../../../services/api';

export const useStatData = (matchId, playerName, selectedStat) => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      if (!matchId || !playerName) {
        setLoading(false);
        return;
      }

      setLoading(true);
      setError(null);

      try {
        let result;

        switch (selectedStat) {
          case STAT_TYPES.SUMMARY: {
            const touchesData = await api.getPlayerMatchTouches(
              matchId,
              playerName,
            );
            result = {
              touches: touchesData,
            };
            break;
          }

          case STAT_TYPES.SHOOTING: {
            result = await api.getPlayerMatchShooting(matchId, playerName);
            break;
          }

          case STAT_TYPES.PASSING: {
            const passingData = await api.getPlayerMatchPassing(
              matchId,
              playerName,
            );
            result = {
              passes: passingData,
            };
            break;
          }

          case STAT_TYPES.DEFENDING: {
            const defendingData = await api.getPlayerMatchDefending(
              matchId,
              playerName,
            );
            result = {
              actions: defendingData,
            };
            break;
          }

          default:
            throw new Error(`Invalid stat type: ${selectedStat}`);
        }

        setData(result);
      } catch (err) {
        console.error('Error fetching data:', err);
        setError(err.message || 'Failed to load data');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, [matchId, playerName, selectedStat]);

  return {
    data,
    loading,
    error,
    refresh: () => {
      setData(null);
      setLoading(true);
    },
  };
};

================
File: src/components/player/PlayerMatchPerformance/visualizations/index.js
================
export { default as PlayerMatchShots } from './PlayerMatchShots';
export { default as PlayerMatchTouches } from './PlayerMatchTouches';
export { default as PlayerVertMatchTouches } from './PlayerVertMatchTouches';

================
File: src/components/player/PlayerMatchPerformance/visualizations/PlayerMatchShots.js
================
import React, { useCallback } from 'react';

const PlayerMatchShots = ({
  shots = [],
  onShotClick,
  selectedShot,
  showLabels = true,
  orientation = 'vertical',
}) => {
  const handleShotClick = useCallback(
    (shot, event) => {
      event.stopPropagation();
      onShotClick?.(shot);
    },
    [onShotClick],
  );

  const getShotRadius = (xg, isGoalView) => {
    if (isGoalView) {
      return 0.2; // Smaller, fixed size for goal view
    }

    if (!xg) return 1;
    const xgValue = parseFloat(xg);
    if (xgValue <= 0.05) return 0.8;
    if (xgValue <= 0.15) return 1.2;
    if (xgValue <= 0.25) return 1.6;
    if (xgValue <= 0.35) return 2;
    return 2.4;
  };

  const getShotStyle = (shot, isSelected, isGoalView) => {
    const isGoal = shot.shot_outcome === 'Goal';
    return {
      fill: isGoal ? 'rgba(244, 63, 94, 0.6)' : 'rgba(0, 0, 0, 0.1)',
      stroke: isGoal ? '#000000' : '#000000',
      strokeWidth: isSelected
        ? isGoalView
          ? '0.1'
          : '0.4'
        : isGoalView
          ? '0.05'
          : '0.2',
      cursor: 'pointer',
    };
  };

  const mapRange = (value, a, b, c, d) => {
    return c + ((value - a) * (d - c)) / (b - a);
  };

  const getCoordinates = (location, isEndLocation = false) => {
    if (!location) return { x: 0, y: 0 };

    const [originalX, originalY, originalZ] = location;

    if (orientation === 'goalview' && isEndLocation) {
      return {
        x: originalY,
        y: originalZ !== undefined ? mapRange(originalZ, 0, 5.34, 5.34, 0) : 0,
      };
    }

    if (orientation === 'vertical') {
      return {
        x: originalY,
        y: 120 - originalX,
      };
    }

    return {
      x: originalX,
      y: originalY,
    };
  };

  const getLineStartPoint = (start, end, radius, isSelected) => {
    const startCoord = getCoordinates(start);
    const endCoord = getCoordinates(end);

    const dx = endCoord.x - startCoord.x;
    const dy = endCoord.y - startCoord.y;
    const length = Math.sqrt(dx * dx + dy * dy);
    const totalRadius = radius + (isSelected ? 0.5 : 0);

    return {
      x: startCoord.x + (dx / length) * totalRadius,
      y: startCoord.y + (dy / length) * totalRadius,
    };
  };

  return (
    <>
      {shots.map((shot, index) => {
        const isGoalView = orientation === 'goalview';
        const coords = isGoalView
          ? getCoordinates(shot.shot_end_location, true)
          : getCoordinates(shot.location);

        const isSelected = selectedShot?.id === shot.id;
        const shotStyle = getShotStyle(shot, isSelected, isGoalView);
        const radius = getShotRadius(shot.shot_statsbomb_xg, isGoalView);

        // Skip shots without end location for goalview
        if (isGoalView && !shot.shot_end_location) {
          return null;
        }

        return (
          <g
            key={shot.id || `${index}-${coords.x}-${coords.y}`}
            onClick={e => handleShotClick(shot, e)}
          >
            {isSelected && (
              <circle
                cx={coords.x}
                cy={coords.y}
                r={radius + (isGoalView ? 0.14 : 0.6)}
                fill='none'
                stroke='rgb(255, 0, 0)'
                strokeWidth={isGoalView ? '0.1' : '0.4'}
              />
            )}

            <circle cx={coords.x} cy={coords.y} r={radius} style={shotStyle} />

            {showLabels && !isGoalView && (
              <text
                x={coords.x}
                y={coords.y - radius - 0.5}
                fontSize='2'
                fill={shotStyle.stroke}
                textAnchor='middle'
                alignmentBaseline='bottom'
              >
                {index + 1}
              </text>
            )}

            {/* Only show trajectory line for pitch views, not goalview */}
            {isSelected && shot.shot_end_location && !isGoalView && (
              <line
                x1={
                  getLineStartPoint(
                    shot.location,
                    shot.shot_end_location,
                    radius,
                    true,
                  ).x
                }
                y1={
                  getLineStartPoint(
                    shot.location,
                    shot.shot_end_location,
                    radius,
                    true,
                  ).y
                }
                x2={getCoordinates(shot.shot_end_location).x}
                y2={getCoordinates(shot.shot_end_location).y}
                stroke='rgb(255, 0, 0)'
                strokeWidth='0.4'
              />
            )}
          </g>
        );
      })}
    </>
  );
};

export default PlayerMatchShots;

================
File: src/components/player/PlayerMatchPerformance/visualizations/PlayerMatchTouches.js
================
import React, { useCallback } from 'react';

const PlayerMatchTouches = ({
  touches = [],
  onTouchClick,
  selectedTouch,
  showLabels = true,
  orientation = 'horizontal', // New prop to control orientation
}) => {
  const handleTouchClick = useCallback(
    (touch, event) => {
      if (onTouchClick) {
        event.stopPropagation();
        onTouchClick(touch);
      }
    },
    [onTouchClick],
  );

  const getTouchStyle = touch => {
    const touchColors = {
      Shot: 'rgba(59, 130, 246, 0.5)',
      assist: 'rgba(234, 179, 8, 0.5)',
      default: 'rgba(234, 179, 8, 0.5)',
    };

    const borderColors = {
      Shot: 'rgb(59, 130, 246)',
      assist: 'rgb(234, 179, 8)',
      default: 'rgb(234, 179, 8)',
    };

    return {
      fill: touchColors[touch.type] || touchColors.default,
      stroke: borderColors[touch.type] || borderColors.default,
      strokeWidth: selectedTouch === touch ? '0.4' : '0.2',
    };
  };

  const getCoordinates = touch => {
    const [originalX, originalY] = touch.location;
    if (orientation === 'vertical') {
      return {
        x: originalY,
        y: 120 - originalX, // Assuming 120 is the pitch height
      };
    }
    return {
      x: originalX,
      y: originalY,
    };
  };

  return (
    <>
      {touches.map((touch, index) => {
        const { x, y } = getCoordinates(touch);
        const touchStyle = getTouchStyle(touch);

        return (
          <g
            key={`${index}-${touch.type}-${x}-${y}`}
            onClick={e => handleTouchClick(touch, e)}
            style={{ cursor: 'pointer' }}
          >
            {selectedTouch === touch && (
              <circle
                cx={x}
                cy={y}
                r='1.5'
                fill='none'
                stroke='rgb(239, 68, 68)'
                strokeWidth='0.2'
                strokeDasharray='0.5'
              />
            )}

            <circle cx={x} cy={y} r='1' {...touchStyle} />

            {showLabels && (
              <text
                x={x}
                y={y - 1.5}
                fontSize='2'
                fill={touchStyle.stroke}
                textAnchor='middle'
                alignmentBaseline='bottom'
              >
                {index + 1}
              </text>
            )}
          </g>
        );
      })}
    </>
  );
};

export default PlayerMatchTouches;

================
File: src/components/player/PlayerMatchPerformance/PlayerMatchPerformance.js
================
import React, { useState, useEffect } from 'react';
import { useParams, useLocation } from 'react-router-dom';
import { STAT_TYPES, getDefaultSubStat } from './config/statTypes';
import { useStatData } from './hooks/useStatData';
import { PlayerProfile } from './components/PlayerProfile';
import { StatNavigation } from './components/StatNavigation';
import { StatOverview } from './components/StatOverview';
import { SubStatNavigation } from './components/SubStatNavigation';
import { ItemDetails } from './components/ItemDetails';
import { Visualization } from './components/Visualization';
import MatchHeader from '../../match/MatchHeader';
import * as api from '../../../services/api';

const PlayerMatchPerformance = () => {
  const { matchId, playerName } = useParams();
  const location = useLocation();
  const [playerInfo, setPlayerInfo] = useState(
    location.state?.playerInfo || null,
  );
  const [matchData, setMatchData] = useState(location.state?.matchData || null);
  const [loadingPlayerInfo, setLoadingPlayerInfo] = useState(
    !location.state?.playerInfo,
  );
  const [loadingMatchData, setLoadingMatchData] = useState(
    !location.state?.matchData,
  );

  const [selectedStat, setSelectedStat] = useState(STAT_TYPES.SUMMARY);
  const [selectedSubStat, setSelectedSubStat] = useState(
    getDefaultSubStat(STAT_TYPES.SUMMARY),
  );
  const [selectedTeam, setSelectedTeam] = useState('team1');
  const [selectedItem, setSelectedItem] = useState(null);

  // Fetch match data if not available in state
  useEffect(() => {
    const fetchMatchData = async () => {
      if (!matchData && matchId) {
        try {
          setLoadingMatchData(true);
          const matchesData = await api.getCompetitionMatches();
          const currentMatch = matchesData.find(
            m => m.match_id.toString() === matchId,
          );
          if (currentMatch) {
            setMatchData(currentMatch);
          }
        } catch (error) {
          console.error('Error fetching match data:', error);
        } finally {
          setLoadingMatchData(false);
        }
      }
    };

    fetchMatchData();
  }, [matchId, matchData]);

  // Fetch player info if not available in state
  useEffect(() => {
    const fetchPlayerInfo = async () => {
      if (!playerInfo && matchId && playerName) {
        try {
          const lineupsData = await api.getMatchLineups(matchId);

          // Search through both teams' lineups
          const allPlayers = [
            ...(Object.values(lineupsData)[0] || []),
            ...(Object.values(lineupsData)[1] || []),
          ];

          const player = allPlayers.find(
            p =>
              p.player_name === decodeURIComponent(playerName) ||
              p.nickname === decodeURIComponent(playerName),
          );

          if (player) {
            setPlayerInfo({
              playerId: player.player_id,
              playerName: player.player_name,
              nickname: player.nickname,
              jerseyNumber: player.jersey_number,
              team: Object.keys(lineupsData).find(team =>
                lineupsData[team].some(p => p.player_id === player.player_id),
              ),
              position: player.positions?.[0]?.position,
            });
          }
        } catch (error) {
          console.error('Error fetching player info:', error);
        } finally {
          setLoadingPlayerInfo(false);
        }
      }
    };

    fetchPlayerInfo();
  }, [matchId, playerName, playerInfo]);

  // Use our custom hook to fetch data
  const { data, loading, error } = useStatData(
    matchId,
    playerInfo?.playerName || playerName,
    selectedStat,
  );

  const handleStatChange = category => {
    setSelectedStat(category.id);
    setSelectedSubStat(getDefaultSubStat(category.id));
    setSelectedItem(null);
  };

  const handleSubStatChange = subStatId => {
    setSelectedSubStat(subStatId);
    setSelectedItem(null);
  };

  const handleItemClick = item => {
    setSelectedItem(prev => (prev === item ? null : item));
  };

  if (loadingPlayerInfo || loadingMatchData) {
    return (
      <div className='flex h-screen items-center justify-center'>
        <div className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent' />
      </div>
    );
  }

  return (
    <div className='min-h-screen bg-gray-100'>
      <div className='container mx-auto px-4 py-8'>
        {/* Match Header */}
        {matchData && <MatchHeader matchData={matchData} />}

        <div className='grid grid-cols-12 gap-4'>
          {/* Profile and Navigation Section */}
          <div className='col-span-12 grid grid-cols-12 gap-4'>
            <PlayerProfile playerInfo={playerInfo} />
            <StatNavigation
              selectedStat={selectedStat}
              onStatChange={handleStatChange}
            />
          </div>

          {/* Stats Overview Section */}
          <div className='col-span-12 lg:col-span-3'>
            <StatOverview selectedStat={selectedStat} data={data} />
          </div>

          {/* Main Visualization Section */}
          <div className='col-span-12 lg:col-span-9'>
            <div className='rounded-lg bg-white shadow-lg'>
              {/* Sub-stat Navigation */}
              <div className='px-6 pt-4'>
                <SubStatNavigation
                  selectedStat={selectedStat}
                  selectedSubStat={selectedSubStat}
                  onSubStatChange={handleSubStatChange}
                />
              </div>

              {/* Visualization and Details */}
              <div className='px-6 pb-6'>
                {loading ? (
                  <div className='flex h-full items-center justify-center'>
                    <div className='h-8 w-8 animate-spin rounded-full border-4 border-blue-500 border-t-transparent' />
                  </div>
                ) : error ? (
                  <div className='flex h-full items-center justify-center text-red-500'>
                    {error}
                  </div>
                ) : (
                  <>
                    <Visualization
                      selectedStat={selectedStat}
                      selectedSubStat={selectedSubStat}
                      data={data}
                      selectedItem={selectedItem}
                      onItemClick={handleItemClick}
                    />

                    <div className='mt-4 rounded-lg bg-gray-50 p-4'>
                      <ItemDetails
                        selectedStat={selectedStat}
                        selectedItem={selectedItem}
                      />
                    </div>
                  </>
                )}
              </div>
            </div>
          </div>
        </div>

        {/* Team Switch Button */}
        <div className='mt-4 flex justify-center'>
          <button
            className='rounded-full bg-gray-800 px-6 py-2 text-white shadow-lg hover:bg-gray-700'
            onClick={() =>
              setSelectedTeam(prev => (prev === 'team1' ? 'team2' : 'team1'))
            }
          >
            Switch to {selectedTeam === 'team1' ? 'Team 2' : 'Team 1'}
          </button>
        </div>
      </div>
    </div>
  );
};

export default PlayerMatchPerformance;

================
File: src/services/api.js
================
import axios from 'axios';

const API_URL = 'http://127.0.0.1:8000/api/';

// Configure axios instance
const apiClient = axios.create({
  baseURL: API_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Add logging
apiClient.interceptors.request.use(request => {
  console.log('Making request to:', request.url);
  return request;
});

apiClient.interceptors.response.use(
  response => response,
  error => {
    console.error('API Error:', error?.response?.data || error.message);
    throw error;
  },
);

// =====================================
// Competition & Season Related Endpoints
// =====================================

export const getCompetitions = async () => {
  try {
    const response = await apiClient.get('competitions/');
    return response.data;
  } catch (error) {
    console.error('Failed to fetch competitions:', error);
    throw new Error('Failed to load competitions');
  }
};

export const getSeasons = async competitionId => {
  try {
    const response = await apiClient.get(`seasons/${competitionId}/`);
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch seasons for competition ${competitionId}:`,
      error,
    );
    throw new Error('Failed to load seasons');
  }
};

export const getCompetitionInfo = async (competitionId, seasonId) => {
  try {
    const response = await apiClient.get(
      `competition-info/${competitionId}/${seasonId}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch competition info for competition ${competitionId}, season ${seasonId}:`,
      error,
    );
    throw new Error('Failed to load competition information');
  }
};

export const getCompetitionMatches = async (competitionId, seasonId) => {
  try {
    const response = await apiClient.get(
      `matches/${competitionId}/${seasonId}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch matches for competition ${competitionId}, season ${seasonId}:`,
      error,
    );
    throw new Error('Failed to load matches');
  }
};

// =====================================
// Match Related Endpoints
// =====================================

export const getMatchInfo = async matchId => {
  try {
    const response = await apiClient.get(`match-info/${matchId}/`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch match info for match ${matchId}:`, error);
    throw new Error('Failed to load match information');
  }
};

export const getMatchLineups = async matchId => {
  try {
    const response = await apiClient.get(`match-lineups/${matchId}/`);
    return response.data;
  } catch (error) {
    console.error(`Failed to fetch lineups for match ${matchId}:`, error);
    throw new Error('Failed to load match lineups');
  }
};

// =====================================
// Player Match Performance Endpoints
// =====================================

export const getPlayerMatchTouches = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-touches/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch touch data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player touch data');
  }
};

export const getPlayerMatchPassing = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-passing/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch passing data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player passing data');
  }
};

export const getPlayerMatchShooting = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-shooting/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch shooting data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player shooting data');
  }
};

export const getPlayerMatchDefending = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-def/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch defending data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player defending data');
  }
};

export const getPlayerMatchPossession = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-match-poss/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch possession data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load player possession data');
  }
};

export const getGoalkeeperMatchStats = async (matchId, playerName) => {
  try {
    const response = await apiClient.get(
      `player-gk/${matchId}/${encodeURIComponent(playerName)}/`,
    );
    return response.data;
  } catch (error) {
    console.error(
      `Failed to fetch goalkeeper data for match ${matchId}, player ${playerName}:`,
      error,
    );
    throw new Error('Failed to load goalkeeper data');
  }
};

================
File: src/App.js
================
import React from 'react';
import { BrowserRouter as Router, Route, Routes } from 'react-router-dom';
import Home from './components/homepage/Home';
import CompetitionOverview from './components/competition/CompetitionOverview';
import BaseLayout from './components/common/BaseLayout';
import MatchDetails from './components/match/MatchDetails';
import PlayerMatchPerformance from './components/player/PlayerMatchPerformance/PlayerMatchPerformance';
import './index.css';

function App() {
  return (
    <Router>
      <BaseLayout>
        <Routes>
          <Route path='/' element={<Home />} />
          <Route
            path='/player-performance/:matchId/:playerName'
            element={<PlayerMatchPerformance />}
          />
          <Route
            path='/league/:competitionId/:seasonId'
            element={<CompetitionOverview />}
          />
          <Route path='/match/:matchId' element={<MatchDetails />} />
        </Routes>
      </BaseLayout>
    </Router>
  );
}

export default App;

================
File: src/App.test.js
================
import { render, screen } from '@testing-library/react';
import App from './App';

test('renders learn react link', () => {
  render(<App />);
  const linkElement = screen.getByText(/learn react/i);
  expect(linkElement).toBeInTheDocument();
});

================
File: src/index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  @apply bg-gray-900;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
);

// If you want to start measuring performance in your app, pass a function
// to log results (for example: reportWebVitals(console.log))
// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals
reportWebVitals();

================
File: src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: src/setupTests.js
================
// jest-dom adds custom jest matchers for asserting on DOM nodes.
// allows you to do things like:
// expect(element).toHaveTextContent(/react/i)
// learn more: https://github.com/testing-library/jest-dom
import '@testing-library/jest-dom';

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

================
File: .prettierrc
================
{
  "arrowParens": "avoid",
  "bracketSpacing": true,
  "htmlWhitespaceSensitivity": "css",
  "jsxSingleQuote": true,
  "printWidth": 80,
  "proseWrap": "always",
  "endOfLine": "lf",
  "semi": true,
  "singleQuote": true,
  "tabWidth": 2,
  "trailingComma": "all",
  "quoteProps": "as-needed",
  "useTabs": false,
  "plugins": ["prettier-plugin-tailwindcss"]
}

================
File: package.json
================
{
  "name": "frontend",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "axios": "^1.7.7",
    "bootstrap": "^5.3.3",
    "date-fns": "^2.30.0",
    "react": "^18.3.1",
    "react-bootstrap": "^2.10.5",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.27.0",
    "react-scripts": "^5.0.1",
    "theme-change": "^2.5.0",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts --openssl-legacy-provider start",
    "build": "react-scripts --openssl-legacy-provider build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "daisyui": "^4.12.14",
    "prettier": "^3.3.3",
    "prettier-plugin-tailwindcss": "^0.6.8",
    "tailwindcss": "^3.4.14"
  }
}

================
File: README.md
================
# Getting Started with Create React App

This project was bootstrapped with
[Create React App](https://github.com/facebook/create-react-app).

## Available Scripts

In the project directory, you can run:

### `npm start`

Runs the app in the development mode.\
Open [http://localhost:3000](http://localhost:3000) to view it in your browser.

The page will reload when you make changes.\
You may also see any lint errors in the console.

### `npm test`

Launches the test runner in the interactive watch mode.\
See the section about
[running tests](https://facebook.github.io/create-react-app/docs/running-tests)
for more information.

### `npm run build`

Builds the app for production to the `build` folder.\
It correctly bundles React in production mode and optimizes the build for the
best performance.

The build is minified and the filenames include the hashes.\
Your app is ready to be deployed!

See the section about
[deployment](https://facebook.github.io/create-react-app/docs/deployment) for
more information.

### `npm run eject`

**Note: this is a one-way operation. Once you `eject`, you can't go back!**

If you aren't satisfied with the build tool and configuration choices, you can
`eject` at any time. This command will remove the single build dependency from
your project.

Instead, it will copy all the configuration files and the transitive
dependencies (webpack, Babel, ESLint, etc) right into your project so you have
full control over them. All of the commands except `eject` will still work, but
they will point to the copied scripts so you can tweak them. At this point
you're on your own.

You don't have to ever use `eject`. The curated feature set is suitable for
small and middle deployments, and you shouldn't feel obligated to use this
feature. However we understand that this tool wouldn't be useful if you couldn't
customize it when you are ready for it.

## Learn More

You can learn more in the
[Create React App documentation](https://facebook.github.io/create-react-app/docs/getting-started).

To learn React, check out the [React documentation](https://reactjs.org/).

### Code Splitting

This section has moved here:
[https://facebook.github.io/create-react-app/docs/code-splitting](https://facebook.github.io/create-react-app/docs/code-splitting)

### Analyzing the Bundle Size

This section has moved here:
[https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size](https://facebook.github.io/create-react-app/docs/analyzing-the-bundle-size)

### Making a Progressive Web App

This section has moved here:
[https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app](https://facebook.github.io/create-react-app/docs/making-a-progressive-web-app)

### Advanced Configuration

This section has moved here:
[https://facebook.github.io/create-react-app/docs/advanced-configuration](https://facebook.github.io/create-react-app/docs/advanced-configuration)

### Deployment

This section has moved here:
[https://facebook.github.io/create-react-app/docs/deployment](https://facebook.github.io/create-react-app/docs/deployment)

### `npm run build` fails to minify

This section has moved here:
[https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify](https://facebook.github.io/create-react-app/docs/troubleshooting#npm-run-build-fails-to-minify)

================
File: tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
  daisyui: { themes: ['light', 'dark'] },
};

================
File: frontend/tailwind.config.js
================
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ['./src/**/*.{js,jsx,ts,tsx}'],
  theme: {
    extend: {},
  },
  plugins: [require('daisyui')],
  daisyui: { themes: ['light', 'dark'] },
};

================
File: .gitignore
================
# Byte-compiled / optimized / DLL files
__pycache__/
*.py[cod]
*$py.class

# C extensions
*.so

# Ignore settings file
mysite/settings.py  # Replace with the path to your settings file if different

# Distribution / packaging
.Python
build/
develop-eggs/
dist/
downloads/
eggs/
.eggs/
lib/
lib64/
parts/
sdist/
var/
wheels/
share/python-wheels/
*.egg-info/
.installed.cfg
*.egg
MANIFEST

# PyInstaller
#  Usually these files are written by a python script from a template
#  before PyInstaller builds the exe, so as to inject date/other infos into it.
*.manifest
*.spec

# Installer logs
pip-log.txt
pip-delete-this-directory.txt

# Unit test / coverage reports
htmlcov/
.tox/
.nox/
.coverage
.coverage.*
.cache
nosetests.xml
coverage.xml
*.cover
*.py,cover
.hypothesis/
.pytest_cache/
cover/

# Translations
*.mo
*.pot

# Django stuff:
*.log
local_settings.py
db.sqlite3
db.sqlite3-journal

# Flask stuff:
instance/
.webassets-cache

# Scrapy stuff:
.scrapy

# Sphinx documentation
docs/_build/

# PyBuilder
.pybuilder/
target/

# Jupyter Notebook
.ipynb_checkpoints

# IPython
profile_default/
ipython_config.py

# pyenv
#   For a library or package, you might want to ignore these files since the code is
#   intended to run in multiple environments; otherwise, check them in:
# .python-version

# pipenv
#   According to pypa/pipenv#598, it is recommended to include Pipfile.lock in version control.
#   However, in case of collaboration, if having platform-specific dependencies or dependencies
#   having no cross-platform support, pipenv may install dependencies that don't work, or not
#   install all needed dependencies.
#Pipfile.lock

# poetry
#   Similar to Pipfile.lock, it is generally recommended to include poetry.lock in version control.
#   This is especially recommended for binary packages to ensure reproducibility, and is more
#   commonly ignored for libraries.
#   https://python-poetry.org/docs/basic-usage/#commit-your-poetrylock-file-to-version-control
#poetry.lock

# pdm
#   Similar to Pipfile.lock, it is generally recommended to include pdm.lock in version control.
#pdm.lock
#   pdm stores project-wide configurations in .pdm.toml, but it is recommended to not include it
#   in version control.
#   https://pdm.fming.dev/latest/usage/project/#working-with-version-control
.pdm.toml
.pdm-python
.pdm-build/

# PEP 582; used by e.g. github.com/David-OConnor/pyflow and github.com/pdm-project/pdm
__pypackages__/

# Celery stuff
celerybeat-schedule
celerybeat.pid

# SageMath parsed files
*.sage.py

# Environments
.env
.venv
.myenv
env/
venv/
myenv/
ENV/
env.bak/
venv.bak/

# Spyder project settings
.spyderproject
.spyproject

# Rope project settings
.ropeproject

# mkdocs documentation
/site

# mypy
.mypy_cache/
.dmypy.json
dmypy.json

# Pyre type checker
.pyre/

# pytype static type analyzer
.pytype/

# Cython debug symbols
cython_debug/

# PyCharm
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Personal
# docs/
# backend/repomix-output.txt
# backend/sbapi/services
# backend/sbapi/management

================
File: README.md
================
# Football Analytics Platform

A comprehensive web application for football/soccer analytics, leveraging StatsBomb data to provide insights, match analysis, and performance statistics.

## Overview

This platform combines StatsBomb's rich football data with interactive visualizations and analytics tools to provide:

- League standings and statistics
- Match analysis and event tracking
- Player performance metrics
- Touch and event visualization on an interactive pitch
- Team statistics and comparisons

## Features

### 🏆 League Management

- View and track multiple leagues
- Real-time standings updates
- Team performance tracking
- Season comparisons

### ⚽ Match Analysis

- Detailed match events
- Player touch mapping
- Shot and pass visualization
- Team statistics

### 📊 Data Visualization

- Interactive football pitch
- Event heatmaps
- Performance metrics
- Statistical comparisons

### 🔄 Live Updates

- Automatic data synchronization
- Real-time standings updates
- Match event tracking

## Technology Stack

### Backend

- Django/Django REST Framework
- StatsBomb Python API
- PostgreSQL
- Python 3.10+

### Frontend

- React
- React Router
- Tailwind CSS
